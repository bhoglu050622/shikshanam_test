"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"](751,{

/***/ 509:
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/esm/server/request/draft-mode.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   draftMode: () => (/* binding */ draftMode)\n/* harmony export */ });\n/* harmony import */ var _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ 6460);\n/* harmony import */ var _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app-render/work-async-storage.external */ 1983);\n/* harmony import */ var _app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app-render/dynamic-rendering */ 1163);\n/* harmony import */ var _create_deduped_by_callsite_server_error_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ 1932);\n/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../client/components/static-generation-bailout */ 4979);\n/* harmony import */ var _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../client/components/hooks-server-context */ 6159);\n/* harmony import */ var _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../shared/lib/invariant-error */ 9809);\n/* harmony import */ var _web_spec_extension_adapters_reflect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ 4115);\n\n\n\n\n\n\n\n\n\nfunction draftMode() {\n    const callingExpression = 'draftMode';\n    const workStore = _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_1__.workAsyncStorage.getStore();\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_0__.workUnitAsyncStorage.getStore();\n    if (!workStore || !workUnitStore) {\n        (0,_app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_0__.throwForMissingRequestStore)(callingExpression);\n    }\n    switch(workUnitStore.type){\n        case 'prerender-runtime':\n            // TODO(runtime-ppr): does it make sense to delay this? normally it's always microtasky\n            return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.delayUntilRuntimeStage)(workUnitStore, createOrGetCachedDraftMode(workUnitStore.draftMode, workStore));\n        case 'request':\n            return createOrGetCachedDraftMode(workUnitStore.draftMode, workStore);\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n            // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n            // the outmost work unit store is a request store (or a runtime prerender),\n            // and if draft mode is enabled.\n            const draftModeProvider = (0,_app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_0__.getDraftModeProviderForCacheScope)(workStore, workUnitStore);\n            if (draftModeProvider) {\n                return createOrGetCachedDraftMode(draftModeProvider, workStore);\n            }\n        // Otherwise, we fall through to providing an empty draft mode.\n        // eslint-disable-next-line no-fallthrough\n        case 'prerender':\n        case 'prerender-client':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n            // Return empty draft mode\n            return createOrGetCachedDraftMode(null, workStore);\n        default:\n            return workUnitStore;\n    }\n}\nfunction createOrGetCachedDraftMode(draftModeProvider, workStore) {\n    const cacheKey = draftModeProvider ?? NullDraftMode;\n    const cachedDraftMode = CachedDraftModes.get(cacheKey);\n    if (cachedDraftMode) {\n        return cachedDraftMode;\n    }\n    let promise;\n    if ( true && !(workStore == null ? void 0 : workStore.isPrefetchRequest)) {\n        const route = workStore == null ? void 0 : workStore.route;\n        if (false) {}\n        promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route);\n    } else {\n        if (false) {}\n        promise = createExoticDraftMode(draftModeProvider);\n    }\n    CachedDraftModes.set(cacheKey, promise);\n    return promise;\n}\nconst NullDraftMode = {};\nconst CachedDraftModes = new WeakMap();\nfunction createExoticDraftMode(underlyingProvider) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    Object.defineProperty(promise, 'isEnabled', {\n        get () {\n            return instance.isEnabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    promise.enable = instance.enable.bind(instance);\n    promise.disable = instance.disable.bind(instance);\n    return promise;\n}\nfunction createExoticDraftModeWithDevWarnings(underlyingProvider, route) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    Object.defineProperty(promise, 'isEnabled', {\n        get () {\n            const expression = '`draftMode().isEnabled`';\n            syncIODev(route, expression);\n            return instance.isEnabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(promise, 'enable', {\n        value: function get() {\n            const expression = '`draftMode().enable()`';\n            syncIODev(route, expression);\n            return instance.enable.apply(instance, arguments);\n        }\n    });\n    Object.defineProperty(promise, 'disable', {\n        value: function get() {\n            const expression = '`draftMode().disable()`';\n            syncIODev(route, expression);\n            return instance.disable.apply(instance, arguments);\n        }\n    });\n    return promise;\n}\n// Similar to `createExoticDraftModeWithDevWarnings`, but just logging the sync\n// access without actually defining the draftMode properties on the promise.\nfunction createDraftModeWithDevWarnings(underlyingProvider, route) {\n    const instance = new DraftMode(underlyingProvider);\n    const promise = Promise.resolve(instance);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            switch(prop){\n                case 'isEnabled':\n                    warnForSyncAccess(route, `\\`draftMode().${prop}\\``);\n                    break;\n                case 'enable':\n                case 'disable':\n                    {\n                        warnForSyncAccess(route, `\\`draftMode().${prop}()\\``);\n                        break;\n                    }\n                default:\n                    {\n                    // We only warn for well-defined properties of the draftMode object.\n                    }\n            }\n            return _web_spec_extension_adapters_reflect__WEBPACK_IMPORTED_MODULE_7__.ReflectAdapter.get(target, prop, receiver);\n        }\n    });\n    return proxiedPromise;\n}\nclass DraftMode {\n    constructor(provider){\n        this._provider = provider;\n    }\n    get isEnabled() {\n        if (this._provider !== null) {\n            return this._provider.isEnabled;\n        }\n        return false;\n    }\n    enable() {\n        // We have a store we want to track dynamic data access to ensure we\n        // don't statically generate routes that manipulate draft mode.\n        trackDynamicDraftMode('draftMode().enable()', this.enable);\n        if (this._provider !== null) {\n            this._provider.enable();\n        }\n    }\n    disable() {\n        trackDynamicDraftMode('draftMode().disable()', this.disable);\n        if (this._provider !== null) {\n            this._provider.disable();\n        }\n    }\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_0__.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.trackSynchronousRequestDataAccessInDev)(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = (0,_create_deduped_by_callsite_server_error_logger__WEBPACK_IMPORTED_MODULE_3__.createDedupedByCallsiteServerErrorLoggerDev)(createDraftModeAccessError);\nfunction createDraftModeAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`draftMode()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E377\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction trackDynamicDraftMode(expression, constructorOpt) {\n    const workStore = _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_1__.workAsyncStorage.getStore();\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_0__.workUnitAsyncStorage.getStore();\n    if (workStore) {\n        // We have a store we want to track dynamic data access to ensure we\n        // don't statically generate routes that manipulate draft mode.\n        if ((workUnitStore == null ? void 0 : workUnitStore.phase) === 'after') {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E348\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_4__.StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E553\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'cache':\n                case 'private-cache':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E246\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, constructorOpt);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'unstable-cache':\n                    throw Object.defineProperty(new Error(`Route ${workStore.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E259\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender':\n                case 'prerender-runtime':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E126\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.abortAndThrowOnSynchronousRequestDataAccess)(workStore.route, expression, error, workUnitStore);\n                    }\n                case 'prerender-client':\n                    const exportName = '`draftMode`';\n                    throw Object.defineProperty(new _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_6__.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E693\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender-ppr':\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.postponeWithTracking)(workStore.route, expression, workUnitStore.dynamicTracking);\n                case 'prerender-legacy':\n                    workUnitStore.revalidate = 0;\n                    const err = Object.defineProperty(new _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_5__.DynamicServerError(`Route ${workStore.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E558\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    workStore.dynamicUsageDescription = expression;\n                    workStore.dynamicUsageStack = err.stack;\n                    throw err;\n                case 'request':\n                    (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.trackDynamicDataInDynamicRender)(workUnitStore);\n                    break;\n                default:\n                    workUnitStore;\n            }\n        }\n    }\n} //# sourceMappingURL=draft-mode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDhGQUErQkEsQ0FBQ1c7b0JBQ2hDO2dCQUNGO29CQUNFQTtZQUNKO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvYW1hbmJob2dhbC9zcmMvc2VydmVyL3JlcXVlc3QvZHJhZnQtbW9kZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBnZXREcmFmdE1vZGVQcm92aWRlckZvckNhY2hlU2NvcGUsXG4gIHRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZSxcbn0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLXVuaXQtYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcblxuaW1wb3J0IHR5cGUgeyBEcmFmdE1vZGVQcm92aWRlciB9IGZyb20gJy4uL2FzeW5jLXN0b3JhZ2UvZHJhZnQtbW9kZS1wcm92aWRlcidcblxuaW1wb3J0IHtcbiAgd29ya0FzeW5jU3RvcmFnZSxcbiAgdHlwZSBXb3JrU3RvcmUsXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgd29ya1VuaXRBc3luY1N0b3JhZ2UgfSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHtcbiAgYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcyxcbiAgZGVsYXlVbnRpbFJ1bnRpbWVTdGFnZSxcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcsXG4gIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIsXG4gIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2LFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiB9IGZyb20gJy4uL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXInXG5pbXBvcnQgeyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IgfSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9zdGF0aWMtZ2VuZXJhdGlvbi1iYWlsb3V0J1xuaW1wb3J0IHsgRHluYW1pY1NlcnZlckVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvaG9va3Mtc2VydmVyLWNvbnRleHQnXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuaW1wb3J0IHsgUmVmbGVjdEFkYXB0ZXIgfSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVmbGVjdCdcblxuLyoqXG4gKiBJbiB0aGlzIHZlcnNpb24gb2YgTmV4dC5qcyBgZHJhZnRNb2RlKClgIHJldHVybnMgYSBQcm9taXNlIGhvd2V2ZXIgeW91IGNhbiBzdGlsbCByZWZlcmVuY2UgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHVuZGVybHlpbmcgZHJhZnRNb2RlIG9iamVjdFxuICogc3luY2hyb25vdXNseSB0byBmYWNpbGl0YXRlIG1pZ3JhdGlvbi4gVGhlIGBVbnNhZmVVbndyYXBwZWREcmFmdE1vZGVgIHR5cGUgaXMgYWRkZWQgdG8geW91ciBjb2RlIGJ5IGEgY29kZW1vZCB0aGF0IGF0dGVtcHRzIHRvIGF1dG9tYXRpY2FsbHlcbiAqIHVwZGF0ZXMgY2FsbHNpdGVzIHRvIHJlZmxlY3QgdGhlIG5ldyBQcm9taXNlIHJldHVybiB0eXBlLiBUaGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSBgZHJhZnRNb2RlKClgIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCwgbmFtZWx5XG4gKiB3aGVuIGl0IGlzIHVzZWQgaW5zaWRlIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gYW5kIHdlIGNhbid0IGJlIHN1cmUgdGhlIGZ1bmN0aW9uIGNhbiBiZSBtYWRlIGFzeW5jIGF1dG9tYXRpY2FsbHkuIEluIHRoZXNlIGNhc2VzIHdlIGFkZCBhblxuICogZXhwbGljaXQgdHlwZSBjYXNlIHRvIGBVbnNhZmVVbndyYXBwZWREcmFmdE1vZGVgIHRvIGVuYWJsZSB0eXBlc2NyaXB0IHRvIGFsbG93IGZvciB0aGUgc3luY2hyb25vdXMgdXNhZ2Ugb25seSB3aGVyZSBpdCBpcyBhY3R1YWxseSBuZWNlc3NhcnkuXG4gKlxuICogWW91IHNob3VsZCBzaG91bGQgdXBkYXRlIHRoZXNlIGNhbGxzaXRlcyB0byBlaXRoZXIgYmUgYXN5bmMgZnVuY3Rpb25zIHdoZXJlIHRoZSBgZHJhZnRNb2RlKClgIHZhbHVlIGNhbiBiZSBhd2FpdGVkIG9yIHlvdSBzaG91bGQgY2FsbCBgZHJhZnRNb2RlKClgXG4gKiBmcm9tIG91dHNpZGUgYW5kIGF3YWl0IHRoZSByZXR1cm4gdmFsdWUgYmVmb3JlIHBhc3NpbmcgaXQgaW50byB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIFlvdSBjYW4gZmluZCBpbnN0YW5jZXMgdGhhdCByZXF1aXJlIG1hbnVhbCBtaWdyYXRpb24gYnkgc2VhcmNoaW5nIGZvciBgVW5zYWZlVW53cmFwcGVkRHJhZnRNb2RlYCBpbiB5b3VyIGNvZGViYXNlIG9yIGJ5IHNlYXJjaCBmb3IgYSBjb21tZW50IHRoYXRcbiAqIHN0YXJ0cyB3aXRoIGBAbmV4dC1jb2RlbW9kLWVycm9yYC5cbiAqXG4gKiBJbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIE5leHQuanMgYGRyYWZ0TW9kZSgpYCB3aWxsIG9ubHkgcmV0dXJuIGEgUHJvbWlzZSBhbmQgeW91IHdpbGwgbm90IGJlIGFibGUgdG8gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIGRyYWZ0TW9kZSBvYmplY3QgZGlyZWN0bHlcbiAqIHdpdGhvdXQgYXdhaXRpbmcgdGhlIHJldHVybiB2YWx1ZSBmaXJzdC4gV2hlbiB0aGlzIGNoYW5nZSBoYXBwZW5zIHRoZSB0eXBlIGBVbnNhZmVVbndyYXBwZWREcmFmdE1vZGVgIHdpbGwgYmUgdXBkYXRlZCB0byByZWZsZWN0IHRoYXQgaXMgaXQgbm8gbG9uZ2VyXG4gKiB1c2FibGUuXG4gKlxuICogVGhpcyB0eXBlIGlzIG1hcmtlZCBkZXByZWNhdGVkIHRvIGhlbHAgaWRlbnRpZnkgaXQgYXMgdGFyZ2V0IGZvciByZWZhY3RvcmluZyBhd2F5LlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCB0eXBlIFVuc2FmZVVud3JhcHBlZERyYWZ0TW9kZSA9IERyYWZ0TW9kZVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhZnRNb2RlKCk6IFByb21pc2U8RHJhZnRNb2RlPiB7XG4gIGNvbnN0IGNhbGxpbmdFeHByZXNzaW9uID0gJ2RyYWZ0TW9kZSdcbiAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKCF3b3JrU3RvcmUgfHwgIXdvcmtVbml0U3RvcmUpIHtcbiAgICB0aHJvd0Zvck1pc3NpbmdSZXF1ZXN0U3RvcmUoY2FsbGluZ0V4cHJlc3Npb24pXG4gIH1cblxuICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgIGNhc2UgJ3ByZXJlbmRlci1ydW50aW1lJzpcbiAgICAgIC8vIFRPRE8ocnVudGltZS1wcHIpOiBkb2VzIGl0IG1ha2Ugc2Vuc2UgdG8gZGVsYXkgdGhpcz8gbm9ybWFsbHkgaXQncyBhbHdheXMgbWljcm90YXNreVxuICAgICAgcmV0dXJuIGRlbGF5VW50aWxSdW50aW1lU3RhZ2UoXG4gICAgICAgIHdvcmtVbml0U3RvcmUsXG4gICAgICAgIGNyZWF0ZU9yR2V0Q2FjaGVkRHJhZnRNb2RlKHdvcmtVbml0U3RvcmUuZHJhZnRNb2RlLCB3b3JrU3RvcmUpXG4gICAgICApXG4gICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICByZXR1cm4gY3JlYXRlT3JHZXRDYWNoZWREcmFmdE1vZGUod29ya1VuaXRTdG9yZS5kcmFmdE1vZGUsIHdvcmtTdG9yZSlcblxuICAgIGNhc2UgJ2NhY2hlJzpcbiAgICBjYXNlICdwcml2YXRlLWNhY2hlJzpcbiAgICBjYXNlICd1bnN0YWJsZS1jYWNoZSc6XG4gICAgICAvLyBJbnNpZGUgb2YgYFwidXNlIGNhY2hlXCJgIG9yIGB1bnN0YWJsZV9jYWNoZWAsIGRyYWZ0IG1vZGUgaXMgYXZhaWxhYmxlIGlmXG4gICAgICAvLyB0aGUgb3V0bW9zdCB3b3JrIHVuaXQgc3RvcmUgaXMgYSByZXF1ZXN0IHN0b3JlIChvciBhIHJ1bnRpbWUgcHJlcmVuZGVyKSxcbiAgICAgIC8vIGFuZCBpZiBkcmFmdCBtb2RlIGlzIGVuYWJsZWQuXG4gICAgICBjb25zdCBkcmFmdE1vZGVQcm92aWRlciA9IGdldERyYWZ0TW9kZVByb3ZpZGVyRm9yQ2FjaGVTY29wZShcbiAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICB3b3JrVW5pdFN0b3JlXG4gICAgICApXG5cbiAgICAgIGlmIChkcmFmdE1vZGVQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gY3JlYXRlT3JHZXRDYWNoZWREcmFmdE1vZGUoZHJhZnRNb2RlUHJvdmlkZXIsIHdvcmtTdG9yZSlcbiAgICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgd2UgZmFsbCB0aHJvdWdoIHRvIHByb3ZpZGluZyBhbiBlbXB0eSBkcmFmdCBtb2RlLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAvLyBSZXR1cm4gZW1wdHkgZHJhZnQgbW9kZVxuICAgICAgcmV0dXJuIGNyZWF0ZU9yR2V0Q2FjaGVkRHJhZnRNb2RlKG51bGwsIHdvcmtTdG9yZSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gd29ya1VuaXRTdG9yZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPckdldENhY2hlZERyYWZ0TW9kZShcbiAgZHJhZnRNb2RlUHJvdmlkZXI6IERyYWZ0TW9kZVByb3ZpZGVyIHwgbnVsbCxcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUgfCB1bmRlZmluZWRcbik6IFByb21pc2U8RHJhZnRNb2RlPiB7XG4gIGNvbnN0IGNhY2hlS2V5ID0gZHJhZnRNb2RlUHJvdmlkZXIgPz8gTnVsbERyYWZ0TW9kZVxuICBjb25zdCBjYWNoZWREcmFmdE1vZGUgPSBDYWNoZWREcmFmdE1vZGVzLmdldChjYWNoZUtleSlcblxuICBpZiAoY2FjaGVkRHJhZnRNb2RlKSB7XG4gICAgcmV0dXJuIGNhY2hlZERyYWZ0TW9kZVxuICB9XG5cbiAgbGV0IHByb21pc2U6IFByb21pc2U8RHJhZnRNb2RlPlxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhd29ya1N0b3JlPy5pc1ByZWZldGNoUmVxdWVzdCkge1xuICAgIGNvbnN0IHJvdXRlID0gd29ya1N0b3JlPy5yb3V0ZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DQUNIRV9DT01QT05FTlRTKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRHJhZnRNb2RlV2l0aERldldhcm5pbmdzKGRyYWZ0TW9kZVByb3ZpZGVyLCByb3V0ZSlcbiAgICB9XG5cbiAgICBwcm9taXNlID0gY3JlYXRlRXhvdGljRHJhZnRNb2RlV2l0aERldldhcm5pbmdzKGRyYWZ0TW9kZVByb3ZpZGVyLCByb3V0ZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NBQ0hFX0NPTVBPTkVOVFMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IERyYWZ0TW9kZShkcmFmdE1vZGVQcm92aWRlcikpXG4gICAgfVxuXG4gICAgcHJvbWlzZSA9IGNyZWF0ZUV4b3RpY0RyYWZ0TW9kZShkcmFmdE1vZGVQcm92aWRlcilcbiAgfVxuXG4gIENhY2hlZERyYWZ0TW9kZXMuc2V0KGNhY2hlS2V5LCBwcm9taXNlKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmludGVyZmFjZSBDYWNoZUxpZmV0aW1lIHt9XG5jb25zdCBOdWxsRHJhZnRNb2RlID0ge31cbmNvbnN0IENhY2hlZERyYWZ0TW9kZXMgPSBuZXcgV2Vha01hcDxDYWNoZUxpZmV0aW1lLCBQcm9taXNlPERyYWZ0TW9kZT4+KClcblxuZnVuY3Rpb24gY3JlYXRlRXhvdGljRHJhZnRNb2RlKFxuICB1bmRlcmx5aW5nUHJvdmlkZXI6IG51bGwgfCBEcmFmdE1vZGVQcm92aWRlclxuKTogUHJvbWlzZTxEcmFmdE1vZGU+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgRHJhZnRNb2RlKHVuZGVybHlpbmdQcm92aWRlcilcbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ2lzRW5hYmxlZCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuaXNFbmFibGVkXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgfSlcbiAgOyhwcm9taXNlIGFzIGFueSkuZW5hYmxlID0gaW5zdGFuY2UuZW5hYmxlLmJpbmQoaW5zdGFuY2UpXG4gIDsocHJvbWlzZSBhcyBhbnkpLmRpc2FibGUgPSBpbnN0YW5jZS5kaXNhYmxlLmJpbmQoaW5zdGFuY2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXhvdGljRHJhZnRNb2RlV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nUHJvdmlkZXI6IG51bGwgfCBEcmFmdE1vZGVQcm92aWRlcixcbiAgcm91dGU6IHVuZGVmaW5lZCB8IHN0cmluZ1xuKTogUHJvbWlzZTxEcmFmdE1vZGU+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSBuZXcgRHJhZnRNb2RlKHVuZGVybHlpbmdQcm92aWRlcilcbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShpbnN0YW5jZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ2lzRW5hYmxlZCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BkcmFmdE1vZGUoKS5pc0VuYWJsZWRgJ1xuICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgcmV0dXJuIGluc3RhbmNlLmlzRW5hYmxlZFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsICdlbmFibGUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGRyYWZ0TW9kZSgpLmVuYWJsZSgpYCdcbiAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgIHJldHVybiBpbnN0YW5jZS5lbmFibGUuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgfSxcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgJ2Rpc2FibGUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGRyYWZ0TW9kZSgpLmRpc2FibGUoKWAnXG4gICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICByZXR1cm4gaW5zdGFuY2UuZGlzYWJsZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzIGFzIGFueSlcbiAgICB9LFxuICB9KVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbi8vIFNpbWlsYXIgdG8gYGNyZWF0ZUV4b3RpY0RyYWZ0TW9kZVdpdGhEZXZXYXJuaW5nc2AsIGJ1dCBqdXN0IGxvZ2dpbmcgdGhlIHN5bmNcbi8vIGFjY2VzcyB3aXRob3V0IGFjdHVhbGx5IGRlZmluaW5nIHRoZSBkcmFmdE1vZGUgcHJvcGVydGllcyBvbiB0aGUgcHJvbWlzZS5cbmZ1bmN0aW9uIGNyZWF0ZURyYWZ0TW9kZVdpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ1Byb3ZpZGVyOiBudWxsIHwgRHJhZnRNb2RlUHJvdmlkZXIsXG4gIHJvdXRlOiB1bmRlZmluZWQgfCBzdHJpbmdcbik6IFByb21pc2U8RHJhZnRNb2RlPiB7XG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IERyYWZ0TW9kZSh1bmRlcmx5aW5nUHJvdmlkZXIpXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoaW5zdGFuY2UpXG5cbiAgY29uc3QgcHJveGllZFByb21pc2UgPSBuZXcgUHJveHkocHJvbWlzZSwge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSAnaXNFbmFibGVkJzpcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgYFxcYGRyYWZ0TW9kZSgpLiR7cHJvcH1cXGBgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICAgIGNhc2UgJ2Rpc2FibGUnOiB7XG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGBcXGBkcmFmdE1vZGUoKS4ke3Byb3B9KClcXGBgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIC8vIFdlIG9ubHkgd2FybiBmb3Igd2VsbC1kZWZpbmVkIHByb3BlcnRpZXMgb2YgdGhlIGRyYWZ0TW9kZSBvYmplY3QuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gIH0pXG5cbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmNsYXNzIERyYWZ0TW9kZSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgLSB0aGlzIGRlY2xhcmF0aW9uIGlzIHN0cmlwcGVkIHZpYSBgdHNjIC0tc3RyaXBJbnRlcm5hbGBcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgX3Byb3ZpZGVyOiBudWxsIHwgRHJhZnRNb2RlUHJvdmlkZXJcblxuICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogbnVsbCB8IERyYWZ0TW9kZVByb3ZpZGVyKSB7XG4gICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlclxuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXIuaXNFbmFibGVkXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHB1YmxpYyBlbmFibGUoKSB7XG4gICAgLy8gV2UgaGF2ZSBhIHN0b3JlIHdlIHdhbnQgdG8gdHJhY2sgZHluYW1pYyBkYXRhIGFjY2VzcyB0byBlbnN1cmUgd2VcbiAgICAvLyBkb24ndCBzdGF0aWNhbGx5IGdlbmVyYXRlIHJvdXRlcyB0aGF0IG1hbmlwdWxhdGUgZHJhZnQgbW9kZS5cbiAgICB0cmFja0R5bmFtaWNEcmFmdE1vZGUoJ2RyYWZ0TW9kZSgpLmVuYWJsZSgpJywgdGhpcy5lbmFibGUpXG4gICAgaWYgKHRoaXMuX3Byb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9wcm92aWRlci5lbmFibGUoKVxuICAgIH1cbiAgfVxuICBwdWJsaWMgZGlzYWJsZSgpIHtcbiAgICB0cmFja0R5bmFtaWNEcmFmdE1vZGUoJ2RyYWZ0TW9kZSgpLmRpc2FibGUoKScsIHRoaXMuZGlzYWJsZSlcbiAgICBpZiAodGhpcy5fcHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3Byb3ZpZGVyLmRpc2FibGUoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jSU9EZXYocm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnByZXJlbmRlclBoYXNlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2LCB3ZSBuZWVkIHRvIGFkdmFuY2Ugb3V0IG9mXG4gICAgICAgICAgLy8gdGhlIFByZXJlbmRlciBlbnZpcm9ubWVudCB3aGVuIHdlIHJlYWQgUmVxdWVzdCBkYXRhIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYod29ya1VuaXRTdG9yZSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXJ1bnRpbWUnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgIGNhc2UgJ2NhY2hlJzpcbiAgICAgIGNhc2UgJ3ByaXZhdGUtY2FjaGUnOlxuICAgICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd29ya1VuaXRTdG9yZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICB9XG4gIH1cblxuICAvLyBJbiBhbGwgY2FzZXMgd2Ugd2FybiBub3JtYWxseVxuICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbilcbn1cblxuY29uc3Qgd2FybkZvclN5bmNBY2Nlc3MgPSBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KFxuICBjcmVhdGVEcmFmdE1vZGVBY2Nlc3NFcnJvclxuKVxuXG5mdW5jdGlvbiBjcmVhdGVEcmFmdE1vZGVBY2Nlc3NFcnJvcihcbiAgcm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gcm91dGUgPyBgUm91dGUgXCIke3JvdXRlfVwiIGAgOiAnVGhpcyByb3V0ZSAnXG4gIHJldHVybiBuZXcgRXJyb3IoXG4gICAgYCR7cHJlZml4fXVzZWQgJHtleHByZXNzaW9ufS4gYCArXG4gICAgICBgXFxgZHJhZnRNb2RlKClcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyB2YWx1ZS4gYCArXG4gICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gIClcbn1cblxuZnVuY3Rpb24gdHJhY2tEeW5hbWljRHJhZnRNb2RlKGV4cHJlc3Npb246IHN0cmluZywgY29uc3RydWN0b3JPcHQ6IEZ1bmN0aW9uKSB7XG4gIGNvbnN0IHdvcmtTdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuXG4gIGlmICh3b3JrU3RvcmUpIHtcbiAgICAvLyBXZSBoYXZlIGEgc3RvcmUgd2Ugd2FudCB0byB0cmFjayBkeW5hbWljIGRhdGEgYWNjZXNzIHRvIGVuc3VyZSB3ZVxuICAgIC8vIGRvbid0IHN0YXRpY2FsbHkgZ2VuZXJhdGUgcm91dGVzIHRoYXQgbWFuaXB1bGF0ZSBkcmFmdCBtb2RlLlxuICAgIGlmICh3b3JrVW5pdFN0b3JlPy5waGFzZSA9PT0gJ2FmdGVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCIke2V4cHJlc3Npb259XCIgaW5zaWRlIFxcYGFmdGVyXFxgLiBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgZHJhZnRNb2RlIGNhbiBiZSByZWFkIGluc2lkZSBcXGBhZnRlclxcYCBidXQgeW91IGNhbm5vdCBlbmFibGUgb3IgZGlzYWJsZSBkcmFmdE1vZGUuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvZnVuY3Rpb25zL2FmdGVyYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NhY2hlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZS1jYWNoZSc6IHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcIiR7ZXhwcmVzc2lvbn1cIiBpbnNpZGUgXCJ1c2UgY2FjaGVcIi4gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGRyYWZ0TW9kZSBjYW4gYmUgcmVhZCBpbiBjYWNoZXMgYnV0IHlvdSBtdXN0IG5vdCBlbmFibGUgb3IgZGlzYWJsZSBkcmFmdE1vZGUgaW5zaWRlIGEgY2FjaGUuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1yZXF1ZXN0LWluLXVzZS1jYWNoZWBcbiAgICAgICAgICApXG4gICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGNvbnN0cnVjdG9yT3B0KVxuICAgICAgICAgIHdvcmtTdG9yZS5pbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IgPz89IGVycm9yXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd1bnN0YWJsZS1jYWNoZSc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB1c2VkIFwiJHtleHByZXNzaW9ufVwiIGluc2lkZSBhIGZ1bmN0aW9uIGNhY2hlZCB3aXRoIFwidW5zdGFibGVfY2FjaGUoLi4uKVwiLiBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgZHJhZnRNb2RlIGNhbiBiZSByZWFkIGluIGNhY2hlcyBidXQgeW91IG11c3Qgbm90IGVuYWJsZSBvciBkaXNhYmxlIGRyYWZ0TW9kZSBpbnNpZGUgYSBjYWNoZS4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdW5zdGFibGVfY2FjaGVgXG4gICAgICAgICAgKVxuXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1ydW50aW1lJzoge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB1c2VkICR7ZXhwcmVzc2lvbn0gd2l0aG91dCBmaXJzdCBjYWxsaW5nIFxcYGF3YWl0IGNvbm5lY3Rpb24oKVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXByZXJlbmRlci1zeW5jLWhlYWRlcnNgXG4gICAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzKFxuICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgICAgICBjb25zdCBleHBvcnROYW1lID0gJ2BkcmFmdE1vZGVgJ1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAgIGAke2V4cG9ydE5hbWV9IG11c3Qgbm90IGJlIHVzZWQgd2l0aGluIGEgY2xpZW50IGNvbXBvbmVudC4gTmV4dC5qcyBzaG91bGQgYmUgcHJldmVudGluZyAke2V4cG9ydE5hbWV9IGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gY2xpZW50IGNvbXBvbmVudHMgc3RhdGljYWxseSwgYnV0IGRpZCBub3QgaW4gdGhpcyBjYXNlLmBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgIHJldHVybiBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgIClcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgICAgd29ya1VuaXRTdG9yZS5yZXZhbGlkYXRlID0gMFxuXG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IER5bmFtaWNTZXJ2ZXJFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgJHtleHByZXNzaW9ufVxcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9keW5hbWljLXNlcnZlci1lcnJvcmBcbiAgICAgICAgICApXG4gICAgICAgICAgd29ya1N0b3JlLmR5bmFtaWNVc2FnZURlc2NyaXB0aW9uID0gZXhwcmVzc2lvblxuICAgICAgICAgIHdvcmtTdG9yZS5keW5hbWljVXNhZ2VTdGFjayA9IGVyci5zdGFja1xuXG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgICAgIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIod29ya1VuaXRTdG9yZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdvcmtVbml0U3RvcmUgc2F0aXNmaWVzIG5ldmVyXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiZ2V0RHJhZnRNb2RlUHJvdmlkZXJGb3JDYWNoZVNjb3BlIiwidGhyb3dGb3JNaXNzaW5nUmVxdWVzdFN0b3JlIiwid29ya0FzeW5jU3RvcmFnZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcyIsImRlbGF5VW50aWxSdW50aW1lU3RhZ2UiLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsInRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJEeW5hbWljU2VydmVyRXJyb3IiLCJJbnZhcmlhbnRFcnJvciIsIlJlZmxlY3RBZGFwdGVyIiwiZHJhZnRNb2RlIiwiY2FsbGluZ0V4cHJlc3Npb24iLCJ3b3JrU3RvcmUiLCJnZXRTdG9yZSIsIndvcmtVbml0U3RvcmUiLCJ0eXBlIiwiY3JlYXRlT3JHZXRDYWNoZWREcmFmdE1vZGUiLCJkcmFmdE1vZGVQcm92aWRlciIsImNhY2hlS2V5IiwiTnVsbERyYWZ0TW9kZSIsImNhY2hlZERyYWZ0TW9kZSIsIkNhY2hlZERyYWZ0TW9kZXMiLCJnZXQiLCJwcm9taXNlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiaXNQcmVmZXRjaFJlcXVlc3QiLCJyb3V0ZSIsIl9fTkVYVF9DQUNIRV9DT01QT05FTlRTIiwiY3JlYXRlRHJhZnRNb2RlV2l0aERldldhcm5pbmdzIiwiY3JlYXRlRXhvdGljRHJhZnRNb2RlV2l0aERldldhcm5pbmdzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJEcmFmdE1vZGUiLCJjcmVhdGVFeG90aWNEcmFmdE1vZGUiLCJzZXQiLCJXZWFrTWFwIiwidW5kZXJseWluZ1Byb3ZpZGVyIiwiaW5zdGFuY2UiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImlzRW5hYmxlZCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJlbmFibGUiLCJiaW5kIiwiZGlzYWJsZSIsImV4cHJlc3Npb24iLCJzeW5jSU9EZXYiLCJ2YWx1ZSIsImFwcGx5IiwiYXJndW1lbnRzIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIndhcm5Gb3JTeW5jQWNjZXNzIiwiY29uc3RydWN0b3IiLCJwcm92aWRlciIsIl9wcm92aWRlciIsInRyYWNrRHluYW1pY0RyYWZ0TW9kZSIsInByZXJlbmRlclBoYXNlIiwiY3JlYXRlRHJhZnRNb2RlQWNjZXNzRXJyb3IiLCJwcmVmaXgiLCJFcnJvciIsImNvbnN0cnVjdG9yT3B0IiwicGhhc2UiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJlcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiaW52YWxpZER5bmFtaWNVc2FnZUVycm9yIiwiZXhwb3J0TmFtZSIsImR5bmFtaWNUcmFja2luZyIsInJldmFsaWRhdGUiLCJlcnIiLCJkeW5hbWljVXNhZ2VEZXNjcmlwdGlvbiIsImR5bmFtaWNVc2FnZVN0YWNrIiwic3RhY2siXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///509\n");

/***/ }),

/***/ 594:
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/esm/server/request/headers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headers: () => (/* binding */ headers)\n/* harmony export */ });\n/* harmony import */ var _web_spec_extension_adapters_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../web/spec-extension/adapters/headers */ 1458);\n/* harmony import */ var _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app-render/work-async-storage.external */ 1983);\n/* harmony import */ var _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ 6460);\n/* harmony import */ var _app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../app-render/dynamic-rendering */ 1163);\n/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../client/components/static-generation-bailout */ 4979);\n/* harmony import */ var _dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dynamic-rendering-utils */ 5770);\n/* harmony import */ var _create_deduped_by_callsite_server_error_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ 1932);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ 8823);\n/* harmony import */ var _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../shared/lib/invariant-error */ 9809);\n/* harmony import */ var _web_spec_extension_adapters_reflect__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ 4115);\n\n\n\n\n\n\n\n\n\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */ function headers() {\n    const callingExpression = 'headers';\n    const workStore = _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_1__.workAsyncStorage.getStore();\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_2__.workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !(0,_utils__WEBPACK_IMPORTED_MODULE_7__.isRequestAPICallableInsideAfter)()) {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E367\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic we override all other logic and always just return an empty\n            // headers object without tracking\n            const underlyingHeaders = _web_spec_extension_adapters_headers__WEBPACK_IMPORTED_MODULE_0__.HeadersAdapter.seal(new Headers({}));\n            return makeUntrackedExoticHeaders(underlyingHeaders);\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'cache':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E304\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, headers);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'private-cache':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside \"use cache: private\". Accessing \"headers\" inside a private cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E742\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, headers);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'unstable-cache':\n                    throw Object.defineProperty(new Error(`Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E127\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender':\n                case 'prerender-client':\n                case 'prerender-runtime':\n                case 'prerender-ppr':\n                case 'prerender-legacy':\n                case 'request':\n                    break;\n                default:\n                    workUnitStore;\n            }\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_4__.StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E525\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'prerender':\n                case 'prerender-runtime':\n                    return makeHangingHeaders(workStore, workUnitStore);\n                case 'prerender-client':\n                    const exportName = '`headers`';\n                    throw Object.defineProperty(new _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_8__.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E693\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender-ppr':\n                    // PPR Prerender (no cacheComponents)\n                    // We are prerendering with PPR. We need track dynamic access here eagerly\n                    // to keep continuity with how headers has worked in PPR without cacheComponents.\n                    // TODO consider switching the semantic to throw on property access instead\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_3__.postponeWithTracking)(workStore.route, callingExpression, workUnitStore.dynamicTracking);\n                case 'prerender-legacy':\n                    // Legacy Prerender\n                    // We are in a legacy static generation mode while prerendering\n                    // We track dynamic access here so we don't need to wrap the headers in\n                    // individual property access tracking.\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_3__.throwToInterruptStaticGeneration)(callingExpression, workStore, workUnitStore);\n                case 'request':\n                    (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_3__.trackDynamicDataInDynamicRender)(workUnitStore);\n                    if (true) {\n                        // Semantically we only need the dev tracking when running in `next dev`\n                        // but since you would never use next dev with production NODE_ENV we use this\n                        // as a proxy so we can statically exclude this code from production builds.\n                        if (false) {}\n                        return makeUntrackedExoticHeadersWithDevWarnings(workUnitStore.headers, workStore == null ? void 0 : workStore.route);\n                    } else {}\n                    break;\n                default:\n                    workUnitStore;\n            }\n        }\n    }\n    // If we end up here, there was no work store or work unit store present.\n    (0,_app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_2__.throwForMissingRequestStore)(callingExpression);\n}\nconst CachedHeaders = new WeakMap();\nfunction makeHangingHeaders(workStore, prerenderStore) {\n    const cachedHeaders = CachedHeaders.get(prerenderStore);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_5__.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, '`headers()`');\n    CachedHeaders.set(prerenderStore, promise);\n    return promise;\n}\nfunction makeUntrackedHeaders(underlyingHeaders) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = Promise.resolve(underlyingHeaders);\n    CachedHeaders.set(underlyingHeaders, promise);\n    return promise;\n}\nfunction makeUntrackedExoticHeaders(underlyingHeaders) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = Promise.resolve(underlyingHeaders);\n    CachedHeaders.set(underlyingHeaders, promise);\n    Object.defineProperties(promise, {\n        append: {\n            value: underlyingHeaders.append.bind(underlyingHeaders)\n        },\n        delete: {\n            value: underlyingHeaders.delete.bind(underlyingHeaders)\n        },\n        get: {\n            value: underlyingHeaders.get.bind(underlyingHeaders)\n        },\n        has: {\n            value: underlyingHeaders.has.bind(underlyingHeaders)\n        },\n        set: {\n            value: underlyingHeaders.set.bind(underlyingHeaders)\n        },\n        getSetCookie: {\n            value: underlyingHeaders.getSetCookie.bind(underlyingHeaders)\n        },\n        forEach: {\n            value: underlyingHeaders.forEach.bind(underlyingHeaders)\n        },\n        keys: {\n            value: underlyingHeaders.keys.bind(underlyingHeaders)\n        },\n        values: {\n            value: underlyingHeaders.values.bind(underlyingHeaders)\n        },\n        entries: {\n            value: underlyingHeaders.entries.bind(underlyingHeaders)\n        },\n        [Symbol.iterator]: {\n            value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders)\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticHeadersWithDevWarnings(underlyingHeaders, route) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_5__.makeDevtoolsIOAwarePromise)(underlyingHeaders);\n    CachedHeaders.set(underlyingHeaders, promise);\n    Object.defineProperties(promise, {\n        append: {\n            value: function append() {\n                const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.append.apply(underlyingHeaders, arguments);\n            }\n        },\n        delete: {\n            value: function _delete() {\n                const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.delete.apply(underlyingHeaders, arguments);\n            }\n        },\n        get: {\n            value: function get() {\n                const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.get.apply(underlyingHeaders, arguments);\n            }\n        },\n        has: {\n            value: function has() {\n                const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.has.apply(underlyingHeaders, arguments);\n            }\n        },\n        set: {\n            value: function set() {\n                const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``;\n                syncIODev(route, expression);\n                return underlyingHeaders.set.apply(underlyingHeaders, arguments);\n            }\n        },\n        getSetCookie: {\n            value: function getSetCookie() {\n                const expression = '`headers().getSetCookie()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.getSetCookie.apply(underlyingHeaders, arguments);\n            }\n        },\n        forEach: {\n            value: function forEach() {\n                const expression = '`headers().forEach(...)`';\n                syncIODev(route, expression);\n                return underlyingHeaders.forEach.apply(underlyingHeaders, arguments);\n            }\n        },\n        keys: {\n            value: function keys() {\n                const expression = '`headers().keys()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.keys.apply(underlyingHeaders, arguments);\n            }\n        },\n        values: {\n            value: function values() {\n                const expression = '`headers().values()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.values.apply(underlyingHeaders, arguments);\n            }\n        },\n        entries: {\n            value: function entries() {\n                const expression = '`headers().entries()`';\n                syncIODev(route, expression);\n                return underlyingHeaders.entries.apply(underlyingHeaders, arguments);\n            }\n        },\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`...headers()` or similar iteration';\n                syncIODev(route, expression);\n                return underlyingHeaders[Symbol.iterator].apply(underlyingHeaders, arguments);\n            }\n        }\n    });\n    return promise;\n}\n// Similar to `makeUntrackedExoticHeadersWithDevWarnings`, but just logging the\n// sync access without actually defining the headers properties on the promise.\nfunction makeUntrackedHeadersWithDevWarnings(underlyingHeaders, route) {\n    const cachedHeaders = CachedHeaders.get(underlyingHeaders);\n    if (cachedHeaders) {\n        return cachedHeaders;\n    }\n    const promise = (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_5__.makeDevtoolsIOAwarePromise)(underlyingHeaders);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            switch(prop){\n                case Symbol.iterator:\n                    {\n                        warnForSyncAccess(route, '`...headers()` or similar iteration');\n                        break;\n                    }\n                case 'append':\n                case 'delete':\n                case 'get':\n                case 'has':\n                case 'set':\n                case 'getSetCookie':\n                case 'forEach':\n                case 'keys':\n                case 'values':\n                case 'entries':\n                    {\n                        warnForSyncAccess(route, `\\`headers().${prop}\\``);\n                        break;\n                    }\n                default:\n                    {\n                    // We only warn for well-defined properties of the headers object.\n                    }\n            }\n            return _web_spec_extension_adapters_reflect__WEBPACK_IMPORTED_MODULE_9__.ReflectAdapter.get(target, prop, receiver);\n        }\n    });\n    CachedHeaders.set(underlyingHeaders, proxiedPromise);\n    return proxiedPromise;\n}\nfunction describeNameArg(arg) {\n    return typeof arg === 'string' ? `'${arg}'` : '...';\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_2__.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_3__.trackSynchronousRequestDataAccessInDev)(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = (0,_create_deduped_by_callsite_server_error_logger__WEBPACK_IMPORTED_MODULE_6__.createDedupedByCallsiteServerErrorLoggerDev)(createHeadersAccessError);\nfunction createHeadersAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`headers()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E277\",\n        enumerable: false,\n        configurable: true\n    });\n} //# sourceMappingURL=headers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDaEQ7QUFFQSxTQUFTVCxVQUFVaEQsS0FBeUIsRUFBRTZDLFVBQWtCO0lBQzlELE1BQU1oRCxnQkFBZ0JoQiw4RkFBb0JBLENBQUNlLFFBQVE7SUFFbkQsSUFBSUMsZUFBZTtRQUNqQixPQUFRQSxjQUFjUyxJQUFJO1lBQ3hCLEtBQUs7Z0JBQ0gsSUFBSVQsY0FBYzZELGNBQWMsS0FBSyxNQUFNO29CQUN6QyxxRUFBcUU7b0JBQ3JFLHFFQUFxRTtvQkFDckV6RSxxR0FBc0NBLENBQUNZO2dCQUN6QztnQkFDQTtZQUNGLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNIO1lBQ0Y7Z0JBQ0VBO1FBQ0o7SUFDRjtJQUVBLGdDQUFnQztJQUNoQzJELGtCQUFrQnhELE9BQU82QztBQUMzQjtBQUVBLE1BQU1XLG9CQUFvQm5FLDRIQUEyQ0EsQ0FDbkVzRTtBQUdGLFNBQVNBLHlCQUNQM0QsS0FBeUIsRUFDekI2QyxVQUFrQjtJQUVsQixNQUFNZSxTQUFTNUQsUUFBUSxDQUFDLE9BQU8sRUFBRUEsTUFBTSxFQUFFLENBQUMsR0FBRztJQUM3QyxPQUFPLHFCQUlOLENBSk0sSUFBSUQsTUFDVCxHQUFHNkQsT0FBTyxLQUFLLEVBQUVmLFdBQVcsRUFBRSxDQUFDLEdBQzdCLENBQUMsd0RBQXdELENBQUMsR0FDMUQsQ0FBQyw4REFBOEQsQ0FBQyxHQUg3RDtlQUFBO29CQUFBO3NCQUFBO0lBSVA7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2FtYW5iaG9nYWwvc3JjL3NlcnZlci9yZXF1ZXN0L2hlYWRlcnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSGVhZGVyc0FkYXB0ZXIsXG4gIHR5cGUgUmVhZG9ubHlIZWFkZXJzLFxufSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvaGVhZGVycydcbmltcG9ydCB7XG4gIHdvcmtBc3luY1N0b3JhZ2UsXG4gIHR5cGUgV29ya1N0b3JlLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIHRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZSxcbiAgd29ya1VuaXRBc3luY1N0b3JhZ2UsXG4gIHR5cGUgUHJlcmVuZGVyU3RvcmVNb2Rlcm4sXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICBwb3N0cG9uZVdpdGhUcmFja2luZyxcbiAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24sXG4gIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIsXG4gIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2LFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgU3RhdGljR2VuQmFpbG91dEVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dCdcbmltcG9ydCB7XG4gIG1ha2VEZXZ0b29sc0lPQXdhcmVQcm9taXNlLFxuICBtYWtlSGFuZ2luZ1Byb21pc2UsXG59IGZyb20gJy4uL2R5bmFtaWMtcmVuZGVyaW5nLXV0aWxzJ1xuaW1wb3J0IHsgY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiB9IGZyb20gJy4uL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXInXG5pbXBvcnQgeyBpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyIH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5pbXBvcnQgeyBSZWZsZWN0QWRhcHRlciB9IGZyb20gJy4uL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0J1xuXG4vKipcbiAqIEluIHRoaXMgdmVyc2lvbiBvZiBOZXh0LmpzIGBoZWFkZXJzKClgIHJldHVybnMgYSBQcm9taXNlIGhvd2V2ZXIgeW91IGNhbiBzdGlsbCByZWZlcmVuY2UgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHVuZGVybHlpbmcgSGVhZGVycyBpbnN0YW5jZVxuICogc3luY2hyb25vdXNseSB0byBmYWNpbGl0YXRlIG1pZ3JhdGlvbi4gVGhlIGBVbnNhZmVVbndyYXBwZWRIZWFkZXJzYCB0eXBlIGlzIGFkZGVkIHRvIHlvdXIgY29kZSBieSBhIGNvZGVtb2QgdGhhdCBhdHRlbXB0cyB0byBhdXRvbWF0aWNhbGx5XG4gKiB1cGRhdGVzIGNhbGxzaXRlcyB0byByZWZsZWN0IHRoZSBuZXcgUHJvbWlzZSByZXR1cm4gdHlwZS4gVGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgYGhlYWRlcnMoKWAgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkLCBuYW1lbHlcbiAqIHdoZW4gaXQgaXMgdXNlZCBpbnNpZGUgYSBzeW5jaHJvbm91cyBmdW5jdGlvbiBhbmQgd2UgY2FuJ3QgYmUgc3VyZSB0aGUgZnVuY3Rpb24gY2FuIGJlIG1hZGUgYXN5bmMgYXV0b21hdGljYWxseS4gSW4gdGhlc2UgY2FzZXMgd2UgYWRkIGFuXG4gKiBleHBsaWNpdCB0eXBlIGNhc2UgdG8gYFVuc2FmZVVud3JhcHBlZEhlYWRlcnNgIHRvIGVuYWJsZSB0eXBlc2NyaXB0IHRvIGFsbG93IGZvciB0aGUgc3luY2hyb25vdXMgdXNhZ2Ugb25seSB3aGVyZSBpdCBpcyBhY3R1YWxseSBuZWNlc3NhcnkuXG4gKlxuICogWW91IHNob3VsZCBzaG91bGQgdXBkYXRlIHRoZXNlIGNhbGxzaXRlcyB0byBlaXRoZXIgYmUgYXN5bmMgZnVuY3Rpb25zIHdoZXJlIHRoZSBgaGVhZGVycygpYCB2YWx1ZSBjYW4gYmUgYXdhaXRlZCBvciB5b3Ugc2hvdWxkIGNhbGwgYGhlYWRlcnMoKWBcbiAqIGZyb20gb3V0c2lkZSBhbmQgYXdhaXQgdGhlIHJldHVybiB2YWx1ZSBiZWZvcmUgcGFzc2luZyBpdCBpbnRvIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogWW91IGNhbiBmaW5kIGluc3RhbmNlcyB0aGF0IHJlcXVpcmUgbWFudWFsIG1pZ3JhdGlvbiBieSBzZWFyY2hpbmcgZm9yIGBVbnNhZmVVbndyYXBwZWRIZWFkZXJzYCBpbiB5b3VyIGNvZGViYXNlIG9yIGJ5IHNlYXJjaCBmb3IgYSBjb21tZW50IHRoYXRcbiAqIHN0YXJ0cyB3aXRoIGBAbmV4dC1jb2RlbW9kLWVycm9yYC5cbiAqXG4gKiBJbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIE5leHQuanMgYGhlYWRlcnMoKWAgd2lsbCBvbmx5IHJldHVybiBhIFByb21pc2UgYW5kIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBIZWFkZXJzIGluc3RhbmNlXG4gKiB3aXRob3V0IGF3YWl0aW5nIHRoZSByZXR1cm4gdmFsdWUgZmlyc3QuIFdoZW4gdGhpcyBjaGFuZ2UgaGFwcGVucyB0aGUgdHlwZSBgVW5zYWZlVW53cmFwcGVkSGVhZGVyc2Agd2lsbCBiZSB1cGRhdGVkIHRvIHJlZmxlY3QgdGhhdCBpcyBpdCBubyBsb25nZXJcbiAqIHVzYWJsZS5cbiAqXG4gKiBUaGlzIHR5cGUgaXMgbWFya2VkIGRlcHJlY2F0ZWQgdG8gaGVscCBpZGVudGlmeSBpdCBhcyB0YXJnZXQgZm9yIHJlZmFjdG9yaW5nIGF3YXkuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IHR5cGUgVW5zYWZlVW53cmFwcGVkSGVhZGVycyA9IFJlYWRvbmx5SGVhZGVyc1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byByZWFkIHRoZSBIVFRQIGluY29taW5nIHJlcXVlc3QgaGVhZGVycyBpblxuICogW1NlcnZlciBDb21wb25lbnRzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc2VydmVyLWNvbXBvbmVudHMpLFxuICogW1NlcnZlciBBY3Rpb25zXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL3NlcnZlci1hY3Rpb25zLWFuZC1tdXRhdGlvbnMpLFxuICogW1JvdXRlIEhhbmRsZXJzXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzKSBhbmRcbiAqIFtNaWRkbGV3YXJlXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL21pZGRsZXdhcmUpLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgRG9jczogYGhlYWRlcnNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvaGVhZGVycylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlYWRlcnMoKTogUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+IHtcbiAgY29uc3QgY2FsbGluZ0V4cHJlc3Npb24gPSAnaGVhZGVycydcbiAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtTdG9yZSkge1xuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICAgIHdvcmtVbml0U3RvcmUucGhhc2UgPT09ICdhZnRlcicgJiZcbiAgICAgICFpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyKClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB1c2VkIFwiaGVhZGVyc1wiIGluc2lkZSBcImFmdGVyKC4uLilcIi4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGFuIFwiYWZ0ZXJcIiBjYWxsYmFjaywgdXNlIFwiaGVhZGVyc1wiIG91dHNpZGUgb2YgdGhlIGNhbGxiYWNrLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2NhbmFyeS9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvYWZ0ZXJgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHdvcmtTdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgICAgLy8gaGVhZGVycyBvYmplY3Qgd2l0aG91dCB0cmFja2luZ1xuICAgICAgY29uc3QgdW5kZXJseWluZ0hlYWRlcnMgPSBIZWFkZXJzQWRhcHRlci5zZWFsKG5ldyBIZWFkZXJzKHt9KSlcbiAgICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVycyh1bmRlcmx5aW5nSGVhZGVycylcbiAgICB9XG5cbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY2FjaGUnOiB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJoZWFkZXJzXCIgaW5zaWRlIFwidXNlIGNhY2hlXCIuIEFjY2Vzc2luZyBEeW5hbWljIGRhdGEgc291cmNlcyBpbnNpZGUgYSBjYWNoZSBzY29wZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGEgY2FjaGVkIGZ1bmN0aW9uIHVzZSBcImhlYWRlcnNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXJlcXVlc3QtaW4tdXNlLWNhY2hlYFxuICAgICAgICAgIClcbiAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgaGVhZGVycylcbiAgICAgICAgICB3b3JrU3RvcmUuaW52YWxpZER5bmFtaWNVc2FnZUVycm9yID8/PSBlcnJvclxuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncHJpdmF0ZS1jYWNoZSc6IHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImhlYWRlcnNcIiBpbnNpZGUgXCJ1c2UgY2FjaGU6IHByaXZhdGVcIi4gQWNjZXNzaW5nIFwiaGVhZGVyc1wiIGluc2lkZSBhIHByaXZhdGUgY2FjaGUgc2NvcGUgaXMgbm90IHN1cHBvcnRlZC4gSWYgeW91IG5lZWQgdGhpcyBkYXRhIGluc2lkZSBhIGNhY2hlZCBmdW5jdGlvbiB1c2UgXCJoZWFkZXJzXCIgb3V0c2lkZSBvZiB0aGUgY2FjaGVkIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXF1aXJlZCBkeW5hbWljIGRhdGEgaW4gYXMgYW4gYXJndW1lbnQuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1yZXF1ZXN0LWluLXVzZS1jYWNoZWBcbiAgICAgICAgICApXG4gICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGhlYWRlcnMpXG4gICAgICAgICAgd29ya1N0b3JlLmludmFsaWREeW5hbWljVXNhZ2VFcnJvciA/Pz0gZXJyb3JcbiAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Vuc3RhYmxlLWNhY2hlJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJoZWFkZXJzXCIgaW5zaWRlIGEgZnVuY3Rpb24gY2FjaGVkIHdpdGggXCJ1bnN0YWJsZV9jYWNoZSguLi4pXCIuIEFjY2Vzc2luZyBEeW5hbWljIGRhdGEgc291cmNlcyBpbnNpZGUgYSBjYWNoZSBzY29wZSBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGEgY2FjaGVkIGZ1bmN0aW9uIHVzZSBcImhlYWRlcnNcIiBvdXRzaWRlIG9mIHRoZSBjYWNoZWQgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlcXVpcmVkIGR5bmFtaWMgZGF0YSBpbiBhcyBhbiBhcmd1bWVudC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvdW5zdGFibGVfY2FjaGVgXG4gICAgICAgICAgKVxuICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLXJ1bnRpbWUnOlxuICAgICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd29ya1VuaXRTdG9yZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya1N0b3JlLmR5bmFtaWNTaG91bGRFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcihcbiAgICAgICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB3aXRoIFxcYGR5bmFtaWMgPSBcImVycm9yXCJcXGAgY291bGRuJ3QgYmUgcmVuZGVyZWQgc3RhdGljYWxseSBiZWNhdXNlIGl0IHVzZWQgXFxgaGVhZGVyc1xcYC4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yZW5kZXJpbmcvc3RhdGljLWFuZC1keW5hbWljI2R5bmFtaWMtcmVuZGVyaW5nYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh3b3JrVW5pdFN0b3JlKSB7XG4gICAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgICBjYXNlICdwcmVyZW5kZXItcnVudGltZSc6XG4gICAgICAgICAgcmV0dXJuIG1ha2VIYW5naW5nSGVhZGVycyh3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSAnYGhlYWRlcnNgJ1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAgIGAke2V4cG9ydE5hbWV9IG11c3Qgbm90IGJlIHVzZWQgd2l0aGluIGEgY2xpZW50IGNvbXBvbmVudC4gTmV4dC5qcyBzaG91bGQgYmUgcHJldmVudGluZyAke2V4cG9ydE5hbWV9IGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gY2xpZW50IGNvbXBvbmVudHMgc3RhdGljYWxseSwgYnV0IGRpZCBub3QgaW4gdGhpcyBjYXNlLmBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgIC8vIFBQUiBQcmVyZW5kZXIgKG5vIGNhY2hlQ29tcG9uZW50cylcbiAgICAgICAgICAvLyBXZSBhcmUgcHJlcmVuZGVyaW5nIHdpdGggUFBSLiBXZSBuZWVkIHRyYWNrIGR5bmFtaWMgYWNjZXNzIGhlcmUgZWFnZXJseVxuICAgICAgICAgIC8vIHRvIGtlZXAgY29udGludWl0eSB3aXRoIGhvdyBoZWFkZXJzIGhhcyB3b3JrZWQgaW4gUFBSIHdpdGhvdXQgY2FjaGVDb21wb25lbnRzLlxuICAgICAgICAgIC8vIFRPRE8gY29uc2lkZXIgc3dpdGNoaW5nIHRoZSBzZW1hbnRpYyB0byB0aHJvdyBvbiBwcm9wZXJ0eSBhY2Nlc3MgaW5zdGVhZFxuICAgICAgICAgIHJldHVybiBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgIGNhbGxpbmdFeHByZXNzaW9uLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICAgIC8vIExlZ2FjeSBQcmVyZW5kZXJcbiAgICAgICAgICAvLyBXZSBhcmUgaW4gYSBsZWdhY3kgc3RhdGljIGdlbmVyYXRpb24gbW9kZSB3aGlsZSBwcmVyZW5kZXJpbmdcbiAgICAgICAgICAvLyBXZSB0cmFjayBkeW5hbWljIGFjY2VzcyBoZXJlIHNvIHdlIGRvbid0IG5lZWQgdG8gd3JhcCB0aGUgaGVhZGVycyBpblxuICAgICAgICAgIC8vIGluZGl2aWR1YWwgcHJvcGVydHkgYWNjZXNzIHRyYWNraW5nLlxuICAgICAgICAgIHJldHVybiB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgICAgICAgICAgIGNhbGxpbmdFeHByZXNzaW9uLFxuICAgICAgICAgICAgd29ya1N0b3JlLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZVxuICAgICAgICAgIClcbiAgICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgICAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcih3b3JrVW5pdFN0b3JlKVxuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAvLyBTZW1hbnRpY2FsbHkgd2Ugb25seSBuZWVkIHRoZSBkZXYgdHJhY2tpbmcgd2hlbiBydW5uaW5nIGluIGBuZXh0IGRldmBcbiAgICAgICAgICAgIC8vIGJ1dCBzaW5jZSB5b3Ugd291bGQgbmV2ZXIgdXNlIG5leHQgZGV2IHdpdGggcHJvZHVjdGlvbiBOT0RFX0VOViB3ZSB1c2UgdGhpc1xuICAgICAgICAgICAgLy8gYXMgYSBwcm94eSBzbyB3ZSBjYW4gc3RhdGljYWxseSBleGNsdWRlIHRoaXMgY29kZSBmcm9tIHByb2R1Y3Rpb24gYnVpbGRzLlxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DQUNIRV9DT01QT05FTlRTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgICB3b3JrVW5pdFN0b3JlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgd29ya1N0b3JlPy5yb3V0ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyhcbiAgICAgICAgICAgICAgd29ya1VuaXRTdG9yZS5oZWFkZXJzLFxuICAgICAgICAgICAgICB3b3JrU3RvcmU/LnJvdXRlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0FDSEVfQ09NUE9ORU5UUykge1xuICAgICAgICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEhlYWRlcnMod29ya1VuaXRTdG9yZS5oZWFkZXJzKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnMod29ya1VuaXRTdG9yZS5oZWFkZXJzKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHdvcmtVbml0U3RvcmUgc2F0aXNmaWVzIG5ldmVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIHRoZXJlIHdhcyBubyB3b3JrIHN0b3JlIG9yIHdvcmsgdW5pdCBzdG9yZSBwcmVzZW50LlxuICB0aHJvd0Zvck1pc3NpbmdSZXF1ZXN0U3RvcmUoY2FsbGluZ0V4cHJlc3Npb24pXG59XG5cbmludGVyZmFjZSBDYWNoZUxpZmV0aW1lIHt9XG5jb25zdCBDYWNoZWRIZWFkZXJzID0gbmV3IFdlYWtNYXA8Q2FjaGVMaWZldGltZSwgUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+PigpXG5cbmZ1bmN0aW9uIG1ha2VIYW5naW5nSGVhZGVycyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogUHJvbWlzZTxSZWFkb25seUhlYWRlcnM+IHtcbiAgY29uc3QgY2FjaGVkSGVhZGVycyA9IENhY2hlZEhlYWRlcnMuZ2V0KHByZXJlbmRlclN0b3JlKVxuICBpZiAoY2FjaGVkSGVhZGVycykge1xuICAgIHJldHVybiBjYWNoZWRIZWFkZXJzXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbWFrZUhhbmdpbmdQcm9taXNlPFJlYWRvbmx5SGVhZGVycz4oXG4gICAgcHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLFxuICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAnYGhlYWRlcnMoKWAnXG4gIClcbiAgQ2FjaGVkSGVhZGVycy5zZXQocHJlcmVuZGVyU3RvcmUsIHByb21pc2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEhlYWRlcnMoXG4gIHVuZGVybHlpbmdIZWFkZXJzOiBSZWFkb25seUhlYWRlcnNcbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldCh1bmRlcmx5aW5nSGVhZGVycylcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nSGVhZGVycylcbiAgQ2FjaGVkSGVhZGVycy5zZXQodW5kZXJseWluZ0hlYWRlcnMsIHByb21pc2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnMoXG4gIHVuZGVybHlpbmdIZWFkZXJzOiBSZWFkb25seUhlYWRlcnNcbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldCh1bmRlcmx5aW5nSGVhZGVycylcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlcmx5aW5nSGVhZGVycylcbiAgQ2FjaGVkSGVhZGVycy5zZXQodW5kZXJseWluZ0hlYWRlcnMsIHByb21pc2UpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvbWlzZSwge1xuICAgIGFwcGVuZDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmFwcGVuZC5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGRlbGV0ZToge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmRlbGV0ZS5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGdldDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmdldC5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGhhczoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmhhcy5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIHNldDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLnNldC5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGdldFNldENvb2tpZToge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmdldFNldENvb2tpZS5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIGZvckVhY2g6IHtcbiAgICAgIHZhbHVlOiB1bmRlcmx5aW5nSGVhZGVycy5mb3JFYWNoLmJpbmQodW5kZXJseWluZ0hlYWRlcnMpLFxuICAgIH0sXG4gICAga2V5czoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdIZWFkZXJzLmtleXMuYmluZCh1bmRlcmx5aW5nSGVhZGVycyksXG4gICAgfSxcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZhbHVlOiB1bmRlcmx5aW5nSGVhZGVycy52YWx1ZXMuYmluZCh1bmRlcmx5aW5nSGVhZGVycyksXG4gICAgfSxcbiAgICBlbnRyaWVzOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnMuZW50cmllcy5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB2YWx1ZTogdW5kZXJseWluZ0hlYWRlcnNbU3ltYm9sLml0ZXJhdG9yXS5iaW5kKHVuZGVybHlpbmdIZWFkZXJzKSxcbiAgICB9LFxuICB9IHNhdGlzZmllcyBIZWFkZXJzRXh0ZW5zaW9ucylcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ0hlYWRlcnM6IFJlYWRvbmx5SGVhZGVycyxcbiAgcm91dGU/OiBzdHJpbmdcbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldCh1bmRlcmx5aW5nSGVhZGVycylcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG1ha2VEZXZ0b29sc0lPQXdhcmVQcm9taXNlKHVuZGVybHlpbmdIZWFkZXJzKVxuXG4gIENhY2hlZEhlYWRlcnMuc2V0KHVuZGVybHlpbmdIZWFkZXJzLCBwcm9taXNlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb21pc2UsIHtcbiAgICBhcHBlbmQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmFwcGVuZCgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSwgLi4uKVxcYGBcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuYXBwZW5kLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICAgIGRlbGV0ZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmRlbGV0ZSgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmRlbGV0ZS5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBnZXQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmdldCgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmdldC5hcHBseSh1bmRlcmx5aW5nSGVhZGVycywgYXJndW1lbnRzIGFzIGFueSlcbiAgICAgIH0sXG4gICAgfSxcbiAgICBoYXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLmhhcygke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmhhcy5hcHBseSh1bmRlcmx5aW5nSGVhZGVycywgYXJndW1lbnRzIGFzIGFueSlcbiAgICAgIH0sXG4gICAgfSxcbiAgICBzZXQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBgXFxgaGVhZGVycygpLnNldCgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSwgLi4uKVxcYGBcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuc2V0LmFwcGx5KHVuZGVybHlpbmdIZWFkZXJzLCBhcmd1bWVudHMgYXMgYW55KVxuICAgICAgfSxcbiAgICB9LFxuICAgIGdldFNldENvb2tpZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldENvb2tpZSgpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgaGVhZGVycygpLmdldFNldENvb2tpZSgpYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuZ2V0U2V0Q29va2llLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICAgIGZvckVhY2g6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BoZWFkZXJzKCkuZm9yRWFjaCguLi4pYCdcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0hlYWRlcnMuZm9yRWFjaC5hcHBseShcbiAgICAgICAgICB1bmRlcmx5aW5nSGVhZGVycyxcbiAgICAgICAgICBhcmd1bWVudHMgYXMgYW55XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgfSxcbiAgICBrZXlzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgaGVhZGVycygpLmtleXMoKWAnXG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdIZWFkZXJzLmtleXMuYXBwbHkodW5kZXJseWluZ0hlYWRlcnMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgIH0sXG4gICAgdmFsdWVzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2BoZWFkZXJzKCkudmFsdWVzKClgJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy52YWx1ZXMuYXBwbHkoXG4gICAgICAgICAgdW5kZXJseWluZ0hlYWRlcnMsXG4gICAgICAgICAgYXJndW1lbnRzIGFzIGFueVxuICAgICAgICApXG4gICAgICB9LFxuICAgIH0sXG4gICAgZW50cmllczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAnYGhlYWRlcnMoKS5lbnRyaWVzKClgJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVycy5lbnRyaWVzLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2AuLi5oZWFkZXJzKClgIG9yIHNpbWlsYXIgaXRlcmF0aW9uJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nSGVhZGVyc1tTeW1ib2wuaXRlcmF0b3JdLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdIZWFkZXJzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICB9LFxuICB9IHNhdGlzZmllcyBIZWFkZXJzRXh0ZW5zaW9ucylcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG4vLyBTaW1pbGFyIHRvIGBtYWtlVW50cmFja2VkRXhvdGljSGVhZGVyc1dpdGhEZXZXYXJuaW5nc2AsIGJ1dCBqdXN0IGxvZ2dpbmcgdGhlXG4vLyBzeW5jIGFjY2VzcyB3aXRob3V0IGFjdHVhbGx5IGRlZmluaW5nIHRoZSBoZWFkZXJzIHByb3BlcnRpZXMgb24gdGhlIHByb21pc2UuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkSGVhZGVyc1dpdGhEZXZXYXJuaW5ncyhcbiAgdW5kZXJseWluZ0hlYWRlcnM6IFJlYWRvbmx5SGVhZGVycyxcbiAgcm91dGU/OiBzdHJpbmdcbik6IFByb21pc2U8UmVhZG9ubHlIZWFkZXJzPiB7XG4gIGNvbnN0IGNhY2hlZEhlYWRlcnMgPSBDYWNoZWRIZWFkZXJzLmdldCh1bmRlcmx5aW5nSGVhZGVycylcbiAgaWYgKGNhY2hlZEhlYWRlcnMpIHtcbiAgICByZXR1cm4gY2FjaGVkSGVhZGVyc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG1ha2VEZXZ0b29sc0lPQXdhcmVQcm9taXNlKHVuZGVybHlpbmdIZWFkZXJzKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgU3ltYm9sLml0ZXJhdG9yOiB7XG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsICdgLi4uaGVhZGVycygpYCBvciBzaW1pbGFyIGl0ZXJhdGlvbicpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhcHBlbmQnOlxuICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICBjYXNlICdoYXMnOlxuICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICBjYXNlICdnZXRTZXRDb29raWUnOlxuICAgICAgICBjYXNlICdmb3JFYWNoJzpcbiAgICAgICAgY2FzZSAna2V5cyc6XG4gICAgICAgIGNhc2UgJ3ZhbHVlcyc6XG4gICAgICAgIGNhc2UgJ2VudHJpZXMnOiB7XG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsIGBcXGBoZWFkZXJzKCkuJHtwcm9wfVxcYGApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgLy8gV2Ugb25seSB3YXJuIGZvciB3ZWxsLWRlZmluZWQgcHJvcGVydGllcyBvZiB0aGUgaGVhZGVycyBvYmplY3QuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3RBZGFwdGVyLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKVxuICAgIH0sXG4gIH0pXG5cbiAgQ2FjaGVkSGVhZGVycy5zZXQodW5kZXJseWluZ0hlYWRlcnMsIHByb3hpZWRQcm9taXNlKVxuXG4gIHJldHVybiBwcm94aWVkUHJvbWlzZVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hbWVBcmcoYXJnOiB1bmtub3duKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGAnJHthcmd9J2AgOiAnLi4uJ1xufVxuXG5mdW5jdGlvbiBzeW5jSU9EZXYocm91dGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgIGlmICh3b3JrVW5pdFN0b3JlLnByZXJlbmRlclBoYXNlID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSdyZSByZW5kZXJpbmcgZHluYW1pY2FsbHkgaW4gZGV2LCB3ZSBuZWVkIHRvIGFkdmFuY2Ugb3V0IG9mXG4gICAgICAgICAgLy8gdGhlIFByZXJlbmRlciBlbnZpcm9ubWVudCB3aGVuIHdlIHJlYWQgUmVxdWVzdCBkYXRhIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgdHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYod29ya1VuaXRTdG9yZSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncHJlcmVuZGVyJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXJ1bnRpbWUnOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgIGNhc2UgJ2NhY2hlJzpcbiAgICAgIGNhc2UgJ3ByaXZhdGUtY2FjaGUnOlxuICAgICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgd29ya1VuaXRTdG9yZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICB9XG4gIH1cblxuICAvLyBJbiBhbGwgY2FzZXMgd2Ugd2FybiBub3JtYWxseVxuICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbilcbn1cblxuY29uc3Qgd2FybkZvclN5bmNBY2Nlc3MgPSBjcmVhdGVEZWR1cGVkQnlDYWxsc2l0ZVNlcnZlckVycm9yTG9nZ2VyRGV2KFxuICBjcmVhdGVIZWFkZXJzQWNjZXNzRXJyb3JcbilcblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyc0FjY2Vzc0Vycm9yKFxuICByb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBleHByZXNzaW9uOiBzdHJpbmdcbikge1xuICBjb25zdCBwcmVmaXggPSByb3V0ZSA/IGBSb3V0ZSBcIiR7cm91dGV9XCIgYCA6ICdUaGlzIHJvdXRlICdcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgJHtwcmVmaXh9dXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICAgIGBcXGBoZWFkZXJzKClcXGAgc2hvdWxkIGJlIGF3YWl0ZWQgYmVmb3JlIHVzaW5nIGl0cyB2YWx1ZS4gYCArXG4gICAgICBgTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvc3luYy1keW5hbWljLWFwaXNgXG4gIClcbn1cblxudHlwZSBIZWFkZXJzRXh0ZW5zaW9ucyA9IHtcbiAgW0sgaW4ga2V5b2YgUmVhZG9ubHlIZWFkZXJzXTogdW5rbm93blxufVxuIl0sIm5hbWVzIjpbIkhlYWRlcnNBZGFwdGVyIiwid29ya0FzeW5jU3RvcmFnZSIsInRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwicG9zdHBvbmVXaXRoVHJhY2tpbmciLCJ0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbiIsInRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIiLCJ0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIm1ha2VEZXZ0b29sc0lPQXdhcmVQcm9taXNlIiwibWFrZUhhbmdpbmdQcm9taXNlIiwiY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiIsImlzUmVxdWVzdEFQSUNhbGxhYmxlSW5zaWRlQWZ0ZXIiLCJJbnZhcmlhbnRFcnJvciIsIlJlZmxlY3RBZGFwdGVyIiwiaGVhZGVycyIsImNhbGxpbmdFeHByZXNzaW9uIiwid29ya1N0b3JlIiwiZ2V0U3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwicGhhc2UiLCJFcnJvciIsInJvdXRlIiwiZm9yY2VTdGF0aWMiLCJ1bmRlcmx5aW5nSGVhZGVycyIsInNlYWwiLCJIZWFkZXJzIiwibWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnMiLCJ0eXBlIiwiZXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImludmFsaWREeW5hbWljVXNhZ2VFcnJvciIsImR5bmFtaWNTaG91bGRFcnJvciIsIm1ha2VIYW5naW5nSGVhZGVycyIsImV4cG9ydE5hbWUiLCJkeW5hbWljVHJhY2tpbmciLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfQ0FDSEVfQ09NUE9ORU5UUyIsIm1ha2VVbnRyYWNrZWRIZWFkZXJzV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZEV4b3RpY0hlYWRlcnNXaXRoRGV2V2FybmluZ3MiLCJtYWtlVW50cmFja2VkSGVhZGVycyIsIkNhY2hlZEhlYWRlcnMiLCJXZWFrTWFwIiwicHJlcmVuZGVyU3RvcmUiLCJjYWNoZWRIZWFkZXJzIiwiZ2V0IiwicHJvbWlzZSIsInJlbmRlclNpZ25hbCIsInNldCIsIlByb21pc2UiLCJyZXNvbHZlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsImFwcGVuZCIsInZhbHVlIiwiYmluZCIsImRlbGV0ZSIsImhhcyIsImdldFNldENvb2tpZSIsImZvckVhY2giLCJrZXlzIiwidmFsdWVzIiwiZW50cmllcyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZXhwcmVzc2lvbiIsImRlc2NyaWJlTmFtZUFyZyIsImFyZ3VtZW50cyIsInN5bmNJT0RldiIsImFwcGx5IiwiX2RlbGV0ZSIsInByb3hpZWRQcm9taXNlIiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJ3YXJuRm9yU3luY0FjY2VzcyIsImFyZyIsInByZXJlbmRlclBoYXNlIiwiY3JlYXRlSGVhZGVyc0FjY2Vzc0Vycm9yIiwicHJlZml4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///594\n");

/***/ }),

/***/ 1163:
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Postpone: () => (/* binding */ Postpone),\n/* harmony export */   PreludeState: () => (/* binding */ PreludeState),\n/* harmony export */   abortAndThrowOnSynchronousRequestDataAccess: () => (/* binding */ abortAndThrowOnSynchronousRequestDataAccess),\n/* harmony export */   abortOnSynchronousPlatformIOAccess: () => (/* binding */ abortOnSynchronousPlatformIOAccess),\n/* harmony export */   accessedDynamicData: () => (/* binding */ accessedDynamicData),\n/* harmony export */   annotateDynamicAccess: () => (/* binding */ annotateDynamicAccess),\n/* harmony export */   consumeDynamicAccess: () => (/* binding */ consumeDynamicAccess),\n/* harmony export */   createDynamicTrackingState: () => (/* binding */ createDynamicTrackingState),\n/* harmony export */   createDynamicValidationState: () => (/* binding */ createDynamicValidationState),\n/* harmony export */   createHangingInputAbortSignal: () => (/* binding */ createHangingInputAbortSignal),\n/* harmony export */   createRenderInBrowserAbortSignal: () => (/* binding */ createRenderInBrowserAbortSignal),\n/* harmony export */   delayUntilRuntimeStage: () => (/* binding */ delayUntilRuntimeStage),\n/* harmony export */   formatDynamicAPIAccesses: () => (/* binding */ formatDynamicAPIAccesses),\n/* harmony export */   getFirstDynamicReason: () => (/* binding */ getFirstDynamicReason),\n/* harmony export */   isDynamicPostpone: () => (/* binding */ isDynamicPostpone),\n/* harmony export */   isPrerenderInterruptedError: () => (/* binding */ isPrerenderInterruptedError),\n/* harmony export */   logDisallowedDynamicError: () => (/* binding */ logDisallowedDynamicError),\n/* harmony export */   markCurrentScopeAsDynamic: () => (/* binding */ markCurrentScopeAsDynamic),\n/* harmony export */   postponeWithTracking: () => (/* binding */ postponeWithTracking),\n/* harmony export */   throwIfDisallowedDynamic: () => (/* binding */ throwIfDisallowedDynamic),\n/* harmony export */   throwToInterruptStaticGeneration: () => (/* binding */ throwToInterruptStaticGeneration),\n/* harmony export */   trackAllowedDynamicAccess: () => (/* binding */ trackAllowedDynamicAccess),\n/* harmony export */   trackDynamicDataInDynamicRender: () => (/* binding */ trackDynamicDataInDynamicRender),\n/* harmony export */   trackSynchronousPlatformIOAccessInDev: () => (/* binding */ trackSynchronousPlatformIOAccessInDev),\n/* harmony export */   trackSynchronousRequestDataAccessInDev: () => (/* binding */ trackSynchronousRequestDataAccessInDev),\n/* harmony export */   useDynamicRouteParams: () => (/* binding */ useDynamicRouteParams),\n/* harmony export */   warnOnSyncDynamicError: () => (/* binding */ warnOnSyncDynamicError)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ 7814);\n/* harmony import */ var _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../client/components/hooks-server-context */ 6159);\n/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../client/components/static-generation-bailout */ 4979);\n/* harmony import */ var _work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./work-unit-async-storage.external */ 6460);\n/* harmony import */ var _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../app-render/work-async-storage.external */ 1983);\n/* harmony import */ var _dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dynamic-rendering-utils */ 5770);\n/* harmony import */ var _lib_framework_boundary_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/framework/boundary-constants */ 4311);\n/* harmony import */ var _lib_scheduler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/scheduler */ 7479);\n/* harmony import */ var _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ 2340);\n/* harmony import */ var _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../shared/lib/invariant-error */ 9809);\n/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */ // Once postpone is in stable we should switch to importing the postpone export directly\n\n\n\n\n\n\n\n\n\n\nconst hasPostpone = typeof react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone === 'function';\nfunction createDynamicTrackingState(isDebugDynamicAccesses) {\n    return {\n        isDebugDynamicAccesses,\n        dynamicAccesses: [],\n        syncDynamicErrorWithStack: null\n    };\n}\nfunction createDynamicValidationState() {\n    return {\n        hasSuspenseAboveBody: false,\n        hasDynamicMetadata: false,\n        hasDynamicViewport: false,\n        hasAllowedDynamic: false,\n        dynamicErrors: []\n    };\n}\nfunction getFirstDynamicReason(trackingState) {\n    var _trackingState_dynamicAccesses_;\n    return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;\n}\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */ function markCurrentScopeAsDynamic(store, workUnitStore, expression) {\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'cache':\n            case 'unstable-cache':\n                // Inside cache scopes, marking a scope as dynamic has no effect,\n                // because the outer cache scope creates a cache boundary. This is\n                // subtly different from reading a dynamic data source, which is\n                // forbidden inside a cache scope.\n                return;\n            case 'private-cache':\n                // A private cache scope is already dynamic by definition.\n                return;\n            case 'prerender-legacy':\n            case 'prerender-ppr':\n            case 'request':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // If we're forcing dynamic rendering or we're forcing static rendering, we\n    // don't need to do anything here because the entire page is already dynamic\n    // or it's static and it should not throw or postpone here.\n    if (store.forceDynamic || store.forceStatic) return;\n    if (store.dynamicShouldError) {\n        throw Object.defineProperty(new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__.StaticGenBailoutError(`Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n            value: \"E553\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-ppr':\n                return postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);\n            case 'prerender-legacy':\n                workUnitStore.revalidate = 0;\n                // We aren't prerendering, but we are generating a static page. We need\n                // to bail out of static generation.\n                const err = Object.defineProperty(new _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E550\",\n                    enumerable: false,\n                    configurable: true\n                });\n                store.dynamicUsageDescription = expression;\n                store.dynamicUsageStack = err.stack;\n                throw err;\n            case 'request':\n                if (true) {\n                    workUnitStore.usedDynamic = true;\n                }\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */ function throwToInterruptStaticGeneration(expression, store, prerenderStore) {\n    // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n    const err = Object.defineProperty(new _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`), \"__NEXT_ERROR_CODE\", {\n        value: \"E558\",\n        enumerable: false,\n        configurable: true\n    });\n    prerenderStore.revalidate = 0;\n    store.dynamicUsageDescription = expression;\n    store.dynamicUsageStack = err.stack;\n    throw err;\n}\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */ function trackDynamicDataInDynamicRender(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'cache':\n        case 'unstable-cache':\n            // Inside cache scopes, marking a scope as dynamic has no effect,\n            // because the outer cache scope creates a cache boundary. This is\n            // subtly different from reading a dynamic data source, which is\n            // forbidden inside a cache scope.\n            return;\n        case 'private-cache':\n            // A private cache scope is already dynamic by definition.\n            return;\n        case 'prerender':\n        case 'prerender-runtime':\n        case 'prerender-legacy':\n        case 'prerender-ppr':\n        case 'prerender-client':\n            break;\n        case 'request':\n            if (true) {\n                workUnitStore.usedDynamic = true;\n            }\n            break;\n        default:\n            workUnitStore;\n    }\n}\nfunction abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {\n    const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;\n    const error = createPrerenderInterruptedError(reason);\n    prerenderStore.controller.abort(error);\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nfunction abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    if (dynamicTracking) {\n        if (dynamicTracking.syncDynamicErrorWithStack === null) {\n            dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n        }\n    }\n}\nfunction trackSynchronousPlatformIOAccessInDev(requestStore) {\n    // We don't actually have a controller to abort but we do the semantic equivalent by\n    // advancing the request store out of prerender mode\n    requestStore.prerenderPhase = false;\n}\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */ function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {\n    const prerenderSignal = prerenderStore.controller.signal;\n    if (prerenderSignal.aborted === false) {\n        // TODO it would be better to move this aborted check into the callsite so we can avoid making\n        // the error object when it isn't relevant to the aborting of the prerender however\n        // since we need the throw semantics regardless of whether we abort it is easier to land\n        // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n        // to ideal implementation\n        abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);\n        // It is important that we set this tracking value after aborting. Aborts are executed\n        // synchronously except for the case where you abort during render itself. By setting this\n        // value late we can use it to determine if any of the aborted tasks are the task that\n        // called the sync IO expression in the first place.\n        const dynamicTracking = prerenderStore.dynamicTracking;\n        if (dynamicTracking) {\n            if (dynamicTracking.syncDynamicErrorWithStack === null) {\n                dynamicTracking.syncDynamicErrorWithStack = errorWithStack;\n            }\n        }\n    }\n    throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);\n}\n/**\n * Use this function when dynamically prerendering with dynamicIO.\n * We don't want to error, because it's better to return something\n * (and we've already aborted the render at the point where the sync dynamic error occured),\n * but we should log an error server-side.\n * @internal\n */ function warnOnSyncDynamicError(dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack) {\n        // the server did something sync dynamic, likely\n        // leading to an early termination of the prerender.\n        console.error(dynamicTracking.syncDynamicErrorWithStack);\n    }\n}\n// For now these implementations are the same so we just reexport\nconst trackSynchronousRequestDataAccessInDev = trackSynchronousPlatformIOAccessInDev;\nfunction Postpone({ reason, route }) {\n    const prerenderStore = _work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__.workUnitAsyncStorage.getStore();\n    const dynamicTracking = prerenderStore && prerenderStore.type === 'prerender-ppr' ? prerenderStore.dynamicTracking : null;\n    postponeWithTracking(route, reason, dynamicTracking);\n}\nfunction postponeWithTracking(route, expression, dynamicTracking) {\n    assertPostpone();\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            // When we aren't debugging, we don't need to create another error for the\n            // stack trace.\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone(createPostponeReason(route, expression));\n}\nfunction createPostponeReason(route, expression) {\n    return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;\n}\nfunction isDynamicPostpone(err) {\n    if (typeof err === 'object' && err !== null && typeof err.message === 'string') {\n        return isDynamicPostponeReason(err.message);\n    }\n    return false;\n}\nfunction isDynamicPostponeReason(reason) {\n    return reason.includes('needs to bail out of prerendering at this point because it used') && reason.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error');\n}\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n    throw Object.defineProperty(new Error('Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'), \"__NEXT_ERROR_CODE\", {\n        value: \"E296\",\n        enumerable: false,\n        configurable: true\n    });\n}\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED';\nfunction createPrerenderInterruptedError(message) {\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.digest = NEXT_PRERENDER_INTERRUPTED;\n    return error;\n}\nfunction isPrerenderInterruptedError(error) {\n    return typeof error === 'object' && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && 'name' in error && 'message' in error && error instanceof Error;\n}\nfunction accessedDynamicData(dynamicAccesses) {\n    return dynamicAccesses.length > 0;\n}\nfunction consumeDynamicAccess(serverDynamic, clientDynamic) {\n    // We mutate because we only call this once we are no longer writing\n    // to the dynamicTrackingState and it's more efficient than creating a new\n    // array.\n    serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);\n    return serverDynamic.dynamicAccesses;\n}\nfunction formatDynamicAPIAccesses(dynamicAccesses) {\n    return dynamicAccesses.filter((access)=>typeof access.stack === 'string' && access.stack.length > 0).map(({ expression, stack })=>{\n        stack = stack.split('\\n') // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4).filter((line)=>{\n            // Exclude Next.js internals from the stack trace.\n            if (line.includes('node_modules/next/')) {\n                return false;\n            }\n            // Exclude anonymous functions from the stack trace.\n            if (line.includes(' (<anonymous>)')) {\n                return false;\n            }\n            // Exclude Node.js internals from the stack trace.\n            if (line.includes(' (node:')) {\n                return false;\n            }\n            return true;\n        }).join('\\n');\n        return `Dynamic API Usage Debug - ${expression}:\\n${stack}`;\n    });\n}\nfunction assertPostpone() {\n    if (!hasPostpone) {\n        throw Object.defineProperty(new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`), \"__NEXT_ERROR_CODE\", {\n            value: \"E224\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */ function createRenderInBrowserAbortSignal() {\n    const controller = new AbortController();\n    controller.abort(Object.defineProperty(new _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_8__.BailoutToCSRError('Render in Browser'), \"__NEXT_ERROR_CODE\", {\n        value: \"E721\",\n        enumerable: false,\n        configurable: true\n    }));\n    return controller.signal;\n}\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */ function createHangingInputAbortSignal(workUnitStore) {\n    switch(workUnitStore.type){\n        case 'prerender':\n        case 'prerender-runtime':\n            const controller = new AbortController();\n            if (workUnitStore.cacheSignal) {\n                // If we have a cacheSignal it means we're in a prospective render. If\n                // the input we're waiting on is coming from another cache, we do want\n                // to wait for it so that we can resolve this cache entry too.\n                workUnitStore.cacheSignal.inputReady().then(()=>{\n                    controller.abort();\n                });\n            } else {\n                // Otherwise we're in the final render and we should already have all\n                // our caches filled.\n                // If the prerender uses stages, we have wait until the runtime stage,\n                // at which point all runtime inputs will be resolved.\n                // (otherwise, a runtime prerender might consider `cookies()` hanging\n                //  even though they'd resolve in the next task.)\n                //\n                // We might still be waiting on some microtasks so we\n                // wait one tick before giving up. When we give up, we still want to\n                // render the content of this cache as deeply as we can so that we can\n                // suspend as deeply as possible in the tree or not at all if we don't\n                // end up waiting for the input.\n                const runtimeStagePromise = (0,_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__.getRuntimeStagePromise)(workUnitStore);\n                if (runtimeStagePromise) {\n                    runtimeStagePromise.then(()=>(0,_lib_scheduler__WEBPACK_IMPORTED_MODULE_7__.scheduleOnNextTick)(()=>controller.abort()));\n                } else {\n                    (0,_lib_scheduler__WEBPACK_IMPORTED_MODULE_7__.scheduleOnNextTick)(()=>controller.abort());\n                }\n            }\n            return controller.signal;\n        case 'prerender-client':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n            return undefined;\n        default:\n            workUnitStore;\n    }\n}\nfunction annotateDynamicAccess(expression, prerenderStore) {\n    const dynamicTracking = prerenderStore.dynamicTracking;\n    if (dynamicTracking) {\n        dynamicTracking.dynamicAccesses.push({\n            stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : undefined,\n            expression\n        });\n    }\n}\nfunction useDynamicRouteParams(expression) {\n    const workStore = _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_4__.workAsyncStorage.getStore();\n    const workUnitStore = _work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__.workUnitAsyncStorage.getStore();\n    if (workStore && workUnitStore) {\n        switch(workUnitStore.type){\n            case 'prerender-client':\n            case 'prerender':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        // We are in a prerender with cacheComponents semantics. We are going to\n                        // hang here and never resolve. This will cause the currently\n                        // rendering component to effectively be a dynamic hole.\n                        react__WEBPACK_IMPORTED_MODULE_0__.use((0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_5__.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, expression));\n                    }\n                    break;\n                }\n            case 'prerender-ppr':\n                {\n                    const fallbackParams = workUnitStore.fallbackRouteParams;\n                    if (fallbackParams && fallbackParams.size > 0) {\n                        return postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);\n                    }\n                    break;\n                }\n            case 'prerender-runtime':\n                throw Object.defineProperty(new _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_9__.InvariantError(`\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E771\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'cache':\n            case 'private-cache':\n                throw Object.defineProperty(new _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_9__.InvariantError(`\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E745\",\n                    enumerable: false,\n                    configurable: true\n                });\n            case 'prerender-legacy':\n            case 'request':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n}\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/;\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags = 'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6';\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(`\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${_lib_framework_boundary_constants__WEBPACK_IMPORTED_MODULE_6__.ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`);\nconst hasMetadataRegex = new RegExp(`\\\\n\\\\s+at ${_lib_framework_boundary_constants__WEBPACK_IMPORTED_MODULE_6__.METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasViewportRegex = new RegExp(`\\\\n\\\\s+at ${_lib_framework_boundary_constants__WEBPACK_IMPORTED_MODULE_6__.VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`);\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${_lib_framework_boundary_constants__WEBPACK_IMPORTED_MODULE_6__.OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`);\nfunction trackAllowedDynamicAccess(workStore, componentStack, dynamicValidation, clientDynamic) {\n    if (hasOutletRegex.test(componentStack)) {\n        // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n        return;\n    } else if (hasMetadataRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicMetadata = true;\n        return;\n    } else if (hasViewportRegex.test(componentStack)) {\n        dynamicValidation.hasDynamicViewport = true;\n        return;\n    } else if (hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(componentStack)) {\n        // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n        // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n        // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n        dynamicValidation.hasAllowedDynamic = true;\n        dynamicValidation.hasSuspenseAboveBody = true;\n        return;\n    } else if (hasSuspenseRegex.test(componentStack)) {\n        // this error had a Suspense boundary above it so we don't need to report it as a source\n        // of disallowed\n        dynamicValidation.hasAllowedDynamic = true;\n        return;\n    } else if (clientDynamic.syncDynamicErrorWithStack) {\n        // This task was the task that called the sync error.\n        dynamicValidation.dynamicErrors.push(clientDynamic.syncDynamicErrorWithStack);\n        return;\n    } else {\n        const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`;\n        const error = createErrorWithComponentOrOwnerStack(message, componentStack);\n        dynamicValidation.dynamicErrors.push(error);\n        return;\n    }\n}\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */ function createErrorWithComponentOrOwnerStack(message, componentStack) {\n    const ownerStack =  true && react__WEBPACK_IMPORTED_MODULE_0__.captureOwnerStack ? react__WEBPACK_IMPORTED_MODULE_0__.captureOwnerStack() : null;\n    const error = Object.defineProperty(new Error(message), \"__NEXT_ERROR_CODE\", {\n        value: \"E394\",\n        enumerable: false,\n        configurable: true\n    });\n    error.stack = error.name + ': ' + message + (ownerStack ?? componentStack);\n    return error;\n}\nvar PreludeState = /*#__PURE__*/ function(PreludeState) {\n    PreludeState[PreludeState[\"Full\"] = 0] = \"Full\";\n    PreludeState[PreludeState[\"Empty\"] = 1] = \"Empty\";\n    PreludeState[PreludeState[\"Errored\"] = 2] = \"Errored\";\n    return PreludeState;\n}({});\nfunction logDisallowedDynamicError(workStore, error) {\n    console.error(error);\n    if (!workStore.dev) {\n        if (workStore.hasReadableErrorStacks) {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`);\n        } else {\n            console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`);\n        }\n    }\n}\nfunction throwIfDisallowedDynamic(workStore, prelude, dynamicValidation, serverDynamic) {\n    if (prelude !== 0) {\n        if (dynamicValidation.hasSuspenseAboveBody) {\n            // This route has opted into allowing fully dynamic rendering\n            // by including a Suspense boundary above the body. In this case\n            // a lack of a shell is not considered disallowed so we simply return\n            return;\n        }\n        if (serverDynamic.syncDynamicErrorWithStack) {\n            // There is no shell and the server did something sync dynamic likely\n            // leading to an early termination of the prerender before the shell\n            // could be completed. We terminate the build/validating render.\n            logDisallowedDynamicError(workStore, serverDynamic.syncDynamicErrorWithStack);\n            throw new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__.StaticGenBailoutError();\n        }\n        // We didn't have any sync bailouts but there may be user code which\n        // blocked the root. We would have captured these during the prerender\n        // and can log them here and then terminate the build/validating render\n        const dynamicErrors = dynamicValidation.dynamicErrors;\n        if (dynamicErrors.length > 0) {\n            for(let i = 0; i < dynamicErrors.length; i++){\n                logDisallowedDynamicError(workStore, dynamicErrors[i]);\n            }\n            throw new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__.StaticGenBailoutError();\n        }\n        // If we got this far then the only other thing that could be blocking\n        // the root is dynamic Viewport. If this is dynamic then\n        // you need to opt into that by adding a Suspense boundary above the body\n        // to indicate your are ok with fully dynamic rendering.\n        if (dynamicValidation.hasDynamicViewport) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`);\n            throw new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__.StaticGenBailoutError();\n        }\n        if (prelude === 1) {\n            // If we ever get this far then we messed up the tracking of invalid dynamic.\n            // We still adhere to the constraint that you must produce a shell but invite the\n            // user to report this as a bug in Next.js.\n            console.error(`Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`);\n            throw new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__.StaticGenBailoutError();\n        }\n    } else {\n        if (dynamicValidation.hasAllowedDynamic === false && dynamicValidation.hasDynamicMetadata) {\n            console.error(`Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`);\n            throw new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__.StaticGenBailoutError();\n        }\n    }\n}\nfunction delayUntilRuntimeStage(prerenderStore, result) {\n    if (prerenderStore.runtimeStagePromise) {\n        return prerenderStore.runtimeStagePromise.then(()=>result);\n    }\n    return result;\n} //# sourceMappingURL=dynamic-rendering.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDakM7SUFDRjtBQUNGO0FBRU8sU0FBU21JLHVCQUNkcEYsY0FBMkMsRUFDM0NxRixNQUFrQjtJQUVsQixJQUFJckYsZUFBZXFELG1CQUFtQixFQUFFO1FBQ3RDLE9BQU9yRCxlQUFlcUQsbUJBQW1CLENBQUNELElBQUksQ0FBQyxJQUFNaUM7SUFDdkQ7SUFDQSxPQUFPQTtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvYW1hbmJob2dhbC9zcmMvc2VydmVyL2FwcC1yZW5kZXIvZHluYW1pYy1yZW5kZXJpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgZnVuY3Rpb25zIHByb3ZpZGVkIGJ5IHRoaXMgbW9kdWxlIGFyZSB1c2VkIHRvIGNvbW11bmljYXRlIGNlcnRhaW4gcHJvcGVydGllc1xuICogYWJvdXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIGNvZGUgc28gdGhhdCBOZXh0LmpzIGNhbiBtYWtlIGRlY2lzaW9ucyBvbiBob3cgdG8gaGFuZGxlXG4gKiB0aGUgY3VycmVudCBleGVjdXRpb24gaW4gZGlmZmVyZW50IHJlbmRlcmluZyBtb2RlcyBzdWNoIGFzIHByZS1yZW5kZXJpbmcsIHJlc3VtaW5nLCBhbmQgU1NSLlxuICpcbiAqIFRvZGF5IE5leHQuanMgdHJlYXRzIGFsbCBjb2RlIGFzIHBvdGVudGlhbGx5IHN0YXRpYy4gQ2VydGFpbiBBUElzIG1heSBvbmx5IG1ha2Ugc2Vuc2Ugd2hlbiBkeW5hbWljYWxseSByZW5kZXJpbmcuXG4gKiBUcmFkaXRpb25hbGx5IHRoaXMgbWVhbnQgZGVvcHRpbmcgdGhlIGVudGlyZSByZW5kZXIgdG8gZHluYW1pYyBob3dldmVyIHdpdGggUFBSIHdlIGNhbiBub3cgZGVvcHQgcGFydHNcbiAqIG9mIGEgUmVhY3QgdHJlZSBhcyBkeW5hbWljIHdoaWxlIHN0aWxsIGtlZXBpbmcgb3RoZXIgcGFydHMgc3RhdGljLiBUaGVyZSBhcmUgcmVhbGx5IHR3byBkaWZmZXJlbnQga2luZHMgb2ZcbiAqIER5bmFtaWMgaW5kaWNhdGlvbnMuXG4gKlxuICogVGhlIGZpcnN0IGlzIHNpbXBseSBhbiBpbnRlbnRpb24gdG8gYmUgZHluYW1pYy4gdW5zdGFibGVfbm9TdG9yZSBpcyBhbiBleGFtcGxlIG9mIHRoaXMgd2hlcmVcbiAqIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIGNvZGUgc2ltcGx5IGRlY2xhcmVzIHRoYXQgdGhlIGN1cnJlbnQgc2NvcGUgaXMgZHluYW1pYyBidXQgaWYgeW91IHVzZSBpdFxuICogaW5zaWRlIHVuc3RhYmxlX2NhY2hlIGl0IGNhbiBzdGlsbCBiZSBjYWNoZWQuIFRoaXMgdHlwZSBvZiBpbmRpY2F0aW9uIGNhbiBiZSByZW1vdmVkIGlmIHdlIGV2ZXJcbiAqIG1ha2UgdGhlIGRlZmF1bHQgZHluYW1pYyB0byBiZWdpbiB3aXRoIGJlY2F1c2UgdGhlIG9ubHkgd2F5IHlvdSB3b3VsZCBldmVyIGJlIHN0YXRpYyBpcyBpbnNpZGVcbiAqIGEgY2FjaGUgc2NvcGUgd2hpY2ggdGhpcyBpbmRpY2F0aW9uIGRvZXMgbm90IGFmZmVjdC5cbiAqXG4gKiBUaGUgc2Vjb25kIGlzIGFuIGluZGljYXRpb24gdGhhdCBhIGR5bmFtaWMgZGF0YSBzb3VyY2Ugd2FzIHJlYWQuIFRoaXMgaXMgYSBzdHJvbmdlciBmb3JtIG9mIGR5bmFtaWNcbiAqIGJlY2F1c2UgaXQgbWVhbnMgdGhhdCBpdCBpcyBpbmFwcHJvcHJpYXRlIHRvIGNhY2hlIHRoaXMgYXQgYWxsLiB1c2luZyBhIGR5bmFtaWMgZGF0YSBzb3VyY2UgaW5zaWRlXG4gKiB1bnN0YWJsZV9jYWNoZSBzaG91bGQgZXJyb3IuIElmIHlvdSB3YW50IHRvIHVzZSBzb21lIGR5bmFtaWMgZGF0YSBpbnNpZGUgdW5zdGFibGVfY2FjaGUgeW91IHNob3VsZFxuICogcmVhZCB0aGF0IGRhdGEgb3V0c2lkZSB0aGUgY2FjaGUgYW5kIHBhc3MgaXQgaW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNhY2hlZCBmdW5jdGlvbi5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFdvcmtTdG9yZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHR5cGUge1xuICBXb3JrVW5pdFN0b3JlLFxuICBSZXF1ZXN0U3RvcmUsXG4gIFByZXJlbmRlclN0b3JlTGVnYWN5LFxuICBQcmVyZW5kZXJTdG9yZU1vZGVybixcbiAgUHJlcmVuZGVyU3RvcmVNb2Rlcm5SdW50aW1lLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuXG4vLyBPbmNlIHBvc3Rwb25lIGlzIGluIHN0YWJsZSB3ZSBzaG91bGQgc3dpdGNoIHRvIGltcG9ydGluZyB0aGUgcG9zdHBvbmUgZXhwb3J0IGRpcmVjdGx5XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmltcG9ydCB7IER5bmFtaWNTZXJ2ZXJFcnJvciB9IGZyb20gJy4uLy4uL2NsaWVudC9jb21wb25lbnRzL2hvb2tzLXNlcnZlci1jb250ZXh0J1xuaW1wb3J0IHsgU3RhdGljR2VuQmFpbG91dEVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dCdcbmltcG9ydCB7XG4gIGdldFJ1bnRpbWVTdGFnZVByb21pc2UsXG4gIHdvcmtVbml0QXN5bmNTdG9yYWdlLFxufSBmcm9tICcuL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgd29ya0FzeW5jU3RvcmFnZSB9IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHsgbWFrZUhhbmdpbmdQcm9taXNlIH0gZnJvbSAnLi4vZHluYW1pYy1yZW5kZXJpbmctdXRpbHMnXG5pbXBvcnQge1xuICBNRVRBREFUQV9CT1VOREFSWV9OQU1FLFxuICBWSUVXUE9SVF9CT1VOREFSWV9OQU1FLFxuICBPVVRMRVRfQk9VTkRBUllfTkFNRSxcbiAgUk9PVF9MQVlPVVRfQk9VTkRBUllfTkFNRSxcbn0gZnJvbSAnLi4vLi4vbGliL2ZyYW1ld29yay9ib3VuZGFyeS1jb25zdGFudHMnXG5pbXBvcnQgeyBzY2hlZHVsZU9uTmV4dFRpY2sgfSBmcm9tICcuLi8uLi9saWIvc2NoZWR1bGVyJ1xuaW1wb3J0IHsgQmFpbG91dFRvQ1NSRXJyb3IgfSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2xhenktZHluYW1pYy9iYWlsb3V0LXRvLWNzcidcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5cbmNvbnN0IGhhc1Bvc3Rwb25lID0gdHlwZW9mIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lID09PSAnZnVuY3Rpb24nXG5cbmV4cG9ydCB0eXBlIER5bmFtaWNBY2Nlc3MgPSB7XG4gIC8qKlxuICAgKiBJZiBkZWJ1Z2dpbmcsIHRoaXMgd2lsbCBjb250YWluIHRoZSBzdGFjayB0cmFjZSBvZiB3aGVyZSB0aGUgZHluYW1pYyBhY2Nlc3NcbiAgICogb2NjdXJyZWQuIFRoaXMgaXMgdXNlZCB0byBwcm92aWRlIG1vcmUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIgYWJvdXQgd2h5XG4gICAqIHRoZWlyIHBhZ2UgaXMgYmVpbmcgcmVuZGVyZWQgZHluYW1pY2FsbHkuXG4gICAqL1xuICBzdGFjaz86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgZXhwcmVzc2lvbiB0aGF0IHdhcyBhY2Nlc3NlZCBkeW5hbWljYWxseS5cbiAgICovXG4gIGV4cHJlc3Npb246IHN0cmluZ1xufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFJTQyByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVHJhY2tpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgc3RhY2sgaW5mb3JtYXRpb24gd2lsbCBhbHNvIGJlIHRyYWNrZWQgZHVyaW5nIGR5bmFtaWMgYWNjZXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlczogYm9vbGVhbiB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBUaGUgZHluYW1pYyBhY2Nlc3NlcyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY0FjY2Vzc2VzOiBBcnJheTxEeW5hbWljQWNjZXNzPlxuXG4gIHN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2s6IG51bGwgfCBFcnJvclxufVxuXG4vLyBTdG9yZXMgZHluYW1pYyByZWFzb25zIHVzZWQgZHVyaW5nIGFuIFNTUiByZW5kZXIuXG5leHBvcnQgdHlwZSBEeW5hbWljVmFsaWRhdGlvblN0YXRlID0ge1xuICBoYXNTdXNwZW5zZUFib3ZlQm9keTogYm9vbGVhblxuICBoYXNEeW5hbWljTWV0YWRhdGE6IGJvb2xlYW5cbiAgaGFzRHluYW1pY1ZpZXdwb3J0OiBib29sZWFuXG4gIGhhc0FsbG93ZWREeW5hbWljOiBib29sZWFuXG4gIGR5bmFtaWNFcnJvcnM6IEFycmF5PEVycm9yPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1RyYWNraW5nU3RhdGUoXG4gIGlzRGVidWdEeW5hbWljQWNjZXNzZXM6IGJvb2xlYW4gfCB1bmRlZmluZWRcbik6IER5bmFtaWNUcmFja2luZ1N0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBpc0RlYnVnRHluYW1pY0FjY2Vzc2VzLFxuICAgIGR5bmFtaWNBY2Nlc3NlczogW10sXG4gICAgc3luY0R5bmFtaWNFcnJvcldpdGhTdGFjazogbnVsbCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSgpOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNTdXNwZW5zZUFib3ZlQm9keTogZmFsc2UsXG4gICAgaGFzRHluYW1pY01ldGFkYXRhOiBmYWxzZSxcbiAgICBoYXNEeW5hbWljVmlld3BvcnQ6IGZhbHNlLFxuICAgIGhhc0FsbG93ZWREeW5hbWljOiBmYWxzZSxcbiAgICBkeW5hbWljRXJyb3JzOiBbXSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3REeW5hbWljUmVhc29uKFxuICB0cmFja2luZ1N0YXRlOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKTogdW5kZWZpbmVkIHwgc3RyaW5nIHtcbiAgcmV0dXJuIHRyYWNraW5nU3RhdGUuZHluYW1pY0FjY2Vzc2VzWzBdPy5leHByZXNzaW9uXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjb21tdW5pY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBzY29wZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBkeW5hbWljLlxuICpcbiAqIEluIG1vc3QgY2FzZXMgdGhpcyBmdW5jdGlvbiBpcyBhIG5vLW9wIGJ1dCBpZiBjYWxsZWQgZHVyaW5nXG4gKiBhIFBQUiBwcmVyZW5kZXIgaXQgd2lsbCBwb3N0cG9uZSB0aGUgY3VycmVudCBzdWItdHJlZSBhbmQgY2FsbGluZ1xuICogaXQgZHVyaW5nIGEgbm9ybWFsIHByZXJlbmRlciB3aWxsIGNhdXNlIHRoZSBlbnRpcmUgcHJlcmVuZGVyIHRvIGFib3J0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljKFxuICBzdG9yZTogV29ya1N0b3JlLFxuICB3b3JrVW5pdFN0b3JlOiB1bmRlZmluZWQgfCBFeGNsdWRlPFdvcmtVbml0U3RvcmUsIFByZXJlbmRlclN0b3JlTW9kZXJuPixcbiAgZXhwcmVzc2lvbjogc3RyaW5nXG4pOiB2b2lkIHtcbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAnY2FjaGUnOlxuICAgICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgICAvLyBJbnNpZGUgY2FjaGUgc2NvcGVzLCBtYXJraW5nIGEgc2NvcGUgYXMgZHluYW1pYyBoYXMgbm8gZWZmZWN0LFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBvdXRlciBjYWNoZSBzY29wZSBjcmVhdGVzIGEgY2FjaGUgYm91bmRhcnkuIFRoaXMgaXNcbiAgICAgICAgLy8gc3VidGx5IGRpZmZlcmVudCBmcm9tIHJlYWRpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlLCB3aGljaCBpc1xuICAgICAgICAvLyBmb3JiaWRkZW4gaW5zaWRlIGEgY2FjaGUgc2NvcGUuXG4gICAgICAgIHJldHVyblxuICAgICAgY2FzZSAncHJpdmF0ZS1jYWNoZSc6XG4gICAgICAgIC8vIEEgcHJpdmF0ZSBjYWNoZSBzY29wZSBpcyBhbHJlYWR5IGR5bmFtaWMgYnkgZGVmaW5pdGlvbi5cbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3b3JrVW5pdFN0b3JlIHNhdGlzZmllcyBuZXZlclxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlJ3JlIGZvcmNpbmcgZHluYW1pYyByZW5kZXJpbmcgb3Igd2UncmUgZm9yY2luZyBzdGF0aWMgcmVuZGVyaW5nLCB3ZVxuICAvLyBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSB0aGUgZW50aXJlIHBhZ2UgaXMgYWxyZWFkeSBkeW5hbWljXG4gIC8vIG9yIGl0J3Mgc3RhdGljIGFuZCBpdCBzaG91bGQgbm90IHRocm93IG9yIHBvc3Rwb25lIGhlcmUuXG4gIGlmIChzdG9yZS5mb3JjZUR5bmFtaWMgfHwgc3RvcmUuZm9yY2VTdGF0aWMpIHJldHVyblxuXG4gIGlmIChzdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgICAgYFJvdXRlICR7c3RvcmUucm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgXG4gICAgKVxuICB9XG5cbiAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgICAgY2FzZSAncHJlcmVuZGVyLXBwcic6XG4gICAgICAgIHJldHVybiBwb3N0cG9uZVdpdGhUcmFja2luZyhcbiAgICAgICAgICBzdG9yZS5yb3V0ZSxcbiAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgIHdvcmtVbml0U3RvcmUuZHluYW1pY1RyYWNraW5nXG4gICAgICAgIClcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgICB3b3JrVW5pdFN0b3JlLnJldmFsaWRhdGUgPSAwXG5cbiAgICAgICAgLy8gV2UgYXJlbid0IHByZXJlbmRlcmluZywgYnV0IHdlIGFyZSBnZW5lcmF0aW5nIGEgc3RhdGljIHBhZ2UuIFdlIG5lZWRcbiAgICAgICAgLy8gdG8gYmFpbCBvdXQgb2Ygc3RhdGljIGdlbmVyYXRpb24uXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBEeW5hbWljU2VydmVyRXJyb3IoXG4gICAgICAgICAgYFJvdXRlICR7c3RvcmUucm91dGV9IGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZHluYW1pYy1zZXJ2ZXItZXJyb3JgXG4gICAgICAgIClcbiAgICAgICAgc3RvcmUuZHluYW1pY1VzYWdlRGVzY3JpcHRpb24gPSBleHByZXNzaW9uXG4gICAgICAgIHN0b3JlLmR5bmFtaWNVc2FnZVN0YWNrID0gZXJyLnN0YWNrXG5cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3b3JrVW5pdFN0b3JlLnVzZWREeW5hbWljID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3b3JrVW5pdFN0b3JlIHNhdGlzZmllcyBuZXZlclxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbWVhbnQgdG8gYmUgdXNlZCB3aGVuIHByZXJlbmRlcmluZyB3aXRob3V0IGNhY2hlQ29tcG9uZW50cyBvciBQUFIuXG4gKiBXaGVuIGNhbGxlZCBkdXJpbmcgYSBidWlsZCBpdCB3aWxsIGNhdXNlIE5leHQuanMgdG8gY29uc2lkZXIgdGhlIHJvdXRlIGFzIGR5bmFtaWMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBzdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVMZWdhY3lcbik6IG5ldmVyIHtcbiAgLy8gV2UgYXJlbid0IHByZXJlbmRlcmluZyBidXQgd2UgYXJlIGdlbmVyYXRpbmcgYSBzdGF0aWMgcGFnZS4gV2UgbmVlZCB0byBiYWlsIG91dCBvZiBzdGF0aWMgZ2VuZXJhdGlvblxuICBjb25zdCBlcnIgPSBuZXcgRHluYW1pY1NlcnZlckVycm9yKFxuICAgIGBSb3V0ZSAke3N0b3JlLnJvdXRlfSBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGAke2V4cHJlc3Npb259XFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2R5bmFtaWMtc2VydmVyLWVycm9yYFxuICApXG5cbiAgcHJlcmVuZGVyU3RvcmUucmV2YWxpZGF0ZSA9IDBcblxuICBzdG9yZS5keW5hbWljVXNhZ2VEZXNjcmlwdGlvbiA9IGV4cHJlc3Npb25cbiAgc3RvcmUuZHluYW1pY1VzYWdlU3RhY2sgPSBlcnIuc3RhY2tcblxuICB0aHJvdyBlcnJcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgc29tZXRoaW5nIGR5bmFtaWMgaGFwcGVuZWQgZXZlbiB3aGVuXG4gKiB3ZSBhcmUgaW4gYSBkeW5hbWljIHJlbmRlci4gVGhpcyBpcyB1c2VmdWwgZm9yIERldiB3aGVyZSBhbGwgcmVuZGVycyBhcmUgZHluYW1pYyBidXRcbiAqIHdlIHN0aWxsIHRyYWNrIHdoZXRoZXIgZHluYW1pYyBBUElzIHdlcmUgYWNjZXNzZWQgZm9yIGhlbHBmdWwgbWVzc2FnaW5nXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyKHdvcmtVbml0U3RvcmU6IFdvcmtVbml0U3RvcmUpIHtcbiAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICBjYXNlICdjYWNoZSc6XG4gICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgLy8gSW5zaWRlIGNhY2hlIHNjb3BlcywgbWFya2luZyBhIHNjb3BlIGFzIGR5bmFtaWMgaGFzIG5vIGVmZmVjdCxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIG91dGVyIGNhY2hlIHNjb3BlIGNyZWF0ZXMgYSBjYWNoZSBib3VuZGFyeS4gVGhpcyBpc1xuICAgICAgLy8gc3VidGx5IGRpZmZlcmVudCBmcm9tIHJlYWRpbmcgYSBkeW5hbWljIGRhdGEgc291cmNlLCB3aGljaCBpc1xuICAgICAgLy8gZm9yYmlkZGVuIGluc2lkZSBhIGNhY2hlIHNjb3BlLlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAncHJpdmF0ZS1jYWNoZSc6XG4gICAgICAvLyBBIHByaXZhdGUgY2FjaGUgc2NvcGUgaXMgYWxyZWFkeSBkeW5hbWljIGJ5IGRlZmluaXRpb24uXG4gICAgICByZXR1cm5cbiAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgIGNhc2UgJ3ByZXJlbmRlci1ydW50aW1lJzpcbiAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3b3JrVW5pdFN0b3JlLnVzZWREeW5hbWljID0gdHJ1ZVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgd29ya1VuaXRTdG9yZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2VzcyhcbiAgcm91dGU6IHN0cmluZyxcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IHZvaWQge1xuICBjb25zdCByZWFzb24gPSBgUm91dGUgJHtyb3V0ZX0gbmVlZHMgdG8gYmFpbCBvdXQgb2YgcHJlcmVuZGVyaW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCB1c2VkICR7ZXhwcmVzc2lvbn0uYFxuXG4gIGNvbnN0IGVycm9yID0gY3JlYXRlUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvcihyZWFzb24pXG5cbiAgcHJlcmVuZGVyU3RvcmUuY29udHJvbGxlci5hYm9ydChlcnJvcilcblxuICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGR5bmFtaWNUcmFja2luZy5keW5hbWljQWNjZXNzZXMucHVzaCh7XG4gICAgICAvLyBXaGVuIHdlIGFyZW4ndCBkZWJ1Z2dpbmcsIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIGFub3RoZXIgZXJyb3IgZm9yIHRoZVxuICAgICAgLy8gc3RhY2sgdHJhY2UuXG4gICAgICBzdGFjazogZHluYW1pY1RyYWNraW5nLmlzRGVidWdEeW5hbWljQWNjZXNzZXNcbiAgICAgICAgPyBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRPblN5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2VzcyhcbiAgcm91dGU6IHN0cmluZyxcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBlcnJvcldpdGhTdGFjazogRXJyb3IsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogdm9pZCB7XG4gIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICBhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUpXG4gIC8vIEl0IGlzIGltcG9ydGFudCB0aGF0IHdlIHNldCB0aGlzIHRyYWNraW5nIHZhbHVlIGFmdGVyIGFib3J0aW5nLiBBYm9ydHMgYXJlIGV4ZWN1dGVkXG4gIC8vIHN5bmNocm9ub3VzbHkgZXhjZXB0IGZvciB0aGUgY2FzZSB3aGVyZSB5b3UgYWJvcnQgZHVyaW5nIHJlbmRlciBpdHNlbGYuIEJ5IHNldHRpbmcgdGhpc1xuICAvLyB2YWx1ZSBsYXRlIHdlIGNhbiB1c2UgaXQgdG8gZGV0ZXJtaW5lIGlmIGFueSBvZiB0aGUgYWJvcnRlZCB0YXNrcyBhcmUgdGhlIHRhc2sgdGhhdFxuICAvLyBjYWxsZWQgdGhlIHN5bmMgSU8gZXhwcmVzc2lvbiBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICBpZiAoZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPT09IG51bGwpIHtcbiAgICAgIGR5bmFtaWNUcmFja2luZy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrID0gZXJyb3JXaXRoU3RhY2tcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzSW5EZXYoXG4gIHJlcXVlc3RTdG9yZTogUmVxdWVzdFN0b3JlXG4pOiB2b2lkIHtcbiAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBhIGNvbnRyb2xsZXIgdG8gYWJvcnQgYnV0IHdlIGRvIHRoZSBzZW1hbnRpYyBlcXVpdmFsZW50IGJ5XG4gIC8vIGFkdmFuY2luZyB0aGUgcmVxdWVzdCBzdG9yZSBvdXQgb2YgcHJlcmVuZGVyIG1vZGVcbiAgcmVxdWVzdFN0b3JlLnByZXJlbmRlclBoYXNlID0gZmFsc2Vcbn1cblxuLyoqXG4gKiB1c2UgdGhpcyBmdW5jdGlvbiB3aGVuIHByZXJlbmRlcmluZyB3aXRoIGNhY2hlQ29tcG9uZW50cy4gSWYgd2UgYXJlIGRvaW5nIGFcbiAqIHByb3NwZWN0aXZlIHByZXJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBhYm9ydCBiZWNhdXNlIHdlIHdhbnQgdG8gZGlzY292ZXJcbiAqIGFsbCBjYWNoZXMgZm9yIHRoZSBzaGVsbC4gSWYgdGhpcyBpcyB0aGUgYWN0dWFsIHByZXJlbmRlciB3ZSBkbyBhYm9ydC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYSBwcmVyZW5kZXJTdG9yZSBidXQgdGhlIGNhbGxlciBzaG91bGQgZW5zdXJlIHdlJ3JlXG4gKiBhY3R1YWxseSBydW5uaW5nIGluIGNhY2hlQ29tcG9uZW50cyBtb2RlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRBbmRUaHJvd09uU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2VzcyhcbiAgcm91dGU6IHN0cmluZyxcbiAgZXhwcmVzc2lvbjogc3RyaW5nLFxuICBlcnJvcldpdGhTdGFjazogRXJyb3IsXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblxuKTogbmV2ZXIge1xuICBjb25zdCBwcmVyZW5kZXJTaWduYWwgPSBwcmVyZW5kZXJTdG9yZS5jb250cm9sbGVyLnNpZ25hbFxuICBpZiAocHJlcmVuZGVyU2lnbmFsLmFib3J0ZWQgPT09IGZhbHNlKSB7XG4gICAgLy8gVE9ETyBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gbW92ZSB0aGlzIGFib3J0ZWQgY2hlY2sgaW50byB0aGUgY2FsbHNpdGUgc28gd2UgY2FuIGF2b2lkIG1ha2luZ1xuICAgIC8vIHRoZSBlcnJvciBvYmplY3Qgd2hlbiBpdCBpc24ndCByZWxldmFudCB0byB0aGUgYWJvcnRpbmcgb2YgdGhlIHByZXJlbmRlciBob3dldmVyXG4gICAgLy8gc2luY2Ugd2UgbmVlZCB0aGUgdGhyb3cgc2VtYW50aWNzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB3ZSBhYm9ydCBpdCBpcyBlYXNpZXIgdG8gbGFuZFxuICAgIC8vIHRoaXMgd2F5LiBTZWUgaG93IHRoaXMgd2FzIGhhbmRsZWQgd2l0aCBgYWJvcnRPblN5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2Vzc2AgZm9yIGEgY2xvc2VyXG4gICAgLy8gdG8gaWRlYWwgaW1wbGVtZW50YXRpb25cbiAgICBhYm9ydE9uU3luY2hyb25vdXNEeW5hbWljRGF0YUFjY2Vzcyhyb3V0ZSwgZXhwcmVzc2lvbiwgcHJlcmVuZGVyU3RvcmUpXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRoYXQgd2Ugc2V0IHRoaXMgdHJhY2tpbmcgdmFsdWUgYWZ0ZXIgYWJvcnRpbmcuIEFib3J0cyBhcmUgZXhlY3V0ZWRcbiAgICAvLyBzeW5jaHJvbm91c2x5IGV4Y2VwdCBmb3IgdGhlIGNhc2Ugd2hlcmUgeW91IGFib3J0IGR1cmluZyByZW5kZXIgaXRzZWxmLiBCeSBzZXR0aW5nIHRoaXNcbiAgICAvLyB2YWx1ZSBsYXRlIHdlIGNhbiB1c2UgaXQgdG8gZGV0ZXJtaW5lIGlmIGFueSBvZiB0aGUgYWJvcnRlZCB0YXNrcyBhcmUgdGhlIHRhc2sgdGhhdFxuICAgIC8vIGNhbGxlZCB0aGUgc3luYyBJTyBleHByZXNzaW9uIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICBjb25zdCBkeW5hbWljVHJhY2tpbmcgPSBwcmVyZW5kZXJTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICBpZiAoZHluYW1pY1RyYWNraW5nKSB7XG4gICAgICBpZiAoZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPT09IG51bGwpIHtcbiAgICAgICAgZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2sgPSBlcnJvcldpdGhTdGFja1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBjcmVhdGVQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKFxuICAgIGBSb3V0ZSAke3JvdXRlfSBuZWVkcyB0byBiYWlsIG91dCBvZiBwcmVyZW5kZXJpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IHVzZWQgJHtleHByZXNzaW9ufS5gXG4gIClcbn1cblxuLyoqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiB3aGVuIGR5bmFtaWNhbGx5IHByZXJlbmRlcmluZyB3aXRoIGR5bmFtaWNJTy5cbiAqIFdlIGRvbid0IHdhbnQgdG8gZXJyb3IsIGJlY2F1c2UgaXQncyBiZXR0ZXIgdG8gcmV0dXJuIHNvbWV0aGluZ1xuICogKGFuZCB3ZSd2ZSBhbHJlYWR5IGFib3J0ZWQgdGhlIHJlbmRlciBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIHN5bmMgZHluYW1pYyBlcnJvciBvY2N1cmVkKSxcbiAqIGJ1dCB3ZSBzaG91bGQgbG9nIGFuIGVycm9yIHNlcnZlci1zaWRlLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YXJuT25TeW5jRHluYW1pY0Vycm9yKGR5bmFtaWNUcmFja2luZzogRHluYW1pY1RyYWNraW5nU3RhdGUpIHtcbiAgaWYgKGR5bmFtaWNUcmFja2luZy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrKSB7XG4gICAgLy8gdGhlIHNlcnZlciBkaWQgc29tZXRoaW5nIHN5bmMgZHluYW1pYywgbGlrZWx5XG4gICAgLy8gbGVhZGluZyB0byBhbiBlYXJseSB0ZXJtaW5hdGlvbiBvZiB0aGUgcHJlcmVuZGVyLlxuICAgIGNvbnNvbGUuZXJyb3IoZHluYW1pY1RyYWNraW5nLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2spXG4gIH1cbn1cblxuLy8gRm9yIG5vdyB0aGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIHRoZSBzYW1lIHNvIHdlIGp1c3QgcmVleHBvcnRcbmV4cG9ydCBjb25zdCB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldiA9XG4gIHRyYWNrU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzSW5EZXZcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGNhbGwgYFJlYWN0LnBvc3Rwb25lYCB0aGF0IHRocm93cyB0aGUgcG9zdHBvbmVkIGVycm9yLlxuICovXG50eXBlIFBvc3Rwb25lUHJvcHMgPSB7XG4gIHJlYXNvbjogc3RyaW5nXG4gIHJvdXRlOiBzdHJpbmdcbn1cbmV4cG9ydCBmdW5jdGlvbiBQb3N0cG9uZSh7IHJlYXNvbiwgcm91dGUgfTogUG9zdHBvbmVQcm9wcyk6IG5ldmVyIHtcbiAgY29uc3QgcHJlcmVuZGVyU3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGNvbnN0IGR5bmFtaWNUcmFja2luZyA9XG4gICAgcHJlcmVuZGVyU3RvcmUgJiYgcHJlcmVuZGVyU3RvcmUudHlwZSA9PT0gJ3ByZXJlbmRlci1wcHInXG4gICAgICA/IHByZXJlbmRlclN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgOiBudWxsXG4gIHBvc3Rwb25lV2l0aFRyYWNraW5nKHJvdXRlLCByZWFzb24sIGR5bmFtaWNUcmFja2luZylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHByZXNzaW9uOiBzdHJpbmcsXG4gIGR5bmFtaWNUcmFja2luZzogbnVsbCB8IER5bmFtaWNUcmFja2luZ1N0YXRlXG4pOiBuZXZlciB7XG4gIGFzc2VydFBvc3Rwb25lKClcbiAgaWYgKGR5bmFtaWNUcmFja2luZykge1xuICAgIGR5bmFtaWNUcmFja2luZy5keW5hbWljQWNjZXNzZXMucHVzaCh7XG4gICAgICAvLyBXaGVuIHdlIGFyZW4ndCBkZWJ1Z2dpbmcsIHdlIGRvbid0IG5lZWQgdG8gY3JlYXRlIGFub3RoZXIgZXJyb3IgZm9yIHRoZVxuICAgICAgLy8gc3RhY2sgdHJhY2UuXG4gICAgICBzdGFjazogZHluYW1pY1RyYWNraW5nLmlzRGVidWdEeW5hbWljQWNjZXNzZXNcbiAgICAgICAgPyBuZXcgRXJyb3IoKS5zdGFja1xuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGV4cHJlc3Npb24sXG4gICAgfSlcbiAgfVxuXG4gIFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lKGNyZWF0ZVBvc3Rwb25lUmVhc29uKHJvdXRlLCBleHByZXNzaW9uKSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9zdHBvbmVSZWFzb24ocm91dGU6IHN0cmluZywgZXhwcmVzc2lvbjogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgYFJvdXRlICR7cm91dGV9IG5lZWRzIHRvIGJhaWwgb3V0IG9mIHByZXJlbmRlcmluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgdXNlZCAke2V4cHJlc3Npb259LiBgICtcbiAgICBgUmVhY3QgdGhyb3dzIHRoaXMgc3BlY2lhbCBvYmplY3QgdG8gaW5kaWNhdGUgd2hlcmUuIEl0IHNob3VsZCBub3QgYmUgY2F1Z2h0IGJ5IGAgK1xuICAgIGB5b3VyIG93biB0cnkvY2F0Y2guIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3Bwci1jYXVnaHQtZXJyb3JgXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1Bvc3Rwb25lKGVycjogdW5rbm93bikge1xuICBpZiAoXG4gICAgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiZcbiAgICBlcnIgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgKGVyciBhcyBhbnkpLm1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICkge1xuICAgIHJldHVybiBpc0R5bmFtaWNQb3N0cG9uZVJlYXNvbigoZXJyIGFzIGFueSkubWVzc2FnZSlcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaXNEeW5hbWljUG9zdHBvbmVSZWFzb24ocmVhc29uOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICByZWFzb24uaW5jbHVkZXMoXG4gICAgICAnbmVlZHMgdG8gYmFpbCBvdXQgb2YgcHJlcmVuZGVyaW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCB1c2VkJ1xuICAgICkgJiZcbiAgICByZWFzb24uaW5jbHVkZXMoXG4gICAgICAnTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHByLWNhdWdodC1lcnJvcidcbiAgICApXG4gIClcbn1cblxuaWYgKGlzRHluYW1pY1Bvc3Rwb25lUmVhc29uKGNyZWF0ZVBvc3Rwb25lUmVhc29uKCclJSUnLCAnXl5eJykpID09PSBmYWxzZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ0ludmFyaWFudDogaXNEeW5hbWljUG9zdHBvbmUgbWlzaWRlbnRpZmllZCBhIHBvc3Rwb25lIHJlYXNvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBOZXh0LmpzJ1xuICApXG59XG5cbmNvbnN0IE5FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEID0gJ05FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEJ1xuXG5mdW5jdGlvbiBjcmVhdGVQcmVyZW5kZXJJbnRlcnJ1cHRlZEVycm9yKG1lc3NhZ2U6IHN0cmluZyk6IEVycm9yIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgOyhlcnJvciBhcyBhbnkpLmRpZ2VzdCA9IE5FWFRfUFJFUkVOREVSX0lOVEVSUlVQVEVEXG4gIHJldHVybiBlcnJvclxufVxuXG50eXBlIERpZ2VzdEVycm9yID0gRXJyb3IgJiB7XG4gIGRpZ2VzdDogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ByZXJlbmRlckludGVycnVwdGVkRXJyb3IoXG4gIGVycm9yOiB1bmtub3duXG4pOiBlcnJvciBpcyBEaWdlc3RFcnJvciB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgKGVycm9yIGFzIGFueSkuZGlnZXN0ID09PSBORVhUX1BSRVJFTkRFUl9JTlRFUlJVUFRFRCAmJlxuICAgICduYW1lJyBpbiBlcnJvciAmJlxuICAgICdtZXNzYWdlJyBpbiBlcnJvciAmJlxuICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzZWREeW5hbWljRGF0YShcbiAgZHluYW1pY0FjY2Vzc2VzOiBBcnJheTxEeW5hbWljQWNjZXNzPlxuKTogYm9vbGVhbiB7XG4gIHJldHVybiBkeW5hbWljQWNjZXNzZXMubGVuZ3RoID4gMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3VtZUR5bmFtaWNBY2Nlc3MoXG4gIHNlcnZlckR5bmFtaWM6IER5bmFtaWNUcmFja2luZ1N0YXRlLFxuICBjbGllbnREeW5hbWljOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKTogRHluYW1pY1RyYWNraW5nU3RhdGVbJ2R5bmFtaWNBY2Nlc3NlcyddIHtcbiAgLy8gV2UgbXV0YXRlIGJlY2F1c2Ugd2Ugb25seSBjYWxsIHRoaXMgb25jZSB3ZSBhcmUgbm8gbG9uZ2VyIHdyaXRpbmdcbiAgLy8gdG8gdGhlIGR5bmFtaWNUcmFja2luZ1N0YXRlIGFuZCBpdCdzIG1vcmUgZWZmaWNpZW50IHRoYW4gY3JlYXRpbmcgYSBuZXdcbiAgLy8gYXJyYXkuXG4gIHNlcnZlckR5bmFtaWMuZHluYW1pY0FjY2Vzc2VzLnB1c2goLi4uY2xpZW50RHluYW1pYy5keW5hbWljQWNjZXNzZXMpXG4gIHJldHVybiBzZXJ2ZXJEeW5hbWljLmR5bmFtaWNBY2Nlc3Nlc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RHluYW1pY0FQSUFjY2Vzc2VzKFxuICBkeW5hbWljQWNjZXNzZXM6IEFycmF5PER5bmFtaWNBY2Nlc3M+XG4pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBkeW5hbWljQWNjZXNzZXNcbiAgICAuZmlsdGVyKFxuICAgICAgKGFjY2Vzcyk6IGFjY2VzcyBpcyBSZXF1aXJlZDxEeW5hbWljQWNjZXNzPiA9PlxuICAgICAgICB0eXBlb2YgYWNjZXNzLnN0YWNrID09PSAnc3RyaW5nJyAmJiBhY2Nlc3Muc3RhY2subGVuZ3RoID4gMFxuICAgIClcbiAgICAubWFwKCh7IGV4cHJlc3Npb24sIHN0YWNrIH0pID0+IHtcbiAgICAgIHN0YWNrID0gc3RhY2tcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAvLyBSZW1vdmUgdGhlIFwiRXJyb3I6IFwiIHByZWZpeCBmcm9tIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBzdGFjayB0cmFjZSBhc1xuICAgICAgICAvLyB3ZWxsIGFzIHRoZSBmaXJzdCA0IGxpbmVzIG9mIHRoZSBzdGFjayB0cmFjZSB3aGljaCBpcyB0aGUgZGlzdGFuY2VcbiAgICAgICAgLy8gZnJvbSB0aGUgdXNlciBjb2RlIGFuZCB0aGUgYG5ldyBFcnJvcigpLnN0YWNrYCBjYWxsLlxuICAgICAgICAuc2xpY2UoNClcbiAgICAgICAgLmZpbHRlcigobGluZSkgPT4ge1xuICAgICAgICAgIC8vIEV4Y2x1ZGUgTmV4dC5qcyBpbnRlcm5hbHMgZnJvbSB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcy9uZXh0LycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeGNsdWRlIGFub255bW91cyBmdW5jdGlvbnMgZnJvbSB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJyAoPGFub255bW91cz4pJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4Y2x1ZGUgTm9kZS5qcyBpbnRlcm5hbHMgZnJvbSB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICAgICAgaWYgKGxpbmUuaW5jbHVkZXMoJyAobm9kZTonKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICByZXR1cm4gYER5bmFtaWMgQVBJIFVzYWdlIERlYnVnIC0gJHtleHByZXNzaW9ufTpcXG4ke3N0YWNrfWBcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBhc3NlcnRQb3N0cG9uZSgpIHtcbiAgaWYgKCFoYXNQb3N0cG9uZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhcmlhbnQ6IFJlYWN0LnVuc3RhYmxlX3Bvc3Rwb25lIGlzIG5vdCBkZWZpbmVkLiBUaGlzIHN1Z2dlc3RzIHRoZSB3cm9uZyB2ZXJzaW9uIG9mIFJlYWN0IHdhcyBsb2FkZWQuIFRoaXMgaXMgYSBidWcgaW4gTmV4dC5qc2BcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgYml0IG9mIGEgaGFjayB0byBhbGxvdyB1cyB0byBhYm9ydCBhIHJlbmRlciB1c2luZyBhIFBvc3Rwb25lIGluc3RhbmNlIGluc3RlYWQgb2YgYW4gRXJyb3Igd2hpY2ggY2hhbmdlcyBSZWFjdCdzXG4gKiBhYm9ydCBzZW1hbnRpY3Mgc2xpZ2h0bHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJJbkJyb3dzZXJBYm9ydFNpZ25hbCgpOiBBYm9ydFNpZ25hbCB7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgY29udHJvbGxlci5hYm9ydChuZXcgQmFpbG91dFRvQ1NSRXJyb3IoJ1JlbmRlciBpbiBCcm93c2VyJykpXG4gIHJldHVybiBjb250cm9sbGVyLnNpZ25hbFxufVxuXG4vKipcbiAqIEluIGEgcHJlcmVuZGVyLCB3ZSBtYXkgZW5kIHVwIHdpdGggaGFuZ2luZyBQcm9taXNlcyBhcyBpbnB1dHMgZHVlIHRoZW1cbiAqIHN0YWxsaW5nIG9uIGNvbm5lY3Rpb24oKSBvciBiZWNhdXNlIHRoZXkncmUgbG9hZGluZyBkeW5hbWljIGRhdGEuIEluIHRoYXRcbiAqIGNhc2Ugd2UgbmVlZCB0byBhYm9ydCB0aGUgZW5jb2Rpbmcgb2YgYXJndW1lbnRzIHNpbmNlIHRoZXknbGwgbmV2ZXIgY29tcGxldGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYW5naW5nSW5wdXRBYm9ydFNpZ25hbChcbiAgd29ya1VuaXRTdG9yZTogV29ya1VuaXRTdG9yZVxuKTogQWJvcnRTaWduYWwgfCB1bmRlZmluZWQge1xuICBzd2l0Y2ggKHdvcmtVbml0U3RvcmUudHlwZSkge1xuICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgY2FzZSAncHJlcmVuZGVyLXJ1bnRpbWUnOlxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuXG4gICAgICBpZiAod29ya1VuaXRTdG9yZS5jYWNoZVNpZ25hbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY2FjaGVTaWduYWwgaXQgbWVhbnMgd2UncmUgaW4gYSBwcm9zcGVjdGl2ZSByZW5kZXIuIElmXG4gICAgICAgIC8vIHRoZSBpbnB1dCB3ZSdyZSB3YWl0aW5nIG9uIGlzIGNvbWluZyBmcm9tIGFub3RoZXIgY2FjaGUsIHdlIGRvIHdhbnRcbiAgICAgICAgLy8gdG8gd2FpdCBmb3IgaXQgc28gdGhhdCB3ZSBjYW4gcmVzb2x2ZSB0aGlzIGNhY2hlIGVudHJ5IHRvby5cbiAgICAgICAgd29ya1VuaXRTdG9yZS5jYWNoZVNpZ25hbC5pbnB1dFJlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2Ugd2UncmUgaW4gdGhlIGZpbmFsIHJlbmRlciBhbmQgd2Ugc2hvdWxkIGFscmVhZHkgaGF2ZSBhbGxcbiAgICAgICAgLy8gb3VyIGNhY2hlcyBmaWxsZWQuXG4gICAgICAgIC8vIElmIHRoZSBwcmVyZW5kZXIgdXNlcyBzdGFnZXMsIHdlIGhhdmUgd2FpdCB1bnRpbCB0aGUgcnVudGltZSBzdGFnZSxcbiAgICAgICAgLy8gYXQgd2hpY2ggcG9pbnQgYWxsIHJ1bnRpbWUgaW5wdXRzIHdpbGwgYmUgcmVzb2x2ZWQuXG4gICAgICAgIC8vIChvdGhlcndpc2UsIGEgcnVudGltZSBwcmVyZW5kZXIgbWlnaHQgY29uc2lkZXIgYGNvb2tpZXMoKWAgaGFuZ2luZ1xuICAgICAgICAvLyAgZXZlbiB0aG91Z2ggdGhleSdkIHJlc29sdmUgaW4gdGhlIG5leHQgdGFzay4pXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIG1pZ2h0IHN0aWxsIGJlIHdhaXRpbmcgb24gc29tZSBtaWNyb3Rhc2tzIHNvIHdlXG4gICAgICAgIC8vIHdhaXQgb25lIHRpY2sgYmVmb3JlIGdpdmluZyB1cC4gV2hlbiB3ZSBnaXZlIHVwLCB3ZSBzdGlsbCB3YW50IHRvXG4gICAgICAgIC8vIHJlbmRlciB0aGUgY29udGVudCBvZiB0aGlzIGNhY2hlIGFzIGRlZXBseSBhcyB3ZSBjYW4gc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgLy8gc3VzcGVuZCBhcyBkZWVwbHkgYXMgcG9zc2libGUgaW4gdGhlIHRyZWUgb3Igbm90IGF0IGFsbCBpZiB3ZSBkb24ndFxuICAgICAgICAvLyBlbmQgdXAgd2FpdGluZyBmb3IgdGhlIGlucHV0LlxuICAgICAgICBjb25zdCBydW50aW1lU3RhZ2VQcm9taXNlID0gZ2V0UnVudGltZVN0YWdlUHJvbWlzZSh3b3JrVW5pdFN0b3JlKVxuICAgICAgICBpZiAocnVudGltZVN0YWdlUHJvbWlzZSkge1xuICAgICAgICAgIHJ1bnRpbWVTdGFnZVByb21pc2UudGhlbigoKSA9PlxuICAgICAgICAgICAgc2NoZWR1bGVPbk5leHRUaWNrKCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSlcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NoZWR1bGVPbk5leHRUaWNrKCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udHJvbGxlci5zaWduYWxcbiAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICBjYXNlICdwcmVyZW5kZXItbGVnYWN5JzpcbiAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICBjYXNlICdjYWNoZSc6XG4gICAgY2FzZSAncHJpdmF0ZS1jYWNoZSc6XG4gICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICB3b3JrVW5pdFN0b3JlIHNhdGlzZmllcyBuZXZlclxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbm5vdGF0ZUR5bmFtaWNBY2Nlc3MoXG4gIGV4cHJlc3Npb246IHN0cmluZyxcbiAgcHJlcmVuZGVyU3RvcmU6IFByZXJlbmRlclN0b3JlTW9kZXJuXG4pIHtcbiAgY29uc3QgZHluYW1pY1RyYWNraW5nID0gcHJlcmVuZGVyU3RvcmUuZHluYW1pY1RyYWNraW5nXG4gIGlmIChkeW5hbWljVHJhY2tpbmcpIHtcbiAgICBkeW5hbWljVHJhY2tpbmcuZHluYW1pY0FjY2Vzc2VzLnB1c2goe1xuICAgICAgc3RhY2s6IGR5bmFtaWNUcmFja2luZy5pc0RlYnVnRHluYW1pY0FjY2Vzc2VzXG4gICAgICAgID8gbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBleHByZXNzaW9uLFxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUR5bmFtaWNSb3V0ZVBhcmFtcyhleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGlmICh3b3JrU3RvcmUgJiYgd29ya1VuaXRTdG9yZSkge1xuICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICBjYXNlICdwcmVyZW5kZXItY2xpZW50JzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlcic6IHtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tQYXJhbXMgPSB3b3JrVW5pdFN0b3JlLmZhbGxiYWNrUm91dGVQYXJhbXNcbiAgICAgICAgaWYgKGZhbGxiYWNrUGFyYW1zICYmIGZhbGxiYWNrUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICAgICAgLy8gV2UgYXJlIGluIGEgcHJlcmVuZGVyIHdpdGggY2FjaGVDb21wb25lbnRzIHNlbWFudGljcy4gV2UgYXJlIGdvaW5nIHRvXG4gICAgICAgICAgLy8gaGFuZyBoZXJlIGFuZCBuZXZlciByZXNvbHZlLiBUaGlzIHdpbGwgY2F1c2UgdGhlIGN1cnJlbnRseVxuICAgICAgICAgIC8vIHJlbmRlcmluZyBjb21wb25lbnQgdG8gZWZmZWN0aXZlbHkgYmUgYSBkeW5hbWljIGhvbGUuXG4gICAgICAgICAgUmVhY3QudXNlKFxuICAgICAgICAgICAgbWFrZUhhbmdpbmdQcm9taXNlKFxuICAgICAgICAgICAgICB3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCxcbiAgICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdwcmVyZW5kZXItcHByJzoge1xuICAgICAgICBjb25zdCBmYWxsYmFja1BhcmFtcyA9IHdvcmtVbml0U3RvcmUuZmFsbGJhY2tSb3V0ZVBhcmFtc1xuICAgICAgICBpZiAoZmFsbGJhY2tQYXJhbXMgJiYgZmFsbGJhY2tQYXJhbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgd29ya1VuaXRTdG9yZS5keW5hbWljVHJhY2tpbmdcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1ydW50aW1lJzpcbiAgICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKFxuICAgICAgICAgIGBcXGAke2V4cHJlc3Npb259XFxgIHdhcyBjYWxsZWQgZHVyaW5nIGEgcnVudGltZSBwcmVyZW5kZXIuIE5leHQuanMgc2hvdWxkIGJlIHByZXZlbnRpbmcgJHtleHByZXNzaW9ufSBmcm9tIGJlaW5nIGluY2x1ZGVkIGluIHNlcnZlciBjb21wb25lbnRzIHN0YXRpY2FsbHksIGJ1dCBkaWQgbm90IGluIHRoaXMgY2FzZS5gXG4gICAgICAgIClcbiAgICAgIGNhc2UgJ2NhY2hlJzpcbiAgICAgIGNhc2UgJ3ByaXZhdGUtY2FjaGUnOlxuICAgICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICAgYFxcYCR7ZXhwcmVzc2lvbn1cXGAgd2FzIGNhbGxlZCBpbnNpZGUgYSBjYWNoZSBzY29wZS4gTmV4dC5qcyBzaG91bGQgYmUgcHJldmVudGluZyAke2V4cHJlc3Npb259IGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gc2VydmVyIGNvbXBvbmVudHMgc3RhdGljYWxseSwgYnV0IGRpZCBub3QgaW4gdGhpcyBjYXNlLmBcbiAgICAgICAgKVxuICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgIGNhc2UgJ3Vuc3RhYmxlLWNhY2hlJzpcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdvcmtVbml0U3RvcmUgc2F0aXNmaWVzIG5ldmVyXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGhhc1N1c3BlbnNlUmVnZXggPSAvXFxuXFxzK2F0IFN1c3BlbnNlIFxcKDxhbm9ueW1vdXM+XFwpL1xuXG4vLyBDb21tb24gaW1wbGljaXQgYm9keSB0YWdzIHRoYXQgUmVhY3Qgd2lsbCB0cmVhdCBhcyBib2R5IHdoZW4gcGxhY2VkIGRpcmVjdGx5IGluIGh0bWxcbmNvbnN0IGJvZHlBbmRJbXBsaWNpdFRhZ3MgPVxuICAnYm9keXxkaXZ8bWFpbnxzZWN0aW9ufGFydGljbGV8YXNpZGV8aGVhZGVyfGZvb3RlcnxuYXZ8Zm9ybXxwfHNwYW58aDF8aDJ8aDN8aDR8aDV8aDYnXG5cbi8vIERldGVjdHMgd2hlbiBSb290TGF5b3V0Qm91bmRhcnkgKG91ciBmcmFtZXdvcmsgbWFya2VyIGNvbXBvbmVudCkgYXBwZWFyc1xuLy8gYWZ0ZXIgU3VzcGVuc2UgaW4gdGhlIGNvbXBvbmVudCBzdGFjaywgaW5kaWNhdGluZyB0aGUgcm9vdCBsYXlvdXQgaXMgd3JhcHBlZFxuLy8gd2l0aGluIGEgU3VzcGVuc2UgYm91bmRhcnkuIEVuc3VyZXMgbm8gYm9keS9odG1sL2ltcGxpY2l0LWJvZHkgY29tcG9uZW50cyBhcmUgaW4gYmV0d2Vlbi5cbi8vXG4vLyBFeGFtcGxlIG1hdGNoZXM6XG4vLyAgIGF0IFN1c3BlbnNlICg8YW5vbnltb3VzPilcbi8vICAgYXQgX19uZXh0X3Jvb3RfbGF5b3V0X2JvdW5kYXJ5X18gKDxhbm9ueW1vdXM+KVxuLy9cbi8vIE9yIHdpdGggb3RoZXIgY29tcG9uZW50cyBpbiBiZXR3ZWVuIChidXQgbm90IGJvZHkvaHRtbC9pbXBsaWNpdC1ib2R5KTpcbi8vICAgYXQgU3VzcGVuc2UgKDxhbm9ueW1vdXM+KVxuLy8gICBhdCBTb21lQ29tcG9uZW50ICg8YW5vbnltb3VzPilcbi8vICAgYXQgX19uZXh0X3Jvb3RfbGF5b3V0X2JvdW5kYXJ5X18gKDxhbm9ueW1vdXM+KVxuY29uc3QgaGFzU3VzcGVuc2VCZWZvcmVSb290TGF5b3V0V2l0aG91dEJvZHlPckltcGxpY2l0Qm9keVJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgYFxcXFxuXFxcXHMrYXQgU3VzcGVuc2UgXFxcXCg8YW5vbnltb3VzPlxcXFwpKD86KD8hXFxcXG5cXFxccythdCAoPzoke2JvZHlBbmRJbXBsaWNpdFRhZ3N9KSBcXFxcKDxhbm9ueW1vdXM+XFxcXCkpW1xcXFxzXFxcXFNdKSo/XFxcXG5cXFxccythdCAke1JPT1RfTEFZT1VUX0JPVU5EQVJZX05BTUV9IFxcXFwoW15cXFxcbl0qXFxcXClgXG4pXG5cbmNvbnN0IGhhc01ldGFkYXRhUmVnZXggPSBuZXcgUmVnRXhwKFxuICBgXFxcXG5cXFxccythdCAke01FVEFEQVRBX0JPVU5EQVJZX05BTUV9W1xcXFxuXFxcXHNdYFxuKVxuY29uc3QgaGFzVmlld3BvcnRSZWdleCA9IG5ldyBSZWdFeHAoXG4gIGBcXFxcblxcXFxzK2F0ICR7VklFV1BPUlRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gXG4pXG5jb25zdCBoYXNPdXRsZXRSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxuXFxcXHMrYXQgJHtPVVRMRVRfQk9VTkRBUllfTkFNRX1bXFxcXG5cXFxcc11gKVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tBbGxvd2VkRHluYW1pY0FjY2VzcyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIGNvbXBvbmVudFN0YWNrOiBzdHJpbmcsXG4gIGR5bmFtaWNWYWxpZGF0aW9uOiBEeW5hbWljVmFsaWRhdGlvblN0YXRlLFxuICBjbGllbnREeW5hbWljOiBEeW5hbWljVHJhY2tpbmdTdGF0ZVxuKSB7XG4gIGlmIChoYXNPdXRsZXRSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gdHJhY2sgdGhhdCB0aGlzIGlzIGR5bmFtaWMuIEl0IGlzIG9ubHkgc28gd2hlbiBzb21ldGhpbmcgZWxzZSBpcyBhbHNvIGR5bmFtaWMuXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzTWV0YWRhdGFSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0R5bmFtaWNNZXRhZGF0YSA9IHRydWVcbiAgICByZXR1cm5cbiAgfSBlbHNlIGlmIChoYXNWaWV3cG9ydFJlZ2V4LnRlc3QoY29tcG9uZW50U3RhY2spKSB7XG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9IGVsc2UgaWYgKFxuICAgIGhhc1N1c3BlbnNlQmVmb3JlUm9vdExheW91dFdpdGhvdXRCb2R5T3JJbXBsaWNpdEJvZHlSZWdleC50ZXN0KFxuICAgICAgY29tcG9uZW50U3RhY2tcbiAgICApXG4gICkge1xuICAgIC8vIEZvciBTdXNwZW5zZSB3aXRoaW4gYm9keSwgdGhlIHByZWx1ZGUgd291bGRuJ3QgYmUgZW1wdHkgc28gaXQgd291bGRuJ3QgdmlvbGF0ZSB0aGUgZW1wdHkgc3RhdGljIHNoZWxscyBydWxlLlxuICAgIC8vIEJ1dCBpZiB5b3UgaGF2ZSBTdXNwZW5zZSBhYm92ZSBib2R5LCB0aGUgcHJlbHVkZSBpcyBlbXB0eSBidXQgd2UgYWxsb3cgdGhhdCBiZWNhdXNlIGhhdmluZyBTdXNwZW5zZVxuICAgIC8vIGlzIGFuIGV4cGxpY2l0IHNpZ25hbCBmcm9tIHRoZSB1c2VyIHRoYXQgdGhleSBhY2tub3dsZWRnZSB0aGUgZW1wdHkgc2hlbGwgYW5kIHdhbnQgZHluYW1pYyByZW5kZXJpbmcuXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzU3VzcGVuc2VBYm92ZUJvZHkgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoaGFzU3VzcGVuc2VSZWdleC50ZXN0KGNvbXBvbmVudFN0YWNrKSkge1xuICAgIC8vIHRoaXMgZXJyb3IgaGFkIGEgU3VzcGVuc2UgYm91bmRhcnkgYWJvdmUgaXQgc28gd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgaXQgYXMgYSBzb3VyY2VcbiAgICAvLyBvZiBkaXNhbGxvd2VkXG4gICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzQWxsb3dlZER5bmFtaWMgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH0gZWxzZSBpZiAoY2xpZW50RHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrKSB7XG4gICAgLy8gVGhpcyB0YXNrIHdhcyB0aGUgdGFzayB0aGF0IGNhbGxlZCB0aGUgc3luYyBlcnJvci5cbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goXG4gICAgICBjbGllbnREeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2tcbiAgICApXG4gICAgcmV0dXJuXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBSb3V0ZSBcIiR7d29ya1N0b3JlLnJvdXRlfVwiOiBBIGNvbXBvbmVudCBhY2Nlc3NlZCBkYXRhLCBoZWFkZXJzLCBwYXJhbXMsIHNlYXJjaFBhcmFtcywgb3IgYSBzaG9ydC1saXZlZCBjYWNoZSB3aXRob3V0IGEgU3VzcGVuc2UgYm91bmRhcnkgbm9yIGEgXCJ1c2UgY2FjaGVcIiBhYm92ZSBpdC4gU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1wcmVyZW5kZXItbWlzc2luZy1zdXNwZW5zZWBcbiAgICBjb25zdCBlcnJvciA9IGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhtZXNzYWdlLCBjb21wb25lbnRTdGFjaylcbiAgICBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzLnB1c2goZXJyb3IpXG4gICAgcmV0dXJuXG4gIH1cbn1cblxuLyoqXG4gKiBJbiBkZXYgbW9kZSwgd2UgcHJlZmVyIHVzaW5nIHRoZSBvd25lciBzdGFjaywgb3RoZXJ3aXNlIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IHN0YWNrIGlzIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayhcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBjb21wb25lbnRTdGFjazogc3RyaW5nXG4pIHtcbiAgY29uc3Qgb3duZXJTdGFjayA9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBSZWFjdC5jYXB0dXJlT3duZXJTdGFja1xuICAgICAgPyBSZWFjdC5jYXB0dXJlT3duZXJTdGFjaygpXG4gICAgICA6IG51bGxcblxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICBlcnJvci5zdGFjayA9IGVycm9yLm5hbWUgKyAnOiAnICsgbWVzc2FnZSArIChvd25lclN0YWNrID8/IGNvbXBvbmVudFN0YWNrKVxuICByZXR1cm4gZXJyb3Jcbn1cblxuZXhwb3J0IGVudW0gUHJlbHVkZVN0YXRlIHtcbiAgRnVsbCA9IDAsXG4gIEVtcHR5ID0gMSxcbiAgRXJyb3JlZCA9IDIsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dEaXNhbGxvd2VkRHluYW1pY0Vycm9yKFxuICB3b3JrU3RvcmU6IFdvcmtTdG9yZSxcbiAgZXJyb3I6IEVycm9yXG4pOiB2b2lkIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcilcblxuICBpZiAoIXdvcmtTdG9yZS5kZXYpIHtcbiAgICBpZiAod29ya1N0b3JlLmhhc1JlYWRhYmxlRXJyb3JTdGFja3MpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBUbyBnZXQgYSBtb3JlIGRldGFpbGVkIHN0YWNrIHRyYWNlIGFuZCBwaW5wb2ludCB0aGUgaXNzdWUsIHN0YXJ0IHRoZSBhcHAgaW4gZGV2ZWxvcG1lbnQgbW9kZSBieSBydW5uaW5nIFxcYG5leHQgZGV2XFxgLCB0aGVuIG9wZW4gXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBpbiB5b3VyIGJyb3dzZXIgdG8gaW52ZXN0aWdhdGUgdGhlIGVycm9yLmBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgVG8gZ2V0IGEgbW9yZSBkZXRhaWxlZCBzdGFjayB0cmFjZSBhbmQgcGlucG9pbnQgdGhlIGlzc3VlLCB0cnkgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC0gU3RhcnQgdGhlIGFwcCBpbiBkZXZlbG9wbWVudCBtb2RlIGJ5IHJ1bm5pbmcgXFxgbmV4dCBkZXZcXGAsIHRoZW4gb3BlbiBcIiR7d29ya1N0b3JlLnJvdXRlfVwiIGluIHlvdXIgYnJvd3NlciB0byBpbnZlc3RpZ2F0ZSB0aGUgZXJyb3IuXG4gIC0gUmVydW4gdGhlIHByb2R1Y3Rpb24gYnVpbGQgd2l0aCBcXGBuZXh0IGJ1aWxkIC0tZGVidWctcHJlcmVuZGVyXFxgIHRvIGdlbmVyYXRlIGJldHRlciBzdGFjayB0cmFjZXMuYClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm93SWZEaXNhbGxvd2VkRHluYW1pYyhcbiAgd29ya1N0b3JlOiBXb3JrU3RvcmUsXG4gIHByZWx1ZGU6IFByZWx1ZGVTdGF0ZSxcbiAgZHluYW1pY1ZhbGlkYXRpb246IER5bmFtaWNWYWxpZGF0aW9uU3RhdGUsXG4gIHNlcnZlckR5bmFtaWM6IER5bmFtaWNUcmFja2luZ1N0YXRlXG4pOiB2b2lkIHtcbiAgaWYgKHByZWx1ZGUgIT09IFByZWx1ZGVTdGF0ZS5GdWxsKSB7XG4gICAgaWYgKGR5bmFtaWNWYWxpZGF0aW9uLmhhc1N1c3BlbnNlQWJvdmVCb2R5KSB7XG4gICAgICAvLyBUaGlzIHJvdXRlIGhhcyBvcHRlZCBpbnRvIGFsbG93aW5nIGZ1bGx5IGR5bmFtaWMgcmVuZGVyaW5nXG4gICAgICAvLyBieSBpbmNsdWRpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBhYm92ZSB0aGUgYm9keS4gSW4gdGhpcyBjYXNlXG4gICAgICAvLyBhIGxhY2sgb2YgYSBzaGVsbCBpcyBub3QgY29uc2lkZXJlZCBkaXNhbGxvd2VkIHNvIHdlIHNpbXBseSByZXR1cm5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJEeW5hbWljLnN5bmNEeW5hbWljRXJyb3JXaXRoU3RhY2spIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIHNoZWxsIGFuZCB0aGUgc2VydmVyIGRpZCBzb21ldGhpbmcgc3luYyBkeW5hbWljIGxpa2VseVxuICAgICAgLy8gbGVhZGluZyB0byBhbiBlYXJseSB0ZXJtaW5hdGlvbiBvZiB0aGUgcHJlcmVuZGVyIGJlZm9yZSB0aGUgc2hlbGxcbiAgICAgIC8vIGNvdWxkIGJlIGNvbXBsZXRlZC4gV2UgdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlci5cbiAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3IoXG4gICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgc2VydmVyRHluYW1pYy5zeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBXZSBkaWRuJ3QgaGF2ZSBhbnkgc3luYyBiYWlsb3V0cyBidXQgdGhlcmUgbWF5IGJlIHVzZXIgY29kZSB3aGljaFxuICAgIC8vIGJsb2NrZWQgdGhlIHJvb3QuIFdlIHdvdWxkIGhhdmUgY2FwdHVyZWQgdGhlc2UgZHVyaW5nIHRoZSBwcmVyZW5kZXJcbiAgICAvLyBhbmQgY2FuIGxvZyB0aGVtIGhlcmUgYW5kIHRoZW4gdGVybWluYXRlIHRoZSBidWlsZC92YWxpZGF0aW5nIHJlbmRlclxuICAgIGNvbnN0IGR5bmFtaWNFcnJvcnMgPSBkeW5hbWljVmFsaWRhdGlvbi5keW5hbWljRXJyb3JzXG4gICAgaWYgKGR5bmFtaWNFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxvZ0Rpc2FsbG93ZWREeW5hbWljRXJyb3Iod29ya1N0b3JlLCBkeW5hbWljRXJyb3JzW2ldKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB0aGUgb25seSBvdGhlciB0aGluZyB0aGF0IGNvdWxkIGJlIGJsb2NraW5nXG4gICAgLy8gdGhlIHJvb3QgaXMgZHluYW1pYyBWaWV3cG9ydC4gSWYgdGhpcyBpcyBkeW5hbWljIHRoZW5cbiAgICAvLyB5b3UgbmVlZCB0byBvcHQgaW50byB0aGF0IGJ5IGFkZGluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5IGFib3ZlIHRoZSBib2R5XG4gICAgLy8gdG8gaW5kaWNhdGUgeW91ciBhcmUgb2sgd2l0aCBmdWxseSBkeW5hbWljIHJlbmRlcmluZy5cbiAgICBpZiAoZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY1ZpZXdwb3J0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZVZpZXdwb3J0XFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdpdGhvdXQgZXhwbGljaXRseSBhbGxvd2luZyBmdWxseSBkeW5hbWljIHJlbmRlcmluZy4gU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LXByZXJlbmRlci1keW5hbWljLXZpZXdwb3J0YFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKHByZWx1ZGUgPT09IFByZWx1ZGVTdGF0ZS5FbXB0eSkge1xuICAgICAgLy8gSWYgd2UgZXZlciBnZXQgdGhpcyBmYXIgdGhlbiB3ZSBtZXNzZWQgdXAgdGhlIHRyYWNraW5nIG9mIGludmFsaWQgZHluYW1pYy5cbiAgICAgIC8vIFdlIHN0aWxsIGFkaGVyZSB0byB0aGUgY29uc3RyYWludCB0aGF0IHlvdSBtdXN0IHByb2R1Y2UgYSBzaGVsbCBidXQgaW52aXRlIHRoZVxuICAgICAgLy8gdXNlciB0byByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBOZXh0LmpzLlxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFJvdXRlIFwiJHt3b3JrU3RvcmUucm91dGV9XCIgZGlkIG5vdCBwcm9kdWNlIGEgc3RhdGljIHNoZWxsIGFuZCBOZXh0LmpzIHdhcyB1bmFibGUgdG8gZGV0ZXJtaW5lIGEgcmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIE5leHQuanMuYFxuICAgICAgKVxuICAgICAgdGhyb3cgbmV3IFN0YXRpY0dlbkJhaWxvdXRFcnJvcigpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIGR5bmFtaWNWYWxpZGF0aW9uLmhhc0FsbG93ZWREeW5hbWljID09PSBmYWxzZSAmJlxuICAgICAgZHluYW1pY1ZhbGlkYXRpb24uaGFzRHluYW1pY01ldGFkYXRhXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgUm91dGUgXCIke3dvcmtTdG9yZS5yb3V0ZX1cIiBoYXMgYSBcXGBnZW5lcmF0ZU1ldGFkYXRhXFxgIHRoYXQgZGVwZW5kcyBvbiBSZXF1ZXN0IGRhdGEgKFxcYGNvb2tpZXMoKVxcYCwgZXRjLi4uKSBvciB1bmNhY2hlZCBleHRlcm5hbCBkYXRhIChcXGBmZXRjaCguLi4pXFxgLCBldGMuLi4pIHdoZW4gdGhlIHJlc3Qgb2YgdGhlIHJvdXRlIGRvZXMgbm90LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcHJlcmVuZGVyLWR5bmFtaWMtbWV0YWRhdGFgXG4gICAgICApXG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5VW50aWxSdW50aW1lU3RhZ2U8VD4oXG4gIHByZXJlbmRlclN0b3JlOiBQcmVyZW5kZXJTdG9yZU1vZGVyblJ1bnRpbWUsXG4gIHJlc3VsdDogUHJvbWlzZTxUPlxuKTogUHJvbWlzZTxUPiB7XG4gIGlmIChwcmVyZW5kZXJTdG9yZS5ydW50aW1lU3RhZ2VQcm9taXNlKSB7XG4gICAgcmV0dXJuIHByZXJlbmRlclN0b3JlLnJ1bnRpbWVTdGFnZVByb21pc2UudGhlbigoKSA9PiByZXN1bHQpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiRHluYW1pY1NlcnZlckVycm9yIiwiU3RhdGljR2VuQmFpbG91dEVycm9yIiwiZ2V0UnVudGltZVN0YWdlUHJvbWlzZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwid29ya0FzeW5jU3RvcmFnZSIsIm1ha2VIYW5naW5nUHJvbWlzZSIsIk1FVEFEQVRBX0JPVU5EQVJZX05BTUUiLCJWSUVXUE9SVF9CT1VOREFSWV9OQU1FIiwiT1VUTEVUX0JPVU5EQVJZX05BTUUiLCJST09UX0xBWU9VVF9CT1VOREFSWV9OQU1FIiwic2NoZWR1bGVPbk5leHRUaWNrIiwiQmFpbG91dFRvQ1NSRXJyb3IiLCJJbnZhcmlhbnRFcnJvciIsImhhc1Bvc3Rwb25lIiwidW5zdGFibGVfcG9zdHBvbmUiLCJjcmVhdGVEeW5hbWljVHJhY2tpbmdTdGF0ZSIsImlzRGVidWdEeW5hbWljQWNjZXNzZXMiLCJkeW5hbWljQWNjZXNzZXMiLCJzeW5jRHluYW1pY0Vycm9yV2l0aFN0YWNrIiwiY3JlYXRlRHluYW1pY1ZhbGlkYXRpb25TdGF0ZSIsImhhc1N1c3BlbnNlQWJvdmVCb2R5IiwiaGFzRHluYW1pY01ldGFkYXRhIiwiaGFzRHluYW1pY1ZpZXdwb3J0IiwiaGFzQWxsb3dlZER5bmFtaWMiLCJkeW5hbWljRXJyb3JzIiwiZ2V0Rmlyc3REeW5hbWljUmVhc29uIiwidHJhY2tpbmdTdGF0ZSIsImV4cHJlc3Npb24iLCJtYXJrQ3VycmVudFNjb3BlQXNEeW5hbWljIiwic3RvcmUiLCJ3b3JrVW5pdFN0b3JlIiwidHlwZSIsImZvcmNlRHluYW1pYyIsImZvcmNlU3RhdGljIiwiZHluYW1pY1Nob3VsZEVycm9yIiwicm91dGUiLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsImR5bmFtaWNUcmFja2luZyIsInJldmFsaWRhdGUiLCJlcnIiLCJkeW5hbWljVXNhZ2VEZXNjcmlwdGlvbiIsImR5bmFtaWNVc2FnZVN0YWNrIiwic3RhY2siLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJ1c2VkRHluYW1pYyIsInRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uIiwicHJlcmVuZGVyU3RvcmUiLCJ0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyIiwiYWJvcnRPblN5bmNocm9ub3VzRHluYW1pY0RhdGFBY2Nlc3MiLCJyZWFzb24iLCJlcnJvciIsImNyZWF0ZVByZXJlbmRlckludGVycnVwdGVkRXJyb3IiLCJjb250cm9sbGVyIiwiYWJvcnQiLCJwdXNoIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJhYm9ydE9uU3luY2hyb25vdXNQbGF0Zm9ybUlPQWNjZXNzIiwiZXJyb3JXaXRoU3RhY2siLCJ0cmFja1N5bmNocm9ub3VzUGxhdGZvcm1JT0FjY2Vzc0luRGV2IiwicmVxdWVzdFN0b3JlIiwicHJlcmVuZGVyUGhhc2UiLCJhYm9ydEFuZFRocm93T25TeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzIiwicHJlcmVuZGVyU2lnbmFsIiwic2lnbmFsIiwiYWJvcnRlZCIsIndhcm5PblN5bmNEeW5hbWljRXJyb3IiLCJjb25zb2xlIiwidHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYiLCJQb3N0cG9uZSIsImdldFN0b3JlIiwiYXNzZXJ0UG9zdHBvbmUiLCJjcmVhdGVQb3N0cG9uZVJlYXNvbiIsImlzRHluYW1pY1Bvc3Rwb25lIiwibWVzc2FnZSIsImlzRHluYW1pY1Bvc3Rwb25lUmVhc29uIiwiaW5jbHVkZXMiLCJORVhUX1BSRVJFTkRFUl9JTlRFUlJVUFRFRCIsImRpZ2VzdCIsImlzUHJlcmVuZGVySW50ZXJydXB0ZWRFcnJvciIsImFjY2Vzc2VkRHluYW1pY0RhdGEiLCJsZW5ndGgiLCJjb25zdW1lRHluYW1pY0FjY2VzcyIsInNlcnZlckR5bmFtaWMiLCJjbGllbnREeW5hbWljIiwiZm9ybWF0RHluYW1pY0FQSUFjY2Vzc2VzIiwiZmlsdGVyIiwiYWNjZXNzIiwibWFwIiwic3BsaXQiLCJzbGljZSIsImxpbmUiLCJqb2luIiwiY3JlYXRlUmVuZGVySW5Ccm93c2VyQWJvcnRTaWduYWwiLCJBYm9ydENvbnRyb2xsZXIiLCJjcmVhdGVIYW5naW5nSW5wdXRBYm9ydFNpZ25hbCIsImNhY2hlU2lnbmFsIiwiaW5wdXRSZWFkeSIsInRoZW4iLCJydW50aW1lU3RhZ2VQcm9taXNlIiwiYW5ub3RhdGVEeW5hbWljQWNjZXNzIiwidXNlRHluYW1pY1JvdXRlUGFyYW1zIiwid29ya1N0b3JlIiwiZmFsbGJhY2tQYXJhbXMiLCJmYWxsYmFja1JvdXRlUGFyYW1zIiwic2l6ZSIsInVzZSIsInJlbmRlclNpZ25hbCIsImhhc1N1c3BlbnNlUmVnZXgiLCJib2R5QW5kSW1wbGljaXRUYWdzIiwiaGFzU3VzcGVuc2VCZWZvcmVSb290TGF5b3V0V2l0aG91dEJvZHlPckltcGxpY2l0Qm9keVJlZ2V4IiwiUmVnRXhwIiwiaGFzTWV0YWRhdGFSZWdleCIsImhhc1ZpZXdwb3J0UmVnZXgiLCJoYXNPdXRsZXRSZWdleCIsInRyYWNrQWxsb3dlZER5bmFtaWNBY2Nlc3MiLCJjb21wb25lbnRTdGFjayIsImR5bmFtaWNWYWxpZGF0aW9uIiwidGVzdCIsImNyZWF0ZUVycm9yV2l0aENvbXBvbmVudE9yT3duZXJTdGFjayIsIm93bmVyU3RhY2siLCJjYXB0dXJlT3duZXJTdGFjayIsIm5hbWUiLCJQcmVsdWRlU3RhdGUiLCJsb2dEaXNhbGxvd2VkRHluYW1pY0Vycm9yIiwiZGV2IiwiaGFzUmVhZGFibGVFcnJvclN0YWNrcyIsInRocm93SWZEaXNhbGxvd2VkRHluYW1pYyIsInByZWx1ZGUiLCJpIiwiZGVsYXlVbnRpbFJ1bnRpbWVTdGFnZSIsInJlc3VsdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1163\n");

/***/ }),

/***/ 5098:
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/esm/server/request/connection.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connection: () => (/* binding */ connection)\n/* harmony export */ });\n/* harmony import */ var _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../app-render/work-async-storage.external */ 1983);\n/* harmony import */ var _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ 6460);\n/* harmony import */ var _app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app-render/dynamic-rendering */ 1163);\n/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../client/components/static-generation-bailout */ 4979);\n/* harmony import */ var _dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dynamic-rendering-utils */ 5770);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ 8823);\n\n\n\n\n\n\n/**\n * This function allows you to indicate that you require an actual user Request before continuing.\n *\n * During prerendering it will never resolve and during rendering it resolves immediately.\n */ function connection() {\n    const callingExpression = 'connection';\n    const workStore = _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_0__.workAsyncStorage.getStore();\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_1__.workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !(0,_utils__WEBPACK_IMPORTED_MODULE_5__.isRequestAPICallableInsideAfter)()) {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"connection\" inside \"after(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but \"after(...)\" executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E186\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic, we override all other logic and always just\n            // return a resolving promise without tracking.\n            return Promise.resolve(undefined);\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_3__.StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E562\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'cache':\n                    {\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"connection\" inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual request, but caches must be able to be produced before a request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E752\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, connection);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'private-cache':\n                    {\n                        // It might not be intuitive to throw for private caches as well, but\n                        // we don't consider runtime prefetches as \"actual requests\" (in the\n                        // navigation sense), despite allowing them to read cookies.\n                        const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"connection\" inside \"use cache: private\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E753\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                        Error.captureStackTrace(error, connection);\n                        workStore.invalidDynamicUsageError ??= error;\n                        throw error;\n                    }\n                case 'unstable-cache':\n                    throw Object.defineProperty(new Error(`Route ${workStore.route} used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E1\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender':\n                case 'prerender-client':\n                case 'prerender-runtime':\n                    // We return a promise that never resolves to allow the prerender to\n                    // stall at this point.\n                    return (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_4__.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, '`connection()`');\n                case 'prerender-ppr':\n                    // We use React's postpone API to interrupt rendering here to create a\n                    // dynamic hole\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.postponeWithTracking)(workStore.route, 'connection', workUnitStore.dynamicTracking);\n                case 'prerender-legacy':\n                    // We throw an error here to interrupt prerendering to mark the route\n                    // as dynamic\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.throwToInterruptStaticGeneration)('connection', workStore, workUnitStore);\n                case 'request':\n                    (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_2__.trackDynamicDataInDynamicRender)(workUnitStore);\n                    if (true) {\n                        // Semantically we only need the dev tracking when running in `next dev`\n                        // but since you would never use next dev with production NODE_ENV we use this\n                        // as a proxy so we can statically exclude this code from production builds.\n                        return (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_4__.makeDevtoolsIOAwarePromise)(undefined);\n                    } else {}\n                default:\n                    workUnitStore;\n            }\n        }\n    }\n    // If we end up here, there was no work store or work unit store present.\n    (0,_app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_1__.throwForMissingRequestStore)(callingExpression);\n} //# sourceMappingURL=connection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cXVlc3QvY29ubmVjdGlvbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3b3JrQXN5bmNTdG9yYWdlIH0gZnJvbSAnLi4vYXBwLXJlbmRlci93b3JrLWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICB0aHJvd0Zvck1pc3NpbmdSZXF1ZXN0U3RvcmUsXG4gIHdvcmtVbml0QXN5bmNTdG9yYWdlLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstdW5pdC1hc3luYy1zdG9yYWdlLmV4dGVybmFsJ1xuaW1wb3J0IHtcbiAgcG9zdHBvbmVXaXRoVHJhY2tpbmcsXG4gIHRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uLFxuICB0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgU3RhdGljR2VuQmFpbG91dEVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dCdcbmltcG9ydCB7XG4gIG1ha2VIYW5naW5nUHJvbWlzZSxcbiAgbWFrZURldnRvb2xzSU9Bd2FyZVByb21pc2UsXG59IGZyb20gJy4uL2R5bmFtaWMtcmVuZGVyaW5nLXV0aWxzJ1xuaW1wb3J0IHsgaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlciB9IGZyb20gJy4vdXRpbHMnXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIGluZGljYXRlIHRoYXQgeW91IHJlcXVpcmUgYW4gYWN0dWFsIHVzZXIgUmVxdWVzdCBiZWZvcmUgY29udGludWluZy5cbiAqXG4gKiBEdXJpbmcgcHJlcmVuZGVyaW5nIGl0IHdpbGwgbmV2ZXIgcmVzb2x2ZSBhbmQgZHVyaW5nIHJlbmRlcmluZyBpdCByZXNvbHZlcyBpbW1lZGlhdGVseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbm5lY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGNhbGxpbmdFeHByZXNzaW9uID0gJ2Nvbm5lY3Rpb24nXG4gIGNvbnN0IHdvcmtTdG9yZSA9IHdvcmtBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuICBjb25zdCB3b3JrVW5pdFN0b3JlID0gd29ya1VuaXRBc3luY1N0b3JhZ2UuZ2V0U3RvcmUoKVxuXG4gIGlmICh3b3JrU3RvcmUpIHtcbiAgICBpZiAoXG4gICAgICB3b3JrVW5pdFN0b3JlICYmXG4gICAgICB3b3JrVW5pdFN0b3JlLnBoYXNlID09PSAnYWZ0ZXInICYmXG4gICAgICAhaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlcigpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvbm5lY3Rpb25cIiBpbnNpZGUgXCJhZnRlciguLi4pXCIuIFRoZSBcXGBjb25uZWN0aW9uKClcXGAgZnVuY3Rpb24gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3Vic2VxdWVudCBjb2RlIG11c3Qgb25seSBydW4gd2hlbiB0aGVyZSBpcyBhbiBhY3R1YWwgUmVxdWVzdCwgYnV0IFwiYWZ0ZXIoLi4uKVwiIGV4ZWN1dGVzIGFmdGVyIHRoZSByZXF1ZXN0LCBzbyB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGUuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvY2FuYXJ5L2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9hZnRlcmBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1N0b3JlLmZvcmNlU3RhdGljKSB7XG4gICAgICAvLyBXaGVuIHVzaW5nIGZvcmNlU3RhdGljLCB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0XG4gICAgICAvLyByZXR1cm4gYSByZXNvbHZpbmcgcHJvbWlzZSB3aXRob3V0IHRyYWNraW5nLlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgfVxuXG4gICAgaWYgKHdvcmtTdG9yZS5keW5hbWljU2hvdWxkRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBTdGF0aWNHZW5CYWlsb3V0RXJyb3IoXG4gICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gd2l0aCBcXGBkeW5hbWljID0gXCJlcnJvclwiXFxgIGNvdWxkbid0IGJlIHJlbmRlcmVkIHN0YXRpY2FsbHkgYmVjYXVzZSBpdCB1c2VkIFxcYGNvbm5lY3Rpb25cXGAuIFNlZSBtb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2J1aWxkaW5nLXlvdXItYXBwbGljYXRpb24vcmVuZGVyaW5nL3N0YXRpYy1hbmQtZHluYW1pYyNkeW5hbWljLXJlbmRlcmluZ2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgICAgc3dpdGNoICh3b3JrVW5pdFN0b3JlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY2FjaGUnOiB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHVzZWQgXCJjb25uZWN0aW9uXCIgaW5zaWRlIFwidXNlIGNhY2hlXCIuIFRoZSBcXGBjb25uZWN0aW9uKClcXGAgZnVuY3Rpb24gaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGUgc3Vic2VxdWVudCBjb2RlIG11c3Qgb25seSBydW4gd2hlbiB0aGVyZSBpcyBhbiBhY3R1YWwgcmVxdWVzdCwgYnV0IGNhY2hlcyBtdXN0IGJlIGFibGUgdG8gYmUgcHJvZHVjZWQgYmVmb3JlIGEgcmVxdWVzdCwgc28gdGhpcyBmdW5jdGlvbiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gICAgICAgICAgKVxuICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjb25uZWN0aW9uKVxuICAgICAgICAgIHdvcmtTdG9yZS5pbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IgPz89IGVycm9yXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwcml2YXRlLWNhY2hlJzoge1xuICAgICAgICAgIC8vIEl0IG1pZ2h0IG5vdCBiZSBpbnR1aXRpdmUgdG8gdGhyb3cgZm9yIHByaXZhdGUgY2FjaGVzIGFzIHdlbGwsIGJ1dFxuICAgICAgICAgIC8vIHdlIGRvbid0IGNvbnNpZGVyIHJ1bnRpbWUgcHJlZmV0Y2hlcyBhcyBcImFjdHVhbCByZXF1ZXN0c1wiIChpbiB0aGVcbiAgICAgICAgICAvLyBuYXZpZ2F0aW9uIHNlbnNlKSwgZGVzcGl0ZSBhbGxvd2luZyB0aGVtIHRvIHJlYWQgY29va2llcy5cbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvbm5lY3Rpb25cIiBpbnNpZGUgXCJ1c2UgY2FjaGU6IHByaXZhdGVcIi4gVGhlIFxcYGNvbm5lY3Rpb24oKVxcYCBmdW5jdGlvbiBpcyB1c2VkIHRvIGluZGljYXRlIHRoZSBzdWJzZXF1ZW50IGNvZGUgbXVzdCBvbmx5IHJ1biB3aGVuIHRoZXJlIGlzIGFuIGFjdHVhbCBuYXZpZ2F0aW9uIHJlcXVlc3QsIGJ1dCBjYWNoZXMgbXVzdCBiZSBhYmxlIHRvIGJlIHByb2R1Y2VkIGJlZm9yZSBhIG5hdmlnYXRpb24gcmVxdWVzdCwgc28gdGhpcyBmdW5jdGlvbiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gICAgICAgICAgKVxuICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjb25uZWN0aW9uKVxuICAgICAgICAgIHdvcmtTdG9yZS5pbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IgPz89IGVycm9yXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd1bnN0YWJsZS1jYWNoZSc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB1c2VkIFwiY29ubmVjdGlvblwiIGluc2lkZSBhIGZ1bmN0aW9uIGNhY2hlZCB3aXRoIFwidW5zdGFibGVfY2FjaGUoLi4uKVwiLiBUaGUgXFxgY29ubmVjdGlvbigpXFxgIGZ1bmN0aW9uIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhlIHN1YnNlcXVlbnQgY29kZSBtdXN0IG9ubHkgcnVuIHdoZW4gdGhlcmUgaXMgYW4gYWN0dWFsIFJlcXVlc3QsIGJ1dCBjYWNoZXMgbXVzdCBiZSBhYmxlIHRvIGJlIHByb2R1Y2VkIGJlZm9yZSBhIFJlcXVlc3Qgc28gdGhpcyBmdW5jdGlvbiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bnN0YWJsZV9jYWNoZWBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICBjYXNlICdwcmVyZW5kZXItcnVudGltZSc6XG4gICAgICAgICAgLy8gV2UgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IG5ldmVyIHJlc29sdmVzIHRvIGFsbG93IHRoZSBwcmVyZW5kZXIgdG9cbiAgICAgICAgICAvLyBzdGFsbCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgIHJldHVybiBtYWtlSGFuZ2luZ1Byb21pc2UoXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLnJlbmRlclNpZ25hbCxcbiAgICAgICAgICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAgICAgICAgICdgY29ubmVjdGlvbigpYCdcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgIC8vIFdlIHVzZSBSZWFjdCdzIHBvc3Rwb25lIEFQSSB0byBpbnRlcnJ1cHQgcmVuZGVyaW5nIGhlcmUgdG8gY3JlYXRlIGFcbiAgICAgICAgICAvLyBkeW5hbWljIGhvbGVcbiAgICAgICAgICByZXR1cm4gcG9zdHBvbmVXaXRoVHJhY2tpbmcoXG4gICAgICAgICAgICB3b3JrU3RvcmUucm91dGUsXG4gICAgICAgICAgICAnY29ubmVjdGlvbicsXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgIClcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgICAgLy8gV2UgdGhyb3cgYW4gZXJyb3IgaGVyZSB0byBpbnRlcnJ1cHQgcHJlcmVuZGVyaW5nIHRvIG1hcmsgdGhlIHJvdXRlXG4gICAgICAgICAgLy8gYXMgZHluYW1pY1xuICAgICAgICAgIHJldHVybiB0aHJvd1RvSW50ZXJydXB0U3RhdGljR2VuZXJhdGlvbihcbiAgICAgICAgICAgICdjb25uZWN0aW9uJyxcbiAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmVcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3JlcXVlc3QnOlxuICAgICAgICAgIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIod29ya1VuaXRTdG9yZSlcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIC8vIFNlbWFudGljYWxseSB3ZSBvbmx5IG5lZWQgdGhlIGRldiB0cmFja2luZyB3aGVuIHJ1bm5pbmcgaW4gYG5leHQgZGV2YFxuICAgICAgICAgICAgLy8gYnV0IHNpbmNlIHlvdSB3b3VsZCBuZXZlciB1c2UgbmV4dCBkZXYgd2l0aCBwcm9kdWN0aW9uIE5PREVfRU5WIHdlIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyBhcyBhIHByb3h5IHNvIHdlIGNhbiBzdGF0aWNhbGx5IGV4Y2x1ZGUgdGhpcyBjb2RlIGZyb20gcHJvZHVjdGlvbiBidWlsZHMuXG4gICAgICAgICAgICByZXR1cm4gbWFrZURldnRvb2xzSU9Bd2FyZVByb21pc2UodW5kZWZpbmVkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd29ya1VuaXRTdG9yZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgdGhlcmUgd2FzIG5vIHdvcmsgc3RvcmUgb3Igd29yayB1bml0IHN0b3JlIHByZXNlbnQuXG4gIHRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZShjYWxsaW5nRXhwcmVzc2lvbilcbn1cbiJdLCJuYW1lcyI6WyJ3b3JrQXN5bmNTdG9yYWdlIiwidGhyb3dGb3JNaXNzaW5nUmVxdWVzdFN0b3JlIiwid29ya1VuaXRBc3luY1N0b3JhZ2UiLCJwb3N0cG9uZVdpdGhUcmFja2luZyIsInRocm93VG9JbnRlcnJ1cHRTdGF0aWNHZW5lcmF0aW9uIiwidHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlciIsIlN0YXRpY0dlbkJhaWxvdXRFcnJvciIsIm1ha2VIYW5naW5nUHJvbWlzZSIsIm1ha2VEZXZ0b29sc0lPQXdhcmVQcm9taXNlIiwiaXNSZXF1ZXN0QVBJQ2FsbGFibGVJbnNpZGVBZnRlciIsImNvbm5lY3Rpb24iLCJjYWxsaW5nRXhwcmVzc2lvbiIsIndvcmtTdG9yZSIsImdldFN0b3JlIiwid29ya1VuaXRTdG9yZSIsInBoYXNlIiwiRXJyb3IiLCJyb3V0ZSIsImZvcmNlU3RhdGljIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1bmRlZmluZWQiLCJkeW5hbWljU2hvdWxkRXJyb3IiLCJ0eXBlIiwiZXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImludmFsaWREeW5hbWljVXNhZ2VFcnJvciIsInJlbmRlclNpZ25hbCIsImR5bmFtaWNUcmFja2luZyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5098\n");

/***/ }),

/***/ 6005:
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/esm/server/request/cookies.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cookies: () => (/* binding */ cookies)\n/* harmony export */ });\n/* harmony import */ var _web_spec_extension_adapters_request_cookies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../web/spec-extension/adapters/request-cookies */ 261);\n/* harmony import */ var _web_spec_extension_cookies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../web/spec-extension/cookies */ 7028);\n/* harmony import */ var _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../app-render/work-async-storage.external */ 1983);\n/* harmony import */ var _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../app-render/work-unit-async-storage.external */ 6460);\n/* harmony import */ var _app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../app-render/dynamic-rendering */ 1163);\n/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../client/components/static-generation-bailout */ 4979);\n/* harmony import */ var _dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamic-rendering-utils */ 5770);\n/* harmony import */ var _create_deduped_by_callsite_server_error_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../create-deduped-by-callsite-server-error-logger */ 1932);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils */ 8823);\n/* harmony import */ var _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../shared/lib/invariant-error */ 9809);\n/* harmony import */ var _web_spec_extension_adapters_reflect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../web/spec-extension/adapters/reflect */ 4115);\n\n\n\n\n\n\n\n\n\n\n\nfunction cookies() {\n    const callingExpression = 'cookies';\n    const workStore = _app_render_work_async_storage_external__WEBPACK_IMPORTED_MODULE_2__.workAsyncStorage.getStore();\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__.workUnitAsyncStorage.getStore();\n    if (workStore) {\n        if (workUnitStore && workUnitStore.phase === 'after' && !(0,_utils__WEBPACK_IMPORTED_MODULE_8__.isRequestAPICallableInsideAfter)()) {\n            throw Object.defineProperty(new Error(`Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`), \"__NEXT_ERROR_CODE\", {\n                value: \"E88\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workStore.forceStatic) {\n            // When using forceStatic we override all other logic and always just return an empty\n            // cookies object without tracking\n            const underlyingCookies = createEmptyCookies();\n            return makeUntrackedExoticCookies(underlyingCookies);\n        }\n        if (workStore.dynamicShouldError) {\n            throw Object.defineProperty(new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_5__.StaticGenBailoutError(`Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`), \"__NEXT_ERROR_CODE\", {\n                value: \"E549\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        if (workUnitStore) {\n            switch(workUnitStore.type){\n                case 'cache':\n                    const error = Object.defineProperty(new Error(`Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E398\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Error.captureStackTrace(error, cookies);\n                    workStore.invalidDynamicUsageError ??= error;\n                    throw error;\n                case 'unstable-cache':\n                    throw Object.defineProperty(new Error(`Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E157\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender':\n                    return makeHangingCookies(workStore, workUnitStore);\n                case 'prerender-client':\n                    const exportName = '`cookies`';\n                    throw Object.defineProperty(new _shared_lib_invariant_error__WEBPACK_IMPORTED_MODULE_9__.InvariantError(`${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E693\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                case 'prerender-ppr':\n                    // We need track dynamic access here eagerly to keep continuity with\n                    // how cookies has worked in PPR without cacheComponents.\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_4__.postponeWithTracking)(workStore.route, callingExpression, workUnitStore.dynamicTracking);\n                case 'prerender-legacy':\n                    // We track dynamic access here so we don't need to wrap the cookies\n                    // in individual property access tracking.\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_4__.throwToInterruptStaticGeneration)(callingExpression, workStore, workUnitStore);\n                case 'prerender-runtime':\n                    return (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_4__.delayUntilRuntimeStage)(workUnitStore, makeUntrackedCookies(workUnitStore.cookies));\n                case 'private-cache':\n                    if (false) {}\n                    return makeUntrackedExoticCookies(workUnitStore.cookies);\n                case 'request':\n                    (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_4__.trackDynamicDataInDynamicRender)(workUnitStore);\n                    let underlyingCookies;\n                    if ((0,_web_spec_extension_adapters_request_cookies__WEBPACK_IMPORTED_MODULE_0__.areCookiesMutableInCurrentPhase)(workUnitStore)) {\n                        // We can't conditionally return different types here based on the context.\n                        // To avoid confusion, we always return the readonly type here.\n                        underlyingCookies = workUnitStore.userspaceMutableCookies;\n                    } else {\n                        underlyingCookies = workUnitStore.cookies;\n                    }\n                    if (true) {\n                        // Semantically we only need the dev tracking when running in `next dev`\n                        // but since you would never use next dev with production NODE_ENV we use this\n                        // as a proxy so we can statically exclude this code from production builds.\n                        if (false) {}\n                        return makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, workStore == null ? void 0 : workStore.route);\n                    } else {}\n                default:\n                    workUnitStore;\n            }\n        }\n    }\n    // If we end up here, there was no work store or work unit store present.\n    (0,_app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__.throwForMissingRequestStore)(callingExpression);\n}\nfunction createEmptyCookies() {\n    return _web_spec_extension_adapters_request_cookies__WEBPACK_IMPORTED_MODULE_0__.RequestCookiesAdapter.seal(new _web_spec_extension_cookies__WEBPACK_IMPORTED_MODULE_1__.RequestCookies(new Headers({})));\n}\nconst CachedCookies = new WeakMap();\nfunction makeHangingCookies(workStore, prerenderStore) {\n    const cachedPromise = CachedCookies.get(prerenderStore);\n    if (cachedPromise) {\n        return cachedPromise;\n    }\n    const promise = (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_6__.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, '`cookies()`');\n    CachedCookies.set(prerenderStore, promise);\n    return promise;\n}\nfunction makeUntrackedCookies(underlyingCookies) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = Promise.resolve(underlyingCookies);\n    CachedCookies.set(underlyingCookies, promise);\n    return promise;\n}\nfunction makeUntrackedExoticCookies(underlyingCookies) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = Promise.resolve(underlyingCookies);\n    CachedCookies.set(underlyingCookies, promise);\n    Object.defineProperties(promise, {\n        [Symbol.iterator]: {\n            value: underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.bind(underlyingCookies)\n        },\n        size: {\n            get () {\n                return underlyingCookies.size;\n            }\n        },\n        get: {\n            value: underlyingCookies.get.bind(underlyingCookies)\n        },\n        getAll: {\n            value: underlyingCookies.getAll.bind(underlyingCookies)\n        },\n        has: {\n            value: underlyingCookies.has.bind(underlyingCookies)\n        },\n        set: {\n            value: underlyingCookies.set.bind(underlyingCookies)\n        },\n        delete: {\n            value: underlyingCookies.delete.bind(underlyingCookies)\n        },\n        clear: {\n            value: typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.bind(underlyingCookies) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise)\n        },\n        toString: {\n            value: underlyingCookies.toString.bind(underlyingCookies)\n        }\n    });\n    return promise;\n}\nfunction makeUntrackedExoticCookiesWithDevWarnings(underlyingCookies, route) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_6__.makeDevtoolsIOAwarePromise)(underlyingCookies);\n    CachedCookies.set(underlyingCookies, promise);\n    Object.defineProperties(promise, {\n        [Symbol.iterator]: {\n            value: function() {\n                const expression = '`...cookies()` or similar iteration';\n                syncIODev(route, expression);\n                return underlyingCookies[Symbol.iterator] ? underlyingCookies[Symbol.iterator].apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n                // has extra properties not available on RequestCookie instances.\n                polyfilledResponseCookiesIterator.call(underlyingCookies);\n            },\n            writable: false\n        },\n        size: {\n            get () {\n                const expression = '`cookies().size`';\n                syncIODev(route, expression);\n                return underlyingCookies.size;\n            }\n        },\n        get: {\n            value: function get() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().get()`';\n                } else {\n                    expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.get.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        getAll: {\n            value: function getAll() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().getAll()`';\n                } else {\n                    expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.getAll.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        has: {\n            value: function get() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().has()`';\n                } else {\n                    expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.has.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        set: {\n            value: function set() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().set()`';\n                } else {\n                    const arg = arguments[0];\n                    if (arg) {\n                        expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``;\n                    } else {\n                        expression = '`cookies().set(...)`';\n                    }\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.set.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        delete: {\n            value: function() {\n                let expression;\n                if (arguments.length === 0) {\n                    expression = '`cookies().delete()`';\n                } else if (arguments.length === 1) {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``;\n                } else {\n                    expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``;\n                }\n                syncIODev(route, expression);\n                return underlyingCookies.delete.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        },\n        clear: {\n            value: function clear() {\n                const expression = '`cookies().clear()`';\n                syncIODev(route, expression);\n                // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n                return typeof underlyingCookies.clear === 'function' ? underlyingCookies.clear.apply(underlyingCookies, arguments) : // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n                // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n                // has extra properties not available on RequestCookie instances.\n                polyfilledResponseCookiesClear.call(underlyingCookies, promise);\n            },\n            writable: false\n        },\n        toString: {\n            value: function toString() {\n                const expression = '`cookies().toString()` or implicit casting';\n                syncIODev(route, expression);\n                return underlyingCookies.toString.apply(underlyingCookies, arguments);\n            },\n            writable: false\n        }\n    });\n    return promise;\n}\n// Similar to `makeUntrackedExoticCookiesWithDevWarnings`, but just logging the\n// sync access without actually defining the cookies properties on the promise.\nfunction makeUntrackedCookiesWithDevWarnings(underlyingCookies, route) {\n    const cachedCookies = CachedCookies.get(underlyingCookies);\n    if (cachedCookies) {\n        return cachedCookies;\n    }\n    const promise = (0,_dynamic_rendering_utils__WEBPACK_IMPORTED_MODULE_6__.makeDevtoolsIOAwarePromise)(underlyingCookies);\n    const proxiedPromise = new Proxy(promise, {\n        get (target, prop, receiver) {\n            switch(prop){\n                case Symbol.iterator:\n                    {\n                        warnForSyncAccess(route, '`...cookies()` or similar iteration');\n                        break;\n                    }\n                case 'size':\n                case 'get':\n                case 'getAll':\n                case 'has':\n                case 'set':\n                case 'delete':\n                case 'clear':\n                case 'toString':\n                    {\n                        warnForSyncAccess(route, `\\`cookies().${prop}\\``);\n                        break;\n                    }\n                default:\n                    {\n                    // We only warn for well-defined properties of the cookies object.\n                    }\n            }\n            return _web_spec_extension_adapters_reflect__WEBPACK_IMPORTED_MODULE_10__.ReflectAdapter.get(target, prop, receiver);\n        }\n    });\n    CachedCookies.set(underlyingCookies, proxiedPromise);\n    return proxiedPromise;\n}\nfunction describeNameArg(arg) {\n    return typeof arg === 'object' && arg !== null && typeof arg.name === 'string' ? `'${arg.name}'` : typeof arg === 'string' ? `'${arg}'` : '...';\n}\nfunction syncIODev(route, expression) {\n    const workUnitStore = _app_render_work_unit_async_storage_external__WEBPACK_IMPORTED_MODULE_3__.workUnitAsyncStorage.getStore();\n    if (workUnitStore) {\n        switch(workUnitStore.type){\n            case 'request':\n                if (workUnitStore.prerenderPhase === true) {\n                    // When we're rendering dynamically in dev, we need to advance out of\n                    // the Prerender environment when we read Request data synchronously.\n                    (0,_app_render_dynamic_rendering__WEBPACK_IMPORTED_MODULE_4__.trackSynchronousRequestDataAccessInDev)(workUnitStore);\n                }\n                break;\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n                break;\n            default:\n                workUnitStore;\n        }\n    }\n    // In all cases we warn normally\n    warnForSyncAccess(route, expression);\n}\nconst warnForSyncAccess = (0,_create_deduped_by_callsite_server_error_logger__WEBPACK_IMPORTED_MODULE_7__.createDedupedByCallsiteServerErrorLoggerDev)(createCookiesAccessError);\nfunction createCookiesAccessError(route, expression) {\n    const prefix = route ? `Route \"${route}\" ` : 'This route ';\n    return Object.defineProperty(new Error(`${prefix}used ${expression}. ` + `\\`cookies()\\` should be awaited before using its value. ` + `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`), \"__NEXT_ERROR_CODE\", {\n        value: \"E223\",\n        enumerable: false,\n        configurable: true\n    });\n}\nfunction polyfilledResponseCookiesIterator() {\n    return this.getAll().map((c)=>[\n            c.name,\n            c\n        ]).values();\n}\nfunction polyfilledResponseCookiesClear(returnable) {\n    for (const cookie of this.getAll()){\n        this.delete(cookie.name);\n    }\n    return returnable;\n} //# sourceMappingURL=cookies.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQ0g7WUFDRjtnQkFDRUE7UUFDSjtJQUNGO0lBRUEsZ0NBQWdDO0lBQ2hDaUUsa0JBQWtCOUQsT0FBT2dEO0FBQzNCO0FBRUEsTUFBTWMsb0JBQW9CekUsNEhBQTJDQSxDQUNuRTRFO0FBR0YsU0FBU0EseUJBQ1BqRSxLQUF5QixFQUN6QmdELFVBQWtCO0lBRWxCLE1BQU1rQixTQUFTbEUsUUFBUSxDQUFDLE9BQU8sRUFBRUEsTUFBTSxFQUFFLENBQUMsR0FBRztJQUM3QyxPQUFPLHFCQUlOLENBSk0sSUFBSUQsTUFDVCxHQUFHbUUsT0FBTyxLQUFLLEVBQUVsQixXQUFXLEVBQUUsQ0FBQyxHQUM3QixDQUFDLHdEQUF3RCxDQUFDLEdBQzFELENBQUMsOERBQThELENBQUMsR0FIN0Q7ZUFBQTtvQkFBQTtzQkFBQTtJQUlQO0FBQ0Y7QUFFQSxTQUFTUjtJQUdQLE9BQU8sSUFBSSxDQUFDRSxNQUFNLEdBQ2Z5QixHQUFHLENBQUMsQ0FBQ0MsSUFBTTtZQUFDQSxFQUFFTCxJQUFJO1lBQUVLO1NBQUUsRUFDdEJDLE1BQU07QUFDWDtBQUVBLFNBQVN2QiwrQkFFUHdCLFVBQTJDO0lBRTNDLEtBQUssTUFBTUMsVUFBVSxJQUFJLENBQUM3QixNQUFNLEdBQUk7UUFDbEMsSUFBSSxDQUFDRSxNQUFNLENBQUMyQixPQUFPUixJQUFJO0lBQ3pCO0lBQ0EsT0FBT087QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2FtYW5iaG9nYWwvc3JjL3NlcnZlci9yZXF1ZXN0L2Nvb2tpZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgdHlwZSBSZWFkb25seVJlcXVlc3RDb29raWVzLFxuICB0eXBlIFJlc3BvbnNlQ29va2llcyxcbiAgYXJlQ29va2llc011dGFibGVJbkN1cnJlbnRQaGFzZSxcbiAgUmVxdWVzdENvb2tpZXNBZGFwdGVyLFxufSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvcmVxdWVzdC1jb29raWVzJ1xuaW1wb3J0IHsgUmVxdWVzdENvb2tpZXMgfSBmcm9tICcuLi93ZWIvc3BlYy1leHRlbnNpb24vY29va2llcydcbmltcG9ydCB7XG4gIHdvcmtBc3luY1N0b3JhZ2UsXG4gIHR5cGUgV29ya1N0b3JlLFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL3dvcmstYXN5bmMtc3RvcmFnZS5leHRlcm5hbCdcbmltcG9ydCB7XG4gIHRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZSxcbiAgd29ya1VuaXRBc3luY1N0b3JhZ2UsXG4gIHR5cGUgUHJlcmVuZGVyU3RvcmVNb2Rlcm4sXG59IGZyb20gJy4uL2FwcC1yZW5kZXIvd29yay11bml0LWFzeW5jLXN0b3JhZ2UuZXh0ZXJuYWwnXG5pbXBvcnQge1xuICBkZWxheVVudGlsUnVudGltZVN0YWdlLFxuICBwb3N0cG9uZVdpdGhUcmFja2luZyxcbiAgdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24sXG4gIHRyYWNrRHluYW1pY0RhdGFJbkR5bmFtaWNSZW5kZXIsXG4gIHRyYWNrU3luY2hyb25vdXNSZXF1ZXN0RGF0YUFjY2Vzc0luRGV2LFxufSBmcm9tICcuLi9hcHAtcmVuZGVyL2R5bmFtaWMtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgU3RhdGljR2VuQmFpbG91dEVycm9yIH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvc3RhdGljLWdlbmVyYXRpb24tYmFpbG91dCdcbmltcG9ydCB7XG4gIG1ha2VEZXZ0b29sc0lPQXdhcmVQcm9taXNlLFxuICBtYWtlSGFuZ2luZ1Byb21pc2UsXG59IGZyb20gJy4uL2R5bmFtaWMtcmVuZGVyaW5nLXV0aWxzJ1xuaW1wb3J0IHsgY3JlYXRlRGVkdXBlZEJ5Q2FsbHNpdGVTZXJ2ZXJFcnJvckxvZ2dlckRldiB9IGZyb20gJy4uL2NyZWF0ZS1kZWR1cGVkLWJ5LWNhbGxzaXRlLXNlcnZlci1lcnJvci1sb2dnZXInXG5pbXBvcnQgeyBpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyIH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IEludmFyaWFudEVycm9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9pbnZhcmlhbnQtZXJyb3InXG5pbXBvcnQgeyBSZWZsZWN0QWRhcHRlciB9IGZyb20gJy4uL3dlYi9zcGVjLWV4dGVuc2lvbi9hZGFwdGVycy9yZWZsZWN0J1xuXG4vKipcbiAqIEluIHRoaXMgdmVyc2lvbiBvZiBOZXh0LmpzIGBjb29raWVzKClgIHJldHVybnMgYSBQcm9taXNlIGhvd2V2ZXIgeW91IGNhbiBzdGlsbCByZWZlcmVuY2UgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHVuZGVybHlpbmcgY29va2llcyBvYmplY3RcbiAqIHN5bmNocm9ub3VzbHkgdG8gZmFjaWxpdGF0ZSBtaWdyYXRpb24uIFRoZSBgVW5zYWZlVW53cmFwcGVkQ29va2llc2AgdHlwZSBpcyBhZGRlZCB0byB5b3VyIGNvZGUgYnkgYSBjb2RlbW9kIHRoYXQgYXR0ZW1wdHMgdG8gYXV0b21hdGljYWxseVxuICogdXBkYXRlcyBjYWxsc2l0ZXMgdG8gcmVmbGVjdCB0aGUgbmV3IFByb21pc2UgcmV0dXJuIHR5cGUuIFRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIGBjb29raWVzKClgIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCwgbmFtZWx5XG4gKiB3aGVuIGl0IGlzIHVzZWQgaW5zaWRlIGEgc3luY2hyb25vdXMgZnVuY3Rpb24gYW5kIHdlIGNhbid0IGJlIHN1cmUgdGhlIGZ1bmN0aW9uIGNhbiBiZSBtYWRlIGFzeW5jIGF1dG9tYXRpY2FsbHkuIEluIHRoZXNlIGNhc2VzIHdlIGFkZCBhblxuICogZXhwbGljaXQgdHlwZSBjYXNlIHRvIGBVbnNhZmVVbndyYXBwZWRDb29raWVzYCB0byBlbmFibGUgdHlwZXNjcmlwdCB0byBhbGxvdyBmb3IgdGhlIHN5bmNocm9ub3VzIHVzYWdlIG9ubHkgd2hlcmUgaXQgaXMgYWN0dWFsbHkgbmVjZXNzYXJ5LlxuICpcbiAqIFlvdSBzaG91bGQgc2hvdWxkIHVwZGF0ZSB0aGVzZSBjYWxsc2l0ZXMgdG8gZWl0aGVyIGJlIGFzeW5jIGZ1bmN0aW9ucyB3aGVyZSB0aGUgYGNvb2tpZXMoKWAgdmFsdWUgY2FuIGJlIGF3YWl0ZWQgb3IgeW91IHNob3VsZCBjYWxsIGBjb29raWVzKClgXG4gKiBmcm9tIG91dHNpZGUgYW5kIGF3YWl0IHRoZSByZXR1cm4gdmFsdWUgYmVmb3JlIHBhc3NpbmcgaXQgaW50byB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIFlvdSBjYW4gZmluZCBpbnN0YW5jZXMgdGhhdCByZXF1aXJlIG1hbnVhbCBtaWdyYXRpb24gYnkgc2VhcmNoaW5nIGZvciBgVW5zYWZlVW53cmFwcGVkQ29va2llc2AgaW4geW91ciBjb2RlYmFzZSBvciBieSBzZWFyY2ggZm9yIGEgY29tbWVudCB0aGF0XG4gKiBzdGFydHMgd2l0aCBgQG5leHQtY29kZW1vZC1lcnJvcmAuXG4gKlxuICogSW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBOZXh0LmpzIGBjb29raWVzKClgIHdpbGwgb25seSByZXR1cm4gYSBQcm9taXNlIGFuZCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgY29va2llcyBvYmplY3QgZGlyZWN0bHlcbiAqIHdpdGhvdXQgYXdhaXRpbmcgdGhlIHJldHVybiB2YWx1ZSBmaXJzdC4gV2hlbiB0aGlzIGNoYW5nZSBoYXBwZW5zIHRoZSB0eXBlIGBVbnNhZmVVbndyYXBwZWRDb29raWVzYCB3aWxsIGJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGF0IGlzIGl0IG5vIGxvbmdlclxuICogdXNhYmxlLlxuICpcbiAqIFRoaXMgdHlwZSBpcyBtYXJrZWQgZGVwcmVjYXRlZCB0byBoZWxwIGlkZW50aWZ5IGl0IGFzIHRhcmdldCBmb3IgcmVmYWN0b3JpbmcgYXdheS5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgdHlwZSBVbnNhZmVVbndyYXBwZWRDb29raWVzID0gUmVhZG9ubHlSZXF1ZXN0Q29va2llc1xuXG5leHBvcnQgZnVuY3Rpb24gY29va2llcygpOiBQcm9taXNlPFJlYWRvbmx5UmVxdWVzdENvb2tpZXM+IHtcbiAgY29uc3QgY2FsbGluZ0V4cHJlc3Npb24gPSAnY29va2llcydcbiAgY29uc3Qgd29ya1N0b3JlID0gd29ya0FzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG4gIGNvbnN0IHdvcmtVbml0U3RvcmUgPSB3b3JrVW5pdEFzeW5jU3RvcmFnZS5nZXRTdG9yZSgpXG5cbiAgaWYgKHdvcmtTdG9yZSkge1xuICAgIGlmIChcbiAgICAgIHdvcmtVbml0U3RvcmUgJiZcbiAgICAgIHdvcmtVbml0U3RvcmUucGhhc2UgPT09ICdhZnRlcicgJiZcbiAgICAgICFpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyKClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gVE9ETyhhZnRlcik6IGNsYXJpZnkgdGhhdCB0aGlzIG9ubHkgYXBwbGllcyB0byBwYWdlcz9cbiAgICAgICAgYFJvdXRlICR7d29ya1N0b3JlLnJvdXRlfSB1c2VkIFwiY29va2llc1wiIGluc2lkZSBcImFmdGVyKC4uLilcIi4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJZiB5b3UgbmVlZCB0aGlzIGRhdGEgaW5zaWRlIGFuIFwiYWZ0ZXJcIiBjYWxsYmFjaywgdXNlIFwiY29va2llc1wiIG91dHNpZGUgb2YgdGhlIGNhbGxiYWNrLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2NhbmFyeS9hcHAvYXBpLXJlZmVyZW5jZS9mdW5jdGlvbnMvYWZ0ZXJgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHdvcmtTdG9yZS5mb3JjZVN0YXRpYykge1xuICAgICAgLy8gV2hlbiB1c2luZyBmb3JjZVN0YXRpYyB3ZSBvdmVycmlkZSBhbGwgb3RoZXIgbG9naWMgYW5kIGFsd2F5cyBqdXN0IHJldHVybiBhbiBlbXB0eVxuICAgICAgLy8gY29va2llcyBvYmplY3Qgd2l0aG91dCB0cmFja2luZ1xuICAgICAgY29uc3QgdW5kZXJseWluZ0Nvb2tpZXMgPSBjcmVhdGVFbXB0eUNvb2tpZXMoKVxuICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzKHVuZGVybHlpbmdDb29raWVzKVxuICAgIH1cblxuICAgIGlmICh3b3JrU3RvcmUuZHluYW1pY1Nob3VsZEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgU3RhdGljR2VuQmFpbG91dEVycm9yKFxuICAgICAgICBgUm91dGUgJHt3b3JrU3RvcmUucm91dGV9IHdpdGggXFxgZHluYW1pYyA9IFwiZXJyb3JcIlxcYCBjb3VsZG4ndCBiZSByZW5kZXJlZCBzdGF0aWNhbGx5IGJlY2F1c2UgaXQgdXNlZCBcXGBjb29raWVzXFxgLiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9zdGF0aWMtYW5kLWR5bmFtaWMjZHluYW1pYy1yZW5kZXJpbmdgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHdvcmtVbml0U3RvcmUpIHtcbiAgICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NhY2hlJzpcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvb2tpZXNcIiBpbnNpZGUgXCJ1c2UgY2FjaGVcIi4gQWNjZXNzaW5nIER5bmFtaWMgZGF0YSBzb3VyY2VzIGluc2lkZSBhIGNhY2hlIHNjb3BlIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYSBjYWNoZWQgZnVuY3Rpb24gdXNlIFwiY29va2llc1wiIG91dHNpZGUgb2YgdGhlIGNhY2hlZCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgcmVxdWlyZWQgZHluYW1pYyBkYXRhIGluIGFzIGFuIGFyZ3VtZW50LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtcmVxdWVzdC1pbi11c2UtY2FjaGVgXG4gICAgICAgICAgKVxuICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjb29raWVzKVxuICAgICAgICAgIHdvcmtTdG9yZS5pbnZhbGlkRHluYW1pY1VzYWdlRXJyb3IgPz89IGVycm9yXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgY2FzZSAndW5zdGFibGUtY2FjaGUnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBSb3V0ZSAke3dvcmtTdG9yZS5yb3V0ZX0gdXNlZCBcImNvb2tpZXNcIiBpbnNpZGUgYSBmdW5jdGlvbiBjYWNoZWQgd2l0aCBcInVuc3RhYmxlX2NhY2hlKC4uLilcIi4gQWNjZXNzaW5nIER5bmFtaWMgZGF0YSBzb3VyY2VzIGluc2lkZSBhIGNhY2hlIHNjb3BlIGlzIG5vdCBzdXBwb3J0ZWQuIElmIHlvdSBuZWVkIHRoaXMgZGF0YSBpbnNpZGUgYSBjYWNoZWQgZnVuY3Rpb24gdXNlIFwiY29va2llc1wiIG91dHNpZGUgb2YgdGhlIGNhY2hlZCBmdW5jdGlvbiBhbmQgcGFzcyB0aGUgcmVxdWlyZWQgZHluYW1pYyBkYXRhIGluIGFzIGFuIGFyZ3VtZW50LiBTZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy91bnN0YWJsZV9jYWNoZWBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlcic6XG4gICAgICAgICAgcmV0dXJuIG1ha2VIYW5naW5nQ29va2llcyh3b3JrU3RvcmUsIHdvcmtVbml0U3RvcmUpXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1jbGllbnQnOlxuICAgICAgICAgIGNvbnN0IGV4cG9ydE5hbWUgPSAnYGNvb2tpZXNgJ1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhcmlhbnRFcnJvcihcbiAgICAgICAgICAgIGAke2V4cG9ydE5hbWV9IG11c3Qgbm90IGJlIHVzZWQgd2l0aGluIGEgY2xpZW50IGNvbXBvbmVudC4gTmV4dC5qcyBzaG91bGQgYmUgcHJldmVudGluZyAke2V4cG9ydE5hbWV9IGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gY2xpZW50IGNvbXBvbmVudHMgc3RhdGljYWxseSwgYnV0IGRpZCBub3QgaW4gdGhpcyBjYXNlLmBcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1wcHInOlxuICAgICAgICAgIC8vIFdlIG5lZWQgdHJhY2sgZHluYW1pYyBhY2Nlc3MgaGVyZSBlYWdlcmx5IHRvIGtlZXAgY29udGludWl0eSB3aXRoXG4gICAgICAgICAgLy8gaG93IGNvb2tpZXMgaGFzIHdvcmtlZCBpbiBQUFIgd2l0aG91dCBjYWNoZUNvbXBvbmVudHMuXG4gICAgICAgICAgcmV0dXJuIHBvc3Rwb25lV2l0aFRyYWNraW5nKFxuICAgICAgICAgICAgd29ya1N0b3JlLnJvdXRlLFxuICAgICAgICAgICAgY2FsbGluZ0V4cHJlc3Npb24sXG4gICAgICAgICAgICB3b3JrVW5pdFN0b3JlLmR5bmFtaWNUcmFja2luZ1xuICAgICAgICAgIClcbiAgICAgICAgY2FzZSAncHJlcmVuZGVyLWxlZ2FjeSc6XG4gICAgICAgICAgLy8gV2UgdHJhY2sgZHluYW1pYyBhY2Nlc3MgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdyYXAgdGhlIGNvb2tpZXNcbiAgICAgICAgICAvLyBpbiBpbmRpdmlkdWFsIHByb3BlcnR5IGFjY2VzcyB0cmFja2luZy5cbiAgICAgICAgICByZXR1cm4gdGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24oXG4gICAgICAgICAgICBjYWxsaW5nRXhwcmVzc2lvbixcbiAgICAgICAgICAgIHdvcmtTdG9yZSxcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmVcbiAgICAgICAgICApXG4gICAgICAgIGNhc2UgJ3ByZXJlbmRlci1ydW50aW1lJzpcbiAgICAgICAgICByZXR1cm4gZGVsYXlVbnRpbFJ1bnRpbWVTdGFnZShcbiAgICAgICAgICAgIHdvcmtVbml0U3RvcmUsXG4gICAgICAgICAgICBtYWtlVW50cmFja2VkQ29va2llcyh3b3JrVW5pdFN0b3JlLmNvb2tpZXMpXG4gICAgICAgICAgKVxuICAgICAgICBjYXNlICdwcml2YXRlLWNhY2hlJzpcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NBQ0hFX0NPTVBPTkVOVFMpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkQ29va2llcyh3b3JrVW5pdFN0b3JlLmNvb2tpZXMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzKHdvcmtVbml0U3RvcmUuY29va2llcylcbiAgICAgICAgY2FzZSAncmVxdWVzdCc6XG4gICAgICAgICAgdHJhY2tEeW5hbWljRGF0YUluRHluYW1pY1JlbmRlcih3b3JrVW5pdFN0b3JlKVxuXG4gICAgICAgICAgbGV0IHVuZGVybHlpbmdDb29raWVzOiBSZWFkb25seVJlcXVlc3RDb29raWVzXG5cbiAgICAgICAgICBpZiAoYXJlQ29va2llc011dGFibGVJbkN1cnJlbnRQaGFzZSh3b3JrVW5pdFN0b3JlKSkge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgY29uZGl0aW9uYWxseSByZXR1cm4gZGlmZmVyZW50IHR5cGVzIGhlcmUgYmFzZWQgb24gdGhlIGNvbnRleHQuXG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBjb25mdXNpb24sIHdlIGFsd2F5cyByZXR1cm4gdGhlIHJlYWRvbmx5IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzID1cbiAgICAgICAgICAgICAgd29ya1VuaXRTdG9yZS51c2Vyc3BhY2VNdXRhYmxlQ29va2llcyBhcyB1bmtub3duIGFzIFJlYWRvbmx5UmVxdWVzdENvb2tpZXNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMgPSB3b3JrVW5pdFN0b3JlLmNvb2tpZXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIC8vIFNlbWFudGljYWxseSB3ZSBvbmx5IG5lZWQgdGhlIGRldiB0cmFja2luZyB3aGVuIHJ1bm5pbmcgaW4gYG5leHQgZGV2YFxuICAgICAgICAgICAgLy8gYnV0IHNpbmNlIHlvdSB3b3VsZCBuZXZlciB1c2UgbmV4dCBkZXYgd2l0aCBwcm9kdWN0aW9uIE5PREVfRU5WIHdlIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyBhcyBhIHByb3h5IHNvIHdlIGNhbiBzdGF0aWNhbGx5IGV4Y2x1ZGUgdGhpcyBjb2RlIGZyb20gcHJvZHVjdGlvbiBidWlsZHMuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NBQ0hFX0NPTVBPTkVOVFMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1ha2VVbnRyYWNrZWRDb29raWVzV2l0aERldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgICAgICAgICAgIHdvcmtTdG9yZT8ucm91dGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXNXaXRoRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgICAgICAgICB3b3JrU3RvcmU/LnJvdXRlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0FDSEVfQ09NUE9ORU5UUykge1xuICAgICAgICAgICAgICByZXR1cm4gbWFrZVVudHJhY2tlZENvb2tpZXModW5kZXJseWluZ0Nvb2tpZXMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYWtlVW50cmFja2VkRXhvdGljQ29va2llcyh1bmRlcmx5aW5nQ29va2llcylcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgd29ya1VuaXRTdG9yZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgdGhlcmUgd2FzIG5vIHdvcmsgc3RvcmUgb3Igd29yayB1bml0IHN0b3JlIHByZXNlbnQuXG4gIHRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZShjYWxsaW5nRXhwcmVzc2lvbilcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW1wdHlDb29raWVzKCk6IFJlYWRvbmx5UmVxdWVzdENvb2tpZXMge1xuICByZXR1cm4gUmVxdWVzdENvb2tpZXNBZGFwdGVyLnNlYWwobmV3IFJlcXVlc3RDb29raWVzKG5ldyBIZWFkZXJzKHt9KSkpXG59XG5cbmludGVyZmFjZSBDYWNoZUxpZmV0aW1lIHt9XG5jb25zdCBDYWNoZWRDb29raWVzID0gbmV3IFdlYWtNYXA8XG4gIENhY2hlTGlmZXRpbWUsXG4gIFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz5cbj4oKVxuXG5mdW5jdGlvbiBtYWtlSGFuZ2luZ0Nvb2tpZXMoXG4gIHdvcmtTdG9yZTogV29ya1N0b3JlLFxuICBwcmVyZW5kZXJTdG9yZTogUHJlcmVuZGVyU3RvcmVNb2Rlcm5cbik6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4ge1xuICBjb25zdCBjYWNoZWRQcm9taXNlID0gQ2FjaGVkQ29va2llcy5nZXQocHJlcmVuZGVyU3RvcmUpXG4gIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgcmV0dXJuIGNhY2hlZFByb21pc2VcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBtYWtlSGFuZ2luZ1Byb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4oXG4gICAgcHJlcmVuZGVyU3RvcmUucmVuZGVyU2lnbmFsLFxuICAgIHdvcmtTdG9yZS5yb3V0ZSxcbiAgICAnYGNvb2tpZXMoKWAnXG4gIClcbiAgQ2FjaGVkQ29va2llcy5zZXQocHJlcmVuZGVyU3RvcmUsIHByb21pc2UpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZENvb2tpZXMoXG4gIHVuZGVybHlpbmdDb29raWVzOiBSZWFkb25seVJlcXVlc3RDb29raWVzXG4pOiBQcm9taXNlPFJlYWRvbmx5UmVxdWVzdENvb2tpZXM+IHtcbiAgY29uc3QgY2FjaGVkQ29va2llcyA9IENhY2hlZENvb2tpZXMuZ2V0KHVuZGVybHlpbmdDb29raWVzKVxuICBpZiAoY2FjaGVkQ29va2llcykge1xuICAgIHJldHVybiBjYWNoZWRDb29raWVzXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVybHlpbmdDb29raWVzKVxuICBDYWNoZWRDb29raWVzLnNldCh1bmRlcmx5aW5nQ29va2llcywgcHJvbWlzZSlcblxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiBtYWtlVW50cmFja2VkRXhvdGljQ29va2llcyhcbiAgdW5kZXJseWluZ0Nvb2tpZXM6IFJlYWRvbmx5UmVxdWVzdENvb2tpZXNcbik6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4ge1xuICBjb25zdCBjYWNoZWRDb29raWVzID0gQ2FjaGVkQ29va2llcy5nZXQodW5kZXJseWluZ0Nvb2tpZXMpXG4gIGlmIChjYWNoZWRDb29raWVzKSB7XG4gICAgcmV0dXJuIGNhY2hlZENvb2tpZXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodW5kZXJseWluZ0Nvb2tpZXMpXG4gIENhY2hlZENvb2tpZXMuc2V0KHVuZGVybHlpbmdDb29raWVzLCBwcm9taXNlKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb21pc2UsIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXToge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzW1N5bWJvbC5pdGVyYXRvcl1cbiAgICAgICAgPyB1bmRlcmx5aW5nQ29va2llc1tTeW1ib2wuaXRlcmF0b3JdLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMpXG4gICAgICAgIDogLy8gVE9ETyB0aGlzIGlzIGEgcG9seWZpbGwgZm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgdHlwZSBpcyBSZXNwb25zZUNvb2tpZXNcbiAgICAgICAgICAvLyBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgYW5kIHVuaWZ5IG91ciBjb29raWVzIHR5cGVzLiBXZSBjb3VsZCBqdXN0IGxldCB0aGlzIGNvbnRpbnVlIHRvIHRocm93IGxhemlseVxuICAgICAgICAgIC8vIGJ1dCB0aGF0J3MgYWxyZWFkeSBhIGhhcmQgdGhpbmcgdG8gZGVidWcgc28gd2UgbWF5IGFzIHdlbGwgaW1wbGVtZW50IGl0IGNvbnNpc3RlbnRseS4gVGhlIGJpZ2dlc3QgcHJvYmxlbSB3aXRoXG4gICAgICAgICAgLy8gaW1wbGVtZW50aW5nIHRoaXMgaW4gdGhpcyB3YXkgaXMgdGhlIHVuZGVybHlpbmcgY29va2llIHR5cGUgaXMgYSBSZXNwb25zZUNvb2tpZSBhbmQgbm90IGEgUmVxdWVzdENvb2tpZSBhbmQgc28gaXRcbiAgICAgICAgICAvLyBoYXMgZXh0cmEgcHJvcGVydGllcyBub3QgYXZhaWxhYmxlIG9uIFJlcXVlc3RDb29raWUgaW5zdGFuY2VzLlxuICAgICAgICAgIHBvbHlmaWxsZWRSZXNwb25zZUNvb2tpZXNJdGVyYXRvci5iaW5kKHVuZGVybHlpbmdDb29raWVzKSxcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIGdldCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuc2l6ZVxuICAgICAgfSxcbiAgICB9LFxuICAgIGdldDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzLmdldC5iaW5kKHVuZGVybHlpbmdDb29raWVzKSxcbiAgICB9LFxuICAgIGdldEFsbDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzLmdldEFsbC5iaW5kKHVuZGVybHlpbmdDb29raWVzKSxcbiAgICB9LFxuICAgIGhhczoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzLmhhcy5iaW5kKHVuZGVybHlpbmdDb29raWVzKSxcbiAgICB9LFxuICAgIHNldDoge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzLnNldC5iaW5kKHVuZGVybHlpbmdDb29raWVzKSxcbiAgICB9LFxuICAgIGRlbGV0ZToge1xuICAgICAgdmFsdWU6IHVuZGVybHlpbmdDb29raWVzLmRlbGV0ZS5iaW5kKHVuZGVybHlpbmdDb29raWVzKSxcbiAgICB9LFxuICAgIGNsZWFyOiB7XG4gICAgICB2YWx1ZTpcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBjbGVhciBpcyBkZWZpbmVkIGluIFJlcXVlc3RDb29raWVzIGltcGxlbWVudGF0aW9uIGJ1dCBub3QgaW4gdGhlIHR5cGVcbiAgICAgICAgdHlwZW9mIHVuZGVybHlpbmdDb29raWVzLmNsZWFyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyAvLyBAdHMtZXhwZWN0LWVycm9yIGNsZWFyIGlzIGRlZmluZWQgaW4gUmVxdWVzdENvb2tpZXMgaW1wbGVtZW50YXRpb24gYnV0IG5vdCBpbiB0aGUgdHlwZVxuICAgICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMuY2xlYXIuYmluZCh1bmRlcmx5aW5nQ29va2llcylcbiAgICAgICAgICA6IC8vIFRPRE8gdGhpcyBpcyBhIHBvbHlmaWxsIGZvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHR5cGUgaXMgUmVzcG9uc2VDb29raWVzXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgcmVtb3ZlIHRoaXMgYW5kIHVuaWZ5IG91ciBjb29raWVzIHR5cGVzLiBXZSBjb3VsZCBqdXN0IGxldCB0aGlzIGNvbnRpbnVlIHRvIHRocm93IGxhemlseVxuICAgICAgICAgICAgLy8gYnV0IHRoYXQncyBhbHJlYWR5IGEgaGFyZCB0aGluZyB0byBkZWJ1ZyBzbyB3ZSBtYXkgYXMgd2VsbCBpbXBsZW1lbnQgaXQgY29uc2lzdGVudGx5LiBUaGUgYmlnZ2VzdCBwcm9ibGVtIHdpdGhcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGluZyB0aGlzIGluIHRoaXMgd2F5IGlzIHRoZSB1bmRlcmx5aW5nIGNvb2tpZSB0eXBlIGlzIGEgUmVzcG9uc2VDb29raWUgYW5kIG5vdCBhIFJlcXVlc3RDb29raWUgYW5kIHNvIGl0XG4gICAgICAgICAgICAvLyBoYXMgZXh0cmEgcHJvcGVydGllcyBub3QgYXZhaWxhYmxlIG9uIFJlcXVlc3RDb29raWUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0NsZWFyLmJpbmQodW5kZXJseWluZ0Nvb2tpZXMsIHByb21pc2UpLFxuICAgIH0sXG4gICAgdG9TdHJpbmc6IHtcbiAgICAgIHZhbHVlOiB1bmRlcmx5aW5nQ29va2llcy50b1N0cmluZy5iaW5kKHVuZGVybHlpbmdDb29raWVzKSxcbiAgICB9LFxuICB9IHNhdGlzZmllcyBDb29raWVFeHRlbnNpb25zKVxuXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIG1ha2VVbnRyYWNrZWRFeG90aWNDb29raWVzV2l0aERldldhcm5pbmdzKFxuICB1bmRlcmx5aW5nQ29va2llczogUmVhZG9ubHlSZXF1ZXN0Q29va2llcyxcbiAgcm91dGU/OiBzdHJpbmdcbik6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz4ge1xuICBjb25zdCBjYWNoZWRDb29raWVzID0gQ2FjaGVkQ29va2llcy5nZXQodW5kZXJseWluZ0Nvb2tpZXMpXG4gIGlmIChjYWNoZWRDb29raWVzKSB7XG4gICAgcmV0dXJuIGNhY2hlZENvb2tpZXNcbiAgfVxuXG4gIGNvbnN0IHByb21pc2UgPSBtYWtlRGV2dG9vbHNJT0F3YXJlUHJvbWlzZSh1bmRlcmx5aW5nQ29va2llcylcbiAgQ2FjaGVkQ29va2llcy5zZXQodW5kZXJseWluZ0Nvb2tpZXMsIHByb21pc2UpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvbWlzZSwge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2AuLi5jb29raWVzKClgIG9yIHNpbWlsYXIgaXRlcmF0aW9uJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llc1tTeW1ib2wuaXRlcmF0b3JdXG4gICAgICAgICAgPyB1bmRlcmx5aW5nQ29va2llc1tTeW1ib2wuaXRlcmF0b3JdLmFwcGx5KFxuICAgICAgICAgICAgICB1bmRlcmx5aW5nQ29va2llcyxcbiAgICAgICAgICAgICAgYXJndW1lbnRzIGFzIGFueVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogLy8gVE9ETyB0aGlzIGlzIGEgcG9seWZpbGwgZm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgdHlwZSBpcyBSZXNwb25zZUNvb2tpZXNcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCByZW1vdmUgdGhpcyBhbmQgdW5pZnkgb3VyIGNvb2tpZXMgdHlwZXMuIFdlIGNvdWxkIGp1c3QgbGV0IHRoaXMgY29udGludWUgdG8gdGhyb3cgbGF6aWx5XG4gICAgICAgICAgICAvLyBidXQgdGhhdCdzIGFscmVhZHkgYSBoYXJkIHRoaW5nIHRvIGRlYnVnIHNvIHdlIG1heSBhcyB3ZWxsIGltcGxlbWVudCBpdCBjb25zaXN0ZW50bHkuIFRoZSBiaWdnZXN0IHByb2JsZW0gd2l0aFxuICAgICAgICAgICAgLy8gaW1wbGVtZW50aW5nIHRoaXMgaW4gdGhpcyB3YXkgaXMgdGhlIHVuZGVybHlpbmcgY29va2llIHR5cGUgaXMgYSBSZXNwb25zZUNvb2tpZSBhbmQgbm90IGEgUmVxdWVzdENvb2tpZSBhbmQgc28gaXRcbiAgICAgICAgICAgIC8vIGhhcyBleHRyYSBwcm9wZXJ0aWVzIG5vdCBhdmFpbGFibGUgb24gUmVxdWVzdENvb2tpZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICBwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzSXRlcmF0b3IuY2FsbCh1bmRlcmx5aW5nQ29va2llcylcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBnZXQoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLnNpemVgJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5zaXplXG4gICAgICB9LFxuICAgIH0sXG4gICAgZ2V0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBsZXQgZXhwcmVzc2lvbjogc3RyaW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLmdldCgpYCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gYFxcYGNvb2tpZXMoKS5nZXQoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0pXFxgYFxuICAgICAgICB9XG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdDb29raWVzLmdldC5hcHBseSh1bmRlcmx5aW5nQ29va2llcywgYXJndW1lbnRzIGFzIGFueSlcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBnZXRBbGw6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGwoKSB7XG4gICAgICAgIGxldCBleHByZXNzaW9uOiBzdHJpbmdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gJ2Bjb29raWVzKCkuZ2V0QWxsKClgJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBgXFxgY29va2llcygpLmdldEFsbCgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSlcXGBgXG4gICAgICAgIH1cbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMuZ2V0QWxsLmFwcGx5KFxuICAgICAgICAgIHVuZGVybHlpbmdDb29raWVzLFxuICAgICAgICAgIGFyZ3VtZW50cyBhcyBhbnlcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGhhczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgbGV0IGV4cHJlc3Npb246IHN0cmluZ1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5oYXMoKWAnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGBcXGBjb29raWVzKCkuaGFzKCR7ZGVzY3JpYmVOYW1lQXJnKGFyZ3VtZW50c1swXSl9KVxcYGBcbiAgICAgICAgfVxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5oYXMuYXBwbHkodW5kZXJseWluZ0Nvb2tpZXMsIGFyZ3VtZW50cyBhcyBhbnkpXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgc2V0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICBsZXQgZXhwcmVzc2lvbjogc3RyaW5nXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLnNldCgpYCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBhcmd1bWVudHNbMF1cbiAgICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gYFxcYGNvb2tpZXMoKS5zZXQoJHtkZXNjcmliZU5hbWVBcmcoYXJnKX0sIC4uLilcXGBgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSAnYGNvb2tpZXMoKS5zZXQoLi4uKWAnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN5bmNJT0Rldihyb3V0ZSwgZXhwcmVzc2lvbilcbiAgICAgICAgcmV0dXJuIHVuZGVybHlpbmdDb29raWVzLnNldC5hcHBseSh1bmRlcmx5aW5nQ29va2llcywgYXJndW1lbnRzIGFzIGFueSlcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBkZWxldGU6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBleHByZXNzaW9uOiBzdHJpbmdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gJ2Bjb29raWVzKCkuZGVsZXRlKClgJ1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBleHByZXNzaW9uID0gYFxcYGNvb2tpZXMoKS5kZWxldGUoJHtkZXNjcmliZU5hbWVBcmcoYXJndW1lbnRzWzBdKX0pXFxgYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHJlc3Npb24gPSBgXFxgY29va2llcygpLmRlbGV0ZSgke2Rlc2NyaWJlTmFtZUFyZyhhcmd1bWVudHNbMF0pfSwgLi4uKVxcYGBcbiAgICAgICAgfVxuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIHJldHVybiB1bmRlcmx5aW5nQ29va2llcy5kZWxldGUuYXBwbHkoXG4gICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMsXG4gICAgICAgICAgYXJndW1lbnRzIGFzIGFueVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgY2xlYXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICdgY29va2llcygpLmNsZWFyKClgJ1xuICAgICAgICBzeW5jSU9EZXYocm91dGUsIGV4cHJlc3Npb24pXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgY2xlYXIgaXMgZGVmaW5lZCBpbiBSZXF1ZXN0Q29va2llcyBpbXBsZW1lbnRhdGlvbiBidXQgbm90IGluIHRoZSB0eXBlXG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5kZXJseWluZ0Nvb2tpZXMuY2xlYXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IC8vIEB0cy1pZ25vcmUgY2xlYXIgaXMgZGVmaW5lZCBpbiBSZXF1ZXN0Q29va2llcyBpbXBsZW1lbnRhdGlvbiBidXQgbm90IGluIHRoZSB0eXBlXG4gICAgICAgICAgICB1bmRlcmx5aW5nQ29va2llcy5jbGVhci5hcHBseSh1bmRlcmx5aW5nQ29va2llcywgYXJndW1lbnRzKVxuICAgICAgICAgIDogLy8gVE9ETyB0aGlzIGlzIGEgcG9seWZpbGwgZm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgdHlwZSBpcyBSZXNwb25zZUNvb2tpZXNcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCByZW1vdmUgdGhpcyBhbmQgdW5pZnkgb3VyIGNvb2tpZXMgdHlwZXMuIFdlIGNvdWxkIGp1c3QgbGV0IHRoaXMgY29udGludWUgdG8gdGhyb3cgbGF6aWx5XG4gICAgICAgICAgICAvLyBidXQgdGhhdCdzIGFscmVhZHkgYSBoYXJkIHRoaW5nIHRvIGRlYnVnIHNvIHdlIG1heSBhcyB3ZWxsIGltcGxlbWVudCBpdCBjb25zaXN0ZW50bHkuIFRoZSBiaWdnZXN0IHByb2JsZW0gd2l0aFxuICAgICAgICAgICAgLy8gaW1wbGVtZW50aW5nIHRoaXMgaW4gdGhpcyB3YXkgaXMgdGhlIHVuZGVybHlpbmcgY29va2llIHR5cGUgaXMgYSBSZXNwb25zZUNvb2tpZSBhbmQgbm90IGEgUmVxdWVzdENvb2tpZSBhbmQgc28gaXRcbiAgICAgICAgICAgIC8vIGhhcyBleHRyYSBwcm9wZXJ0aWVzIG5vdCBhdmFpbGFibGUgb24gUmVxdWVzdENvb2tpZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICBwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzQ2xlYXIuY2FsbCh1bmRlcmx5aW5nQ29va2llcywgcHJvbWlzZSlcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICB0b1N0cmluZzoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gJ2Bjb29raWVzKCkudG9TdHJpbmcoKWAgb3IgaW1wbGljaXQgY2FzdGluZydcbiAgICAgICAgc3luY0lPRGV2KHJvdXRlLCBleHByZXNzaW9uKVxuICAgICAgICByZXR1cm4gdW5kZXJseWluZ0Nvb2tpZXMudG9TdHJpbmcuYXBwbHkoXG4gICAgICAgICAgdW5kZXJseWluZ0Nvb2tpZXMsXG4gICAgICAgICAgYXJndW1lbnRzIGFzIGFueVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0sXG4gIH0gc2F0aXNmaWVzIENvb2tpZUV4dGVuc2lvbnMpXG5cbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuLy8gU2ltaWxhciB0byBgbWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXNXaXRoRGV2V2FybmluZ3NgLCBidXQganVzdCBsb2dnaW5nIHRoZVxuLy8gc3luYyBhY2Nlc3Mgd2l0aG91dCBhY3R1YWxseSBkZWZpbmluZyB0aGUgY29va2llcyBwcm9wZXJ0aWVzIG9uIHRoZSBwcm9taXNlLlxuZnVuY3Rpb24gbWFrZVVudHJhY2tlZENvb2tpZXNXaXRoRGV2V2FybmluZ3MoXG4gIHVuZGVybHlpbmdDb29raWVzOiBSZWFkb25seVJlcXVlc3RDb29raWVzLFxuICByb3V0ZT86IHN0cmluZ1xuKTogUHJvbWlzZTxSZWFkb25seVJlcXVlc3RDb29raWVzPiB7XG4gIGNvbnN0IGNhY2hlZENvb2tpZXMgPSBDYWNoZWRDb29raWVzLmdldCh1bmRlcmx5aW5nQ29va2llcylcbiAgaWYgKGNhY2hlZENvb2tpZXMpIHtcbiAgICByZXR1cm4gY2FjaGVkQ29va2llc1xuICB9XG5cbiAgY29uc3QgcHJvbWlzZSA9IG1ha2VEZXZ0b29sc0lPQXdhcmVQcm9taXNlKHVuZGVybHlpbmdDb29raWVzKVxuXG4gIGNvbnN0IHByb3hpZWRQcm9taXNlID0gbmV3IFByb3h5KHByb21pc2UsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgU3ltYm9sLml0ZXJhdG9yOiB7XG4gICAgICAgICAgd2FybkZvclN5bmNBY2Nlc3Mocm91dGUsICdgLi4uY29va2llcygpYCBvciBzaW1pbGFyIGl0ZXJhdGlvbicpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgY2FzZSAnZ2V0QWxsJzpcbiAgICAgICAgY2FzZSAnaGFzJzpcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgY2FzZSAnY2xlYXInOlxuICAgICAgICBjYXNlICd0b1N0cmluZyc6IHtcbiAgICAgICAgICB3YXJuRm9yU3luY0FjY2Vzcyhyb3V0ZSwgYFxcYGNvb2tpZXMoKS4ke3Byb3B9XFxgYClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhcm4gZm9yIHdlbGwtZGVmaW5lZCBwcm9wZXJ0aWVzIG9mIHRoZSBjb29raWVzIG9iamVjdC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVmbGVjdEFkYXB0ZXIuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpXG4gICAgfSxcbiAgfSlcblxuICBDYWNoZWRDb29raWVzLnNldCh1bmRlcmx5aW5nQ29va2llcywgcHJveGllZFByb21pc2UpXG5cbiAgcmV0dXJuIHByb3hpZWRQcm9taXNlXG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmFtZUFyZyhhcmc6IHVua25vd24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmXG4gICAgYXJnICE9PSBudWxsICYmXG4gICAgdHlwZW9mIChhcmcgYXMgYW55KS5uYW1lID09PSAnc3RyaW5nJ1xuICAgID8gYCckeyhhcmcgYXMgYW55KS5uYW1lfSdgXG4gICAgOiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJ1xuICAgICAgPyBgJyR7YXJnfSdgXG4gICAgICA6ICcuLi4nXG59XG5cbmZ1bmN0aW9uIHN5bmNJT0Rldihyb3V0ZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBleHByZXNzaW9uOiBzdHJpbmcpIHtcbiAgY29uc3Qgd29ya1VuaXRTdG9yZSA9IHdvcmtVbml0QXN5bmNTdG9yYWdlLmdldFN0b3JlKClcblxuICBpZiAod29ya1VuaXRTdG9yZSkge1xuICAgIHN3aXRjaCAod29ya1VuaXRTdG9yZS50eXBlKSB7XG4gICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgaWYgKHdvcmtVbml0U3RvcmUucHJlcmVuZGVyUGhhc2UgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBXaGVuIHdlJ3JlIHJlbmRlcmluZyBkeW5hbWljYWxseSBpbiBkZXYsIHdlIG5lZWQgdG8gYWR2YW5jZSBvdXQgb2ZcbiAgICAgICAgICAvLyB0aGUgUHJlcmVuZGVyIGVudmlyb25tZW50IHdoZW4gd2UgcmVhZCBSZXF1ZXN0IGRhdGEgc3luY2hyb25vdXNseS5cbiAgICAgICAgICB0cmFja1N5bmNocm9ub3VzUmVxdWVzdERhdGFBY2Nlc3NJbkRldih3b3JrVW5pdFN0b3JlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVyZW5kZXInOlxuICAgICAgY2FzZSAncHJlcmVuZGVyLWNsaWVudCc6XG4gICAgICBjYXNlICdwcmVyZW5kZXItcnVudGltZSc6XG4gICAgICBjYXNlICdwcmVyZW5kZXItcHByJzpcbiAgICAgIGNhc2UgJ3ByZXJlbmRlci1sZWdhY3knOlxuICAgICAgY2FzZSAnY2FjaGUnOlxuICAgICAgY2FzZSAncHJpdmF0ZS1jYWNoZSc6XG4gICAgICBjYXNlICd1bnN0YWJsZS1jYWNoZSc6XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3b3JrVW5pdFN0b3JlIHNhdGlzZmllcyBuZXZlclxuICAgIH1cbiAgfVxuXG4gIC8vIEluIGFsbCBjYXNlcyB3ZSB3YXJuIG5vcm1hbGx5XG4gIHdhcm5Gb3JTeW5jQWNjZXNzKHJvdXRlLCBleHByZXNzaW9uKVxufVxuXG5jb25zdCB3YXJuRm9yU3luY0FjY2VzcyA9IGNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYoXG4gIGNyZWF0ZUNvb2tpZXNBY2Nlc3NFcnJvclxuKVxuXG5mdW5jdGlvbiBjcmVhdGVDb29raWVzQWNjZXNzRXJyb3IoXG4gIHJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGV4cHJlc3Npb246IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHByZWZpeCA9IHJvdXRlID8gYFJvdXRlIFwiJHtyb3V0ZX1cIiBgIDogJ1RoaXMgcm91dGUgJ1xuICByZXR1cm4gbmV3IEVycm9yKFxuICAgIGAke3ByZWZpeH11c2VkICR7ZXhwcmVzc2lvbn0uIGAgK1xuICAgICAgYFxcYGNvb2tpZXMoKVxcYCBzaG91bGQgYmUgYXdhaXRlZCBiZWZvcmUgdXNpbmcgaXRzIHZhbHVlLiBgICtcbiAgICAgIGBMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9zeW5jLWR5bmFtaWMtYXBpc2BcbiAgKVxufVxuXG5mdW5jdGlvbiBwb2x5ZmlsbGVkUmVzcG9uc2VDb29raWVzSXRlcmF0b3IoXG4gIHRoaXM6IFJlc3BvbnNlQ29va2llc1xuKTogUmV0dXJuVHlwZTxSZWFkb25seVJlcXVlc3RDb29raWVzW3R5cGVvZiBTeW1ib2wuaXRlcmF0b3JdPiB7XG4gIHJldHVybiB0aGlzLmdldEFsbCgpXG4gICAgLm1hcCgoYykgPT4gW2MubmFtZSwgY10gYXMgW3N0cmluZywgYW55XSlcbiAgICAudmFsdWVzKClcbn1cblxuZnVuY3Rpb24gcG9seWZpbGxlZFJlc3BvbnNlQ29va2llc0NsZWFyKFxuICB0aGlzOiBSZXNwb25zZUNvb2tpZXMsXG4gIHJldHVybmFibGU6IFByb21pc2U8UmVhZG9ubHlSZXF1ZXN0Q29va2llcz5cbik6IHR5cGVvZiByZXR1cm5hYmxlIHtcbiAgZm9yIChjb25zdCBjb29raWUgb2YgdGhpcy5nZXRBbGwoKSkge1xuICAgIHRoaXMuZGVsZXRlKGNvb2tpZS5uYW1lKVxuICB9XG4gIHJldHVybiByZXR1cm5hYmxlXG59XG5cbnR5cGUgQ29va2llRXh0ZW5zaW9ucyA9IHtcbiAgW0sgaW4ga2V5b2YgUmVhZG9ubHlSZXF1ZXN0Q29va2llcyB8ICdjbGVhciddOiB1bmtub3duXG59XG4iXSwibmFtZXMiOlsiYXJlQ29va2llc011dGFibGVJbkN1cnJlbnRQaGFzZSIsIlJlcXVlc3RDb29raWVzQWRhcHRlciIsIlJlcXVlc3RDb29raWVzIiwid29ya0FzeW5jU3RvcmFnZSIsInRocm93Rm9yTWlzc2luZ1JlcXVlc3RTdG9yZSIsIndvcmtVbml0QXN5bmNTdG9yYWdlIiwiZGVsYXlVbnRpbFJ1bnRpbWVTdGFnZSIsInBvc3Rwb25lV2l0aFRyYWNraW5nIiwidGhyb3dUb0ludGVycnVwdFN0YXRpY0dlbmVyYXRpb24iLCJ0cmFja0R5bmFtaWNEYXRhSW5EeW5hbWljUmVuZGVyIiwidHJhY2tTeW5jaHJvbm91c1JlcXVlc3REYXRhQWNjZXNzSW5EZXYiLCJTdGF0aWNHZW5CYWlsb3V0RXJyb3IiLCJtYWtlRGV2dG9vbHNJT0F3YXJlUHJvbWlzZSIsIm1ha2VIYW5naW5nUHJvbWlzZSIsImNyZWF0ZURlZHVwZWRCeUNhbGxzaXRlU2VydmVyRXJyb3JMb2dnZXJEZXYiLCJpc1JlcXVlc3RBUElDYWxsYWJsZUluc2lkZUFmdGVyIiwiSW52YXJpYW50RXJyb3IiLCJSZWZsZWN0QWRhcHRlciIsImNvb2tpZXMiLCJjYWxsaW5nRXhwcmVzc2lvbiIsIndvcmtTdG9yZSIsImdldFN0b3JlIiwid29ya1VuaXRTdG9yZSIsInBoYXNlIiwiRXJyb3IiLCJyb3V0ZSIsImZvcmNlU3RhdGljIiwidW5kZXJseWluZ0Nvb2tpZXMiLCJjcmVhdGVFbXB0eUNvb2tpZXMiLCJtYWtlVW50cmFja2VkRXhvdGljQ29va2llcyIsImR5bmFtaWNTaG91bGRFcnJvciIsInR5cGUiLCJlcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiaW52YWxpZER5bmFtaWNVc2FnZUVycm9yIiwibWFrZUhhbmdpbmdDb29raWVzIiwiZXhwb3J0TmFtZSIsImR5bmFtaWNUcmFja2luZyIsIm1ha2VVbnRyYWNrZWRDb29raWVzIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DQUNIRV9DT01QT05FTlRTIiwidXNlcnNwYWNlTXV0YWJsZUNvb2tpZXMiLCJOT0RFX0VOViIsIm1ha2VVbnRyYWNrZWRDb29raWVzV2l0aERldldhcm5pbmdzIiwibWFrZVVudHJhY2tlZEV4b3RpY0Nvb2tpZXNXaXRoRGV2V2FybmluZ3MiLCJzZWFsIiwiSGVhZGVycyIsIkNhY2hlZENvb2tpZXMiLCJXZWFrTWFwIiwicHJlcmVuZGVyU3RvcmUiLCJjYWNoZWRQcm9taXNlIiwiZ2V0IiwicHJvbWlzZSIsInJlbmRlclNpZ25hbCIsInNldCIsImNhY2hlZENvb2tpZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJTeW1ib2wiLCJpdGVyYXRvciIsInZhbHVlIiwiYmluZCIsInBvbHlmaWxsZWRSZXNwb25zZUNvb2tpZXNJdGVyYXRvciIsInNpemUiLCJnZXRBbGwiLCJoYXMiLCJkZWxldGUiLCJjbGVhciIsInBvbHlmaWxsZWRSZXNwb25zZUNvb2tpZXNDbGVhciIsInRvU3RyaW5nIiwiZXhwcmVzc2lvbiIsInN5bmNJT0RldiIsImFwcGx5IiwiYXJndW1lbnRzIiwiY2FsbCIsIndyaXRhYmxlIiwibGVuZ3RoIiwiZGVzY3JpYmVOYW1lQXJnIiwiYXJnIiwicHJveGllZFByb21pc2UiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIndhcm5Gb3JTeW5jQWNjZXNzIiwibmFtZSIsInByZXJlbmRlclBoYXNlIiwiY3JlYXRlQ29va2llc0FjY2Vzc0Vycm9yIiwicHJlZml4IiwibWFwIiwiYyIsInZhbHVlcyIsInJldHVybmFibGUiLCJjb29raWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6005\n");

/***/ }),

/***/ 8566:
/*!*************************!*\
  !*** ./lib/auth/jwt.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JWTAuthService: () => (/* binding */ JWTAuthService),\n/* harmony export */   jwtAuth: () => (/* binding */ jwtAuth)\n/* harmony export */ });\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsonwebtoken */ 961);\n/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ 619);\n/**\n * JWT Authentication Service\n * Handles token generation, validation, and refresh\n */ \n\nclass JWTAuthService {\n    constructor(){\n        this.accessTokenSecret = process.env.JWT_ACCESS_SECRET || 'your-access-secret-key';\n        this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET || 'your-refresh-secret-key';\n        this.accessTokenExpiry = process.env.JWT_ACCESS_EXPIRY || '15m';\n        this.refreshTokenExpiry = process.env.JWT_REFRESH_EXPIRY || '7d';\n    }\n    static getInstance() {\n        if (!JWTAuthService.instance) {\n            JWTAuthService.instance = new JWTAuthService();\n        }\n        return JWTAuthService.instance;\n    }\n    /**\n   * Generate access and refresh tokens\n   */ generateTokens(payload) {\n        const accessToken = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(payload, this.accessTokenSecret, {\n            expiresIn: this.accessTokenExpiry,\n            issuer: 'shikshanam.com',\n            audience: 'shikshanam-users'\n        });\n        const refreshToken = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign({\n            userId: payload.userId,\n            type: 'refresh'\n        }, this.refreshTokenSecret, {\n            expiresIn: this.refreshTokenExpiry,\n            issuer: 'shikshanam.com',\n            audience: 'shikshanam-users'\n        });\n        return {\n            accessToken,\n            refreshToken\n        };\n    }\n    /**\n   * Verify access token\n   */ verifyAccessToken(token) {\n        try {\n            const decoded = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().verify(token, this.accessTokenSecret, {\n                issuer: 'shikshanam.com',\n                audience: 'shikshanam-users'\n            });\n            return decoded;\n        } catch (error) {\n            console.error('Access token verification failed:', error);\n            return null;\n        }\n    }\n    /**\n   * Verify refresh token\n   */ verifyRefreshToken(token) {\n        try {\n            const decoded = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().verify(token, this.refreshTokenSecret, {\n                issuer: 'shikshanam.com',\n                audience: 'shikshanam-users'\n            });\n            if (decoded.type !== 'refresh') {\n                throw new Error('Invalid token type');\n            }\n            return {\n                userId: decoded.userId\n            };\n        } catch (error) {\n            console.error('Refresh token verification failed:', error);\n            return null;\n        }\n    }\n    /**\n   * Extract token from request\n   */ extractTokenFromRequest(request) {\n        // Check Authorization header\n        const authHeader = request.headers.get('authorization');\n        if (authHeader?.startsWith('Bearer ')) {\n            return authHeader.substring(7);\n        }\n        // Check cookies\n        const tokenCookie = request.cookies.get('access_token')?.value;\n        if (tokenCookie) {\n            return tokenCookie;\n        }\n        return null;\n    }\n    /**\n   * Set secure cookies for tokens\n   */ async setTokenCookies(accessToken, refreshToken) {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n        // Set access token cookie (short-lived)\n        cookieStore.set('access_token', accessToken, {\n            httpOnly: true,\n            secure: \"development\" === 'production',\n            sameSite: 'strict',\n            maxAge: 15 * 60,\n            path: '/'\n        });\n        // Set refresh token cookie (long-lived)\n        cookieStore.set('refresh_token', refreshToken, {\n            httpOnly: true,\n            secure: \"development\" === 'production',\n            sameSite: 'strict',\n            maxAge: 7 * 24 * 60 * 60,\n            path: '/'\n        });\n    }\n    /**\n   * Clear token cookies\n   */ async clearTokenCookies() {\n        const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n        cookieStore.delete('access_token');\n        cookieStore.delete('refresh_token');\n    }\n    /**\n   * Get user from request\n   */ async getUserFromRequest(request) {\n        const token = this.extractTokenFromRequest(request);\n        if (!token) {\n            return null;\n        }\n        return this.verifyAccessToken(token);\n    }\n    /**\n   * Refresh access token using refresh token\n   */ async refreshAccessToken(refreshToken, userData) {\n        const decoded = this.verifyRefreshToken(refreshToken);\n        if (!decoded) {\n            return null;\n        }\n        // Generate new access token\n        const newAccessToken = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().sign(userData, this.accessTokenSecret, {\n            expiresIn: this.accessTokenExpiry,\n            issuer: 'shikshanam.com',\n            audience: 'shikshanam-users'\n        });\n        return newAccessToken;\n    }\n}\n// Export singleton instance\nconst jwtAuth = JWTAuthService.getInstance();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNiQyxNQUFNO1FBQ1I7UUFFQSx3Q0FBd0M7UUFDeENOLFlBQVlDLEdBQUcsQ0FBQyxpQkFBaUJ0QixjQUFjO1lBQzdDdUIsVUFBVTtZQUNWQyxRQUFRMUMsa0JBQXlCO1lBQ2pDMkMsVUFBVTtZQUNWQyxRQUFRLElBQUksS0FBSyxLQUFLO1lBQ3RCQyxNQUFNO1FBQ1I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTUMsb0JBQW1DO1FBQ3ZDLE1BQU1QLGNBQWMsTUFBTTFDLHFEQUFPQTtRQUVqQzBDLFlBQVlRLE1BQU0sQ0FBQztRQUNuQlIsWUFBWVEsTUFBTSxDQUFDO0lBQ3JCO0lBRUE7O0dBRUMsR0FDRCxNQUFNQyxtQkFBbUJsQixPQUFvQixFQUE4QjtRQUN6RSxNQUFNUixRQUFRLElBQUksQ0FBQ08sdUJBQXVCLENBQUNDO1FBQzNDLElBQUksQ0FBQ1IsT0FBTztZQUNWLE9BQU87UUFDVDtRQUVBLE9BQU8sSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQ0M7SUFDaEM7SUFFQTs7R0FFQyxHQUNELE1BQU0yQixtQkFBbUIvQixZQUFvQixFQUFFZ0MsUUFBeUMsRUFBMEI7UUFDaEgsTUFBTTNCLFVBQVUsSUFBSSxDQUFDSSxrQkFBa0IsQ0FBQ1Q7UUFDeEMsSUFBSSxDQUFDSyxTQUFTO1lBQ1osT0FBTztRQUNUO1FBRUUsNEJBQTRCO1FBQzVCLE1BQU00QixpQkFBaUJ2RCx3REFBUSxDQUFDc0QsVUFBVSxJQUFJLENBQUNuRCxpQkFBaUIsRUFBRTtZQUNoRWdCLFdBQVcsSUFBSSxDQUFDVixpQkFBaUI7WUFDakNXLFFBQVE7WUFDUkMsVUFBVTtRQUNaO1FBRUYsT0FBT2tDO0lBQ1Q7QUFDRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNQyxVQUFVdEQsZUFBZVcsV0FBVyxHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvYW1hbmJob2dhbC9EZXNrdG9wL3NoaWtzaGEvc2hpa3NoYW5hbV9uZXcvbGliL2F1dGgvand0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSldUIEF1dGhlbnRpY2F0aW9uIFNlcnZpY2VcbiAqIEhhbmRsZXMgdG9rZW4gZ2VuZXJhdGlvbiwgdmFsaWRhdGlvbiwgYW5kIHJlZnJlc2hcbiAqL1xuXG5pbXBvcnQgand0IGZyb20gJ2pzb253ZWJ0b2tlbic7XG5pbXBvcnQgeyBjb29raWVzIH0gZnJvbSAnbmV4dC9oZWFkZXJzJztcbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIEpXVFBheWxvYWQge1xuICB1c2VySWQ6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcm9sZTogc3RyaW5nO1xuICBpYXQ/OiBudW1iZXI7XG4gIGV4cD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb2tlblBhaXIge1xuICBhY2Nlc3NUb2tlbjogc3RyaW5nO1xuICByZWZyZXNoVG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEpXVEF1dGhTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEpXVEF1dGhTZXJ2aWNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGFjY2Vzc1Rva2VuU2VjcmV0OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVmcmVzaFRva2VuU2VjcmV0OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWNjZXNzVG9rZW5FeHBpcnk6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSByZWZyZXNoVG9rZW5FeHBpcnk6IHN0cmluZztcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYWNjZXNzVG9rZW5TZWNyZXQgPSBwcm9jZXNzLmVudi5KV1RfQUNDRVNTX1NFQ1JFVCB8fCAneW91ci1hY2Nlc3Mtc2VjcmV0LWtleSc7XG4gICAgdGhpcy5yZWZyZXNoVG9rZW5TZWNyZXQgPSBwcm9jZXNzLmVudi5KV1RfUkVGUkVTSF9TRUNSRVQgfHwgJ3lvdXItcmVmcmVzaC1zZWNyZXQta2V5JztcbiAgICB0aGlzLmFjY2Vzc1Rva2VuRXhwaXJ5ID0gcHJvY2Vzcy5lbnYuSldUX0FDQ0VTU19FWFBJUlkgfHwgJzE1bSc7XG4gICAgdGhpcy5yZWZyZXNoVG9rZW5FeHBpcnkgPSBwcm9jZXNzLmVudi5KV1RfUkVGUkVTSF9FWFBJUlkgfHwgJzdkJztcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBKV1RBdXRoU2VydmljZSB7XG4gICAgaWYgKCFKV1RBdXRoU2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgSldUQXV0aFNlcnZpY2UuaW5zdGFuY2UgPSBuZXcgSldUQXV0aFNlcnZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIEpXVEF1dGhTZXJ2aWNlLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFjY2VzcyBhbmQgcmVmcmVzaCB0b2tlbnNcbiAgICovXG4gIGdlbmVyYXRlVG9rZW5zKHBheWxvYWQ6IE9taXQ8SldUUGF5bG9hZCwgJ2lhdCcgfCAnZXhwJz4pOiBUb2tlblBhaXIge1xuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gand0LnNpZ24ocGF5bG9hZCwgdGhpcy5hY2Nlc3NUb2tlblNlY3JldCwge1xuICAgICAgZXhwaXJlc0luOiB0aGlzLmFjY2Vzc1Rva2VuRXhwaXJ5LFxuICAgICAgaXNzdWVyOiAnc2hpa3NoYW5hbS5jb20nLFxuICAgICAgYXVkaWVuY2U6ICdzaGlrc2hhbmFtLXVzZXJzJyxcbiAgICB9IGFzIGp3dC5TaWduT3B0aW9ucyk7XG5cbiAgICBjb25zdCByZWZyZXNoVG9rZW4gPSBqd3Quc2lnbihcbiAgICAgIHsgdXNlcklkOiBwYXlsb2FkLnVzZXJJZCwgdHlwZTogJ3JlZnJlc2gnIH0sXG4gICAgICB0aGlzLnJlZnJlc2hUb2tlblNlY3JldCxcbiAgICAgIHtcbiAgICAgICAgZXhwaXJlc0luOiB0aGlzLnJlZnJlc2hUb2tlbkV4cGlyeSxcbiAgICAgICAgaXNzdWVyOiAnc2hpa3NoYW5hbS5jb20nLFxuICAgICAgICBhdWRpZW5jZTogJ3NoaWtzaGFuYW0tdXNlcnMnLFxuICAgICAgfSBhcyBqd3QuU2lnbk9wdGlvbnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhY2Nlc3MgdG9rZW5cbiAgICovXG4gIHZlcmlmeUFjY2Vzc1Rva2VuKHRva2VuOiBzdHJpbmcpOiBKV1RQYXlsb2FkIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBqd3QudmVyaWZ5KHRva2VuLCB0aGlzLmFjY2Vzc1Rva2VuU2VjcmV0LCB7XG4gICAgICAgIGlzc3VlcjogJ3NoaWtzaGFuYW0uY29tJyxcbiAgICAgICAgYXVkaWVuY2U6ICdzaGlrc2hhbmFtLXVzZXJzJyxcbiAgICAgIH0pIGFzIEpXVFBheWxvYWQ7XG4gICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQWNjZXNzIHRva2VuIHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSByZWZyZXNoIHRva2VuXG4gICAqL1xuICB2ZXJpZnlSZWZyZXNoVG9rZW4odG9rZW46IHN0cmluZyk6IHsgdXNlcklkOiBzdHJpbmcgfSB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNvZGVkID0gand0LnZlcmlmeSh0b2tlbiwgdGhpcy5yZWZyZXNoVG9rZW5TZWNyZXQsIHtcbiAgICAgICAgaXNzdWVyOiAnc2hpa3NoYW5hbS5jb20nLFxuICAgICAgICBhdWRpZW5jZTogJ3NoaWtzaGFuYW0tdXNlcnMnLFxuICAgICAgfSkgYXMgYW55O1xuICAgICAgXG4gICAgICBpZiAoZGVjb2RlZC50eXBlICE9PSAncmVmcmVzaCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuIHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHsgdXNlcklkOiBkZWNvZGVkLnVzZXJJZCB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdSZWZyZXNoIHRva2VuIHZlcmlmaWNhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdG9rZW4gZnJvbSByZXF1ZXN0XG4gICAqL1xuICBleHRyYWN0VG9rZW5Gcm9tUmVxdWVzdChyZXF1ZXN0OiBOZXh0UmVxdWVzdCk6IHN0cmluZyB8IG51bGwge1xuICAgIC8vIENoZWNrIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoYXV0aEhlYWRlcj8uc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICByZXR1cm4gYXV0aEhlYWRlci5zdWJzdHJpbmcoNyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY29va2llc1xuICAgIGNvbnN0IHRva2VuQ29va2llID0gcmVxdWVzdC5jb29raWVzLmdldCgnYWNjZXNzX3Rva2VuJyk/LnZhbHVlO1xuICAgIGlmICh0b2tlbkNvb2tpZSkge1xuICAgICAgcmV0dXJuIHRva2VuQ29va2llO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBzZWN1cmUgY29va2llcyBmb3IgdG9rZW5zXG4gICAqL1xuICBhc3luYyBzZXRUb2tlbkNvb2tpZXMoYWNjZXNzVG9rZW46IHN0cmluZywgcmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb29raWVTdG9yZSA9IGF3YWl0IGNvb2tpZXMoKTtcbiAgICBcbiAgICAvLyBTZXQgYWNjZXNzIHRva2VuIGNvb2tpZSAoc2hvcnQtbGl2ZWQpXG4gICAgY29va2llU3RvcmUuc2V0KCdhY2Nlc3NfdG9rZW4nLCBhY2Nlc3NUb2tlbiwge1xuICAgICAgaHR0cE9ubHk6IHRydWUsXG4gICAgICBzZWN1cmU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicsXG4gICAgICBzYW1lU2l0ZTogJ3N0cmljdCcsXG4gICAgICBtYXhBZ2U6IDE1ICogNjAsIC8vIDE1IG1pbnV0ZXNcbiAgICAgIHBhdGg6ICcvJyxcbiAgICB9KTtcblxuICAgIC8vIFNldCByZWZyZXNoIHRva2VuIGNvb2tpZSAobG9uZy1saXZlZClcbiAgICBjb29raWVTdG9yZS5zZXQoJ3JlZnJlc2hfdG9rZW4nLCByZWZyZXNoVG9rZW4sIHtcbiAgICAgIGh0dHBPbmx5OiB0cnVlLFxuICAgICAgc2VjdXJlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgc2FtZVNpdGU6ICdzdHJpY3QnLFxuICAgICAgbWF4QWdlOiA3ICogMjQgKiA2MCAqIDYwLCAvLyA3IGRheXNcbiAgICAgIHBhdGg6ICcvJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0b2tlbiBjb29raWVzXG4gICAqL1xuICBhc3luYyBjbGVhclRva2VuQ29va2llcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb29raWVTdG9yZSA9IGF3YWl0IGNvb2tpZXMoKTtcbiAgICBcbiAgICBjb29raWVTdG9yZS5kZWxldGUoJ2FjY2Vzc190b2tlbicpO1xuICAgIGNvb2tpZVN0b3JlLmRlbGV0ZSgncmVmcmVzaF90b2tlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1c2VyIGZyb20gcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckZyb21SZXF1ZXN0KHJlcXVlc3Q6IE5leHRSZXF1ZXN0KTogUHJvbWlzZTxKV1RQYXlsb2FkIHwgbnVsbD4ge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5leHRyYWN0VG9rZW5Gcm9tUmVxdWVzdChyZXF1ZXN0KTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy52ZXJpZnlBY2Nlc3NUb2tlbih0b2tlbik7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCBhY2Nlc3MgdG9rZW4gdXNpbmcgcmVmcmVzaCB0b2tlblxuICAgKi9cbiAgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbjogc3RyaW5nLCB1c2VyRGF0YTogT21pdDxKV1RQYXlsb2FkLCAnaWF0JyB8ICdleHAnPik6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGNvbnN0IGRlY29kZWQgPSB0aGlzLnZlcmlmeVJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgIGlmICghZGVjb2RlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgICAvLyBHZW5lcmF0ZSBuZXcgYWNjZXNzIHRva2VuXG4gICAgICBjb25zdCBuZXdBY2Nlc3NUb2tlbiA9IGp3dC5zaWduKHVzZXJEYXRhLCB0aGlzLmFjY2Vzc1Rva2VuU2VjcmV0LCB7XG4gICAgICAgIGV4cGlyZXNJbjogdGhpcy5hY2Nlc3NUb2tlbkV4cGlyeSxcbiAgICAgICAgaXNzdWVyOiAnc2hpa3NoYW5hbS5jb20nLFxuICAgICAgICBhdWRpZW5jZTogJ3NoaWtzaGFuYW0tdXNlcnMnLFxuICAgICAgfSBhcyBqd3QuU2lnbk9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIG5ld0FjY2Vzc1Rva2VuO1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBqd3RBdXRoID0gSldUQXV0aFNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiJdLCJuYW1lcyI6WyJqd3QiLCJjb29raWVzIiwiSldUQXV0aFNlcnZpY2UiLCJhY2Nlc3NUb2tlblNlY3JldCIsInByb2Nlc3MiLCJlbnYiLCJKV1RfQUNDRVNTX1NFQ1JFVCIsInJlZnJlc2hUb2tlblNlY3JldCIsIkpXVF9SRUZSRVNIX1NFQ1JFVCIsImFjY2Vzc1Rva2VuRXhwaXJ5IiwiSldUX0FDQ0VTU19FWFBJUlkiLCJyZWZyZXNoVG9rZW5FeHBpcnkiLCJKV1RfUkVGUkVTSF9FWFBJUlkiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiZ2VuZXJhdGVUb2tlbnMiLCJwYXlsb2FkIiwiYWNjZXNzVG9rZW4iLCJzaWduIiwiZXhwaXJlc0luIiwiaXNzdWVyIiwiYXVkaWVuY2UiLCJyZWZyZXNoVG9rZW4iLCJ1c2VySWQiLCJ0eXBlIiwidmVyaWZ5QWNjZXNzVG9rZW4iLCJ0b2tlbiIsImRlY29kZWQiLCJ2ZXJpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJ2ZXJpZnlSZWZyZXNoVG9rZW4iLCJFcnJvciIsImV4dHJhY3RUb2tlbkZyb21SZXF1ZXN0IiwicmVxdWVzdCIsImF1dGhIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0Iiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsInRva2VuQ29va2llIiwidmFsdWUiLCJzZXRUb2tlbkNvb2tpZXMiLCJjb29raWVTdG9yZSIsInNldCIsImh0dHBPbmx5Iiwic2VjdXJlIiwic2FtZVNpdGUiLCJtYXhBZ2UiLCJwYXRoIiwiY2xlYXJUb2tlbkNvb2tpZXMiLCJkZWxldGUiLCJnZXRVc2VyRnJvbVJlcXVlc3QiLCJyZWZyZXNoQWNjZXNzVG9rZW4iLCJ1c2VyRGF0YSIsIm5ld0FjY2Vzc1Rva2VuIiwiand0QXV0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8566\n");

/***/ })

});