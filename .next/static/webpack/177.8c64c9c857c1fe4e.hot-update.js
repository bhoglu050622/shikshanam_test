"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"](177,{

/***/ 56:
/*!************************************!*\
  !*** ./lib/services/graphy-api.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   graphyAPI: () => (/* binding */ graphyAPI)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ 41463);\n// Graphy API Configuration\nconst GRAPHY_CONFIG = {\n    baseUrl: 'https://api.ongraphy.com',\n    mid: process.env.GRAPHY_MID || 'hyperquest',\n    apiKey: process.env.GRAPHY_API_KEY || '52bae682-186d-44af-a933-c6b6808596c9'\n};\nclass GraphyAPIService {\n    /**\n   * Get learner information by ID\n   */ async getLearner(learnerId) {\n        let includeCourseInfo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            const url = \"\".concat(this.baseUrl, \"/public/v1/learners/\").concat(learnerId, \"?mid=\").concat(this.mid, \"&key=\").concat(this.apiKey, \"&courseInfo=\").concat(includeCourseInfo);\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error fetching learner:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        }\n    }\n    /**\n   * Get learner usage statistics\n   */ async getLearnerUsage(learnerId, productId, date) {\n        try {\n            const dateParam = date ? \"&date=\".concat(date) : '';\n            const url = \"\".concat(this.baseUrl, \"/public/v1/learners/\").concat(learnerId, \"/usage?mid=\").concat(this.mid, \"&key=\").concat(this.apiKey, \"&productId=\").concat(productId).concat(dateParam);\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error fetching learner usage:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        }\n    }\n    /**\n   * Get learner discussions\n   */ async getLearnerDiscussions(learnerId, startDate, endDate) {\n        try {\n            const startParam = startDate ? \"&startDate=\".concat(startDate) : '';\n            const endParam = endDate ? \"&endDate=\".concat(endDate) : '';\n            const url = \"\".concat(this.baseUrl, \"/public/v1/learners/\").concat(learnerId, \"/discussions?mid=\").concat(this.mid, \"&key=\").concat(this.apiKey).concat(startParam).concat(endParam);\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error fetching learner discussions:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        }\n    }\n    /**\n   * Get live class attendees\n   */ async getLiveClassAttendees(liveClassId) {\n        let skip = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, limit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;\n        try {\n            const url = \"\".concat(this.baseUrl, \"/t/api/public/v3/products/liveclass/attendees?mid=\").concat(this.mid, \"&key=\").concat(this.apiKey, \"&skip=\").concat(skip, \"&limit=\").concat(limit, \"&liveClassId=\").concat(liveClassId);\n            const response = await fetch(url, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error fetching live class attendees:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        }\n    }\n    /**\n   * Reset learner device registrations\n   */ async resetLearnerDevice(email) {\n        try {\n            const url = \"\".concat(this.baseUrl, \"/t/api/public/v3/learners/reset-device?mid=\").concat(this.mid, \"&key=\").concat(this.apiKey, \"&email=\").concat(email);\n            const response = await fetch(url, {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error resetting learner device:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        }\n    }\n    /**\n   * Create or update learner\n   */ async createOrUpdateLearner(learnerData) {\n        try {\n            const formData = new URLSearchParams();\n            formData.append('mid', this.mid);\n            formData.append('key', this.apiKey);\n            formData.append('email', learnerData.email);\n            if (learnerData.name) formData.append('name', learnerData.name);\n            if (learnerData.password) formData.append('password', learnerData.password);\n            if (learnerData.mobile) formData.append('mobile', learnerData.mobile);\n            if (learnerData.sendEmail !== undefined) formData.append('sendEmail', learnerData.sendEmail.toString());\n            if (learnerData.customFields) formData.append('customFields', JSON.stringify(learnerData.customFields));\n            const response = await fetch(\"\".concat(this.baseUrl, \"/t/api/public/v3/learners/update\"), {\n                method: 'PATCH',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                },\n                body: formData\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error creating/updating learner:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        }\n    }\n    /**\n   * Reset iOS screenshot restriction\n   */ async resetIOSScreenshotRestriction(email) {\n        try {\n            const url = \"\".concat(this.baseUrl, \"/t/api/public/v3/learners/reset/ios/screenshot?mid=\").concat(this.mid, \"&key=\").concat(this.apiKey, \"&email=\").concat(email);\n            const response = await fetch(url, {\n                method: 'PATCH',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error(\"HTTP error! status: \".concat(response.status));\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data\n            };\n        } catch (error) {\n            console.error('Error resetting iOS screenshot restriction:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred'\n            };\n        }\n    }\n    /**\n   * Helper method to format dates for API calls\n   */ formatDate(date) {\n        return date.toISOString().split('T')[0].replace(/-/g, '/');\n    }\n    /**\n   * Helper method to validate email format\n   */ isValidEmail(email) {\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        return emailRegex.test(email);\n    }\n    constructor(){\n        this.baseUrl = GRAPHY_CONFIG.baseUrl;\n        this.mid = GRAPHY_CONFIG.mid;\n        this.apiKey = GRAPHY_CONFIG.apiKey;\n    }\n}\n// Export singleton instance\nconst graphyAPI = new GraphyAPIService();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GraphyAPIService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TTNCLFdBQVcsTUFBTUMsTUFBTUYsS0FBSztnQkFDaENHLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBRUEsSUFBSSxDQUFDSCxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUMsTUFBTSx1QkFBdUMsT0FBaEJMLFNBQVNNLE1BQU07WUFDeEQ7WUFFQSxNQUFNQyxPQUFPLE1BQU1QLFNBQVNRLElBQUk7WUFDaEMsT0FBTztnQkFBRUMsU0FBUztnQkFBTUY7WUFBSztRQUMvQixFQUFFLE9BQU9HLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtDQUErQ0E7WUFDN0QsT0FBTztnQkFDTEQsU0FBUztnQkFDVEMsT0FBT0EsaUJBQWlCTCxRQUFRSyxNQUFNRSxPQUFPLEdBQUc7WUFDbEQ7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRGdDLFdBQVc3QixJQUFVLEVBQVU7UUFDN0IsT0FBT0EsS0FBSzhCLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNDLE9BQU8sQ0FBQyxNQUFNO0lBQ3hEO0lBRUE7O0dBRUMsR0FDREMsYUFBYXJCLEtBQWEsRUFBVztRQUNuQyxNQUFNc0IsYUFBYTtRQUNuQixPQUFPQSxXQUFXQyxJQUFJLENBQUN2QjtJQUN6QjtJQTlQQSxhQUFjO1FBQ1osSUFBSSxDQUFDdkMsT0FBTyxHQUFHRCxjQUFjQyxPQUFPO1FBQ3BDLElBQUksQ0FBQ0MsR0FBRyxHQUFHRixjQUFjRSxHQUFHO1FBQzVCLElBQUksQ0FBQ0ksTUFBTSxHQUFHTixjQUFjTSxNQUFNO0lBQ3BDO0FBMlBGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU0wRCxZQUFZLElBQUl4RCxtQkFBa0I7QUFDL0MsaUVBQWVBLGdCQUFnQkEsRUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FtYW5iaG9nYWwvRGVza3RvcC9zaGlrc2hhL3NoaWtzaGFuYW1fbmV3L2xpYi9zZXJ2aWNlcy9ncmFwaHktYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdPT0dMRV9PQVVUSF9DT05GSUcgfSBmcm9tICdAL2xpYi9jb25maWcvYXV0aCdcblxuLy8gR3JhcGh5IEFQSSBDb25maWd1cmF0aW9uXG5jb25zdCBHUkFQSFlfQ09ORklHID0ge1xuICBiYXNlVXJsOiAnaHR0cHM6Ly9hcGkub25ncmFwaHkuY29tJyxcbiAgbWlkOiBwcm9jZXNzLmVudi5HUkFQSFlfTUlEIHx8ICdoeXBlcnF1ZXN0JyxcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5HUkFQSFlfQVBJX0tFWSB8fCAnNTJiYWU2ODItMTg2ZC00NGFmLWE5MzMtYzZiNjgwODU5NmM5Jyxcbn1cblxuLy8gVHlwZXMgZm9yIEdyYXBoeSBBUEkgcmVzcG9uc2VzXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoeUxlYXJuZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgbmFtZT86IHN0cmluZ1xuICBtb2JpbGU/OiBzdHJpbmdcbiAgY3VzdG9tRmllbGRzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBjb3Vyc2VJbmZvPzoge1xuICAgIGVucm9sbGVkQ291cnNlczogYW55W11cbiAgICBwcm9ncmVzczogUmVjb3JkPHN0cmluZywgbnVtYmVyPlxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGh5VXNhZ2Uge1xuICBsZWFybmVySWQ6IHN0cmluZ1xuICBwcm9kdWN0SWQ6IHN0cmluZ1xuICB1c2FnZToge1xuICAgIHRvdGFsVGltZTogbnVtYmVyXG4gICAgc2Vzc2lvbnM6IG51bWJlclxuICAgIGxhc3RBY2Nlc3NlZDogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmFwaHlEaXNjdXNzaW9uIHtcbiAgaWQ6IHN0cmluZ1xuICBjb250ZW50OiBzdHJpbmdcbiAgdGltZXN0YW1wOiBzdHJpbmdcbiAgY291cnNlSWQ/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmFwaHlMaXZlQ2xhc3NBdHRlbmRlZSB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgam9pblRpbWU6IHN0cmluZ1xuICBkdXJhdGlvbjogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGh5QVBJUmVzcG9uc2U8VD4ge1xuICBzdWNjZXNzOiBib29sZWFuXG4gIGRhdGE/OiBUXG4gIGVycm9yPzogc3RyaW5nXG4gIG1lc3NhZ2U/OiBzdHJpbmdcbn1cblxuY2xhc3MgR3JhcGh5QVBJU2VydmljZSB7XG4gIHByaXZhdGUgYmFzZVVybDogc3RyaW5nXG4gIHByaXZhdGUgbWlkOiBzdHJpbmdcbiAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmFzZVVybCA9IEdSQVBIWV9DT05GSUcuYmFzZVVybFxuICAgIHRoaXMubWlkID0gR1JBUEhZX0NPTkZJRy5taWRcbiAgICB0aGlzLmFwaUtleSA9IEdSQVBIWV9DT05GSUcuYXBpS2V5XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxlYXJuZXIgaW5mb3JtYXRpb24gYnkgSURcbiAgICovXG4gIGFzeW5jIGdldExlYXJuZXIobGVhcm5lcklkOiBzdHJpbmcsIGluY2x1ZGVDb3Vyc2VJbmZvID0gZmFsc2UpOiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPEdyYXBoeUxlYXJuZXI+PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0vcHVibGljL3YxL2xlYXJuZXJzLyR7bGVhcm5lcklkfT9taWQ9JHt0aGlzLm1pZH0ma2V5PSR7dGhpcy5hcGlLZXl9JmNvdXJzZUluZm89JHtpbmNsdWRlQ291cnNlSW5mb31gXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGxlYXJuZXI6JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCcgXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsZWFybmVyIHVzYWdlIHN0YXRpc3RpY3NcbiAgICovXG4gIGFzeW5jIGdldExlYXJuZXJVc2FnZShcbiAgICBsZWFybmVySWQ6IHN0cmluZywgXG4gICAgcHJvZHVjdElkOiBzdHJpbmcsIFxuICAgIGRhdGU/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxHcmFwaHlVc2FnZT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0ZVBhcmFtID0gZGF0ZSA/IGAmZGF0ZT0ke2RhdGV9YCA6ICcnXG4gICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9L3B1YmxpYy92MS9sZWFybmVycy8ke2xlYXJuZXJJZH0vdXNhZ2U/bWlkPSR7dGhpcy5taWR9JmtleT0ke3RoaXMuYXBpS2V5fSZwcm9kdWN0SWQ9JHtwcm9kdWN0SWR9JHtkYXRlUGFyYW19YFxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGEgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBsZWFybmVyIHVzYWdlOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHsgXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnIFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbGVhcm5lciBkaXNjdXNzaW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0TGVhcm5lckRpc2N1c3Npb25zKFxuICAgIGxlYXJuZXJJZDogc3RyaW5nLCBcbiAgICBzdGFydERhdGU/OiBzdHJpbmcsIFxuICAgIGVuZERhdGU/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxHcmFwaHlEaXNjdXNzaW9uW10+PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0UGFyYW0gPSBzdGFydERhdGUgPyBgJnN0YXJ0RGF0ZT0ke3N0YXJ0RGF0ZX1gIDogJydcbiAgICAgIGNvbnN0IGVuZFBhcmFtID0gZW5kRGF0ZSA/IGAmZW5kRGF0ZT0ke2VuZERhdGV9YCA6ICcnXG4gICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9L3B1YmxpYy92MS9sZWFybmVycy8ke2xlYXJuZXJJZH0vZGlzY3Vzc2lvbnM/bWlkPSR7dGhpcy5taWR9JmtleT0ke3RoaXMuYXBpS2V5fSR7c3RhcnRQYXJhbX0ke2VuZFBhcmFtfWBcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbGVhcm5lciBkaXNjdXNzaW9uczonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxpdmUgY2xhc3MgYXR0ZW5kZWVzXG4gICAqL1xuICBhc3luYyBnZXRMaXZlQ2xhc3NBdHRlbmRlZXMoXG4gICAgbGl2ZUNsYXNzSWQ6IHN0cmluZywgXG4gICAgc2tpcCA9IDAsIFxuICAgIGxpbWl0ID0gMTBcbiAgKTogUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxHcmFwaHlMaXZlQ2xhc3NBdHRlbmRlZVtdPj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9L3QvYXBpL3B1YmxpYy92My9wcm9kdWN0cy9saXZlY2xhc3MvYXR0ZW5kZWVzP21pZD0ke3RoaXMubWlkfSZrZXk9JHt0aGlzLmFwaUtleX0mc2tpcD0ke3NraXB9JmxpbWl0PSR7bGltaXR9JmxpdmVDbGFzc0lkPSR7bGl2ZUNsYXNzSWR9YFxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGEgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBsaXZlIGNsYXNzIGF0dGVuZGVlczonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgbGVhcm5lciBkZXZpY2UgcmVnaXN0cmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgcmVzZXRMZWFybmVyRGV2aWNlKGVtYWlsOiBzdHJpbmcpOiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPGFueT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS90L2FwaS9wdWJsaWMvdjMvbGVhcm5lcnMvcmVzZXQtZGV2aWNlP21pZD0ke3RoaXMubWlkfSZrZXk9JHt0aGlzLmFwaUtleX0mZW1haWw9JHtlbWFpbH1gXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc2V0dGluZyBsZWFybmVyIGRldmljZTonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIG9yIHVwZGF0ZSBsZWFybmVyXG4gICAqL1xuICBhc3luYyBjcmVhdGVPclVwZGF0ZUxlYXJuZXIobGVhcm5lckRhdGE6IHtcbiAgICBlbWFpbDogc3RyaW5nXG4gICAgbmFtZT86IHN0cmluZ1xuICAgIHBhc3N3b3JkPzogc3RyaW5nXG4gICAgbW9iaWxlPzogc3RyaW5nXG4gICAgc2VuZEVtYWlsPzogYm9vbGVhblxuICAgIGN1c3RvbUZpZWxkcz86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgfSk6IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8R3JhcGh5TGVhcm5lcj4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnbWlkJywgdGhpcy5taWQpXG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2tleScsIHRoaXMuYXBpS2V5KVxuICAgICAgZm9ybURhdGEuYXBwZW5kKCdlbWFpbCcsIGxlYXJuZXJEYXRhLmVtYWlsKVxuICAgICAgXG4gICAgICBpZiAobGVhcm5lckRhdGEubmFtZSkgZm9ybURhdGEuYXBwZW5kKCduYW1lJywgbGVhcm5lckRhdGEubmFtZSlcbiAgICAgIGlmIChsZWFybmVyRGF0YS5wYXNzd29yZCkgZm9ybURhdGEuYXBwZW5kKCdwYXNzd29yZCcsIGxlYXJuZXJEYXRhLnBhc3N3b3JkKVxuICAgICAgaWYgKGxlYXJuZXJEYXRhLm1vYmlsZSkgZm9ybURhdGEuYXBwZW5kKCdtb2JpbGUnLCBsZWFybmVyRGF0YS5tb2JpbGUpXG4gICAgICBpZiAobGVhcm5lckRhdGEuc2VuZEVtYWlsICE9PSB1bmRlZmluZWQpIGZvcm1EYXRhLmFwcGVuZCgnc2VuZEVtYWlsJywgbGVhcm5lckRhdGEuc2VuZEVtYWlsLnRvU3RyaW5nKCkpXG4gICAgICBpZiAobGVhcm5lckRhdGEuY3VzdG9tRmllbGRzKSBmb3JtRGF0YS5hcHBlbmQoJ2N1c3RvbUZpZWxkcycsIEpTT04uc3RyaW5naWZ5KGxlYXJuZXJEYXRhLmN1c3RvbUZpZWxkcykpXG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS90L2FwaS9wdWJsaWMvdjMvbGVhcm5lcnMvdXBkYXRlYCwge1xuICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhXG4gICAgICB9KVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcvdXBkYXRpbmcgbGVhcm5lcjonLCBlcnJvcilcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgaU9TIHNjcmVlbnNob3QgcmVzdHJpY3Rpb25cbiAgICovXG4gIGFzeW5jIHJlc2V0SU9TU2NyZWVuc2hvdFJlc3RyaWN0aW9uKGVtYWlsOiBzdHJpbmcpOiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPGFueT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS90L2FwaS9wdWJsaWMvdjMvbGVhcm5lcnMvcmVzZXQvaW9zL3NjcmVlbnNob3Q/bWlkPSR7dGhpcy5taWR9JmtleT0ke3RoaXMuYXBpS2V5fSZlbWFpbD0ke2VtYWlsfWBcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGEgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNldHRpbmcgaU9TIHNjcmVlbnNob3QgcmVzdHJpY3Rpb246JywgZXJyb3IpXG4gICAgICByZXR1cm4geyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCcgXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gZm9ybWF0IGRhdGVzIGZvciBBUEkgY2FsbHNcbiAgICovXG4gIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLnJlcGxhY2UoLy0vZywgJy8nKVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gdmFsaWRhdGUgZW1haWwgZm9ybWF0XG4gICAqL1xuICBpc1ZhbGlkRW1haWwoZW1haWw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskL1xuICAgIHJldHVybiBlbWFpbFJlZ2V4LnRlc3QoZW1haWwpXG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGdyYXBoeUFQSSA9IG5ldyBHcmFwaHlBUElTZXJ2aWNlKClcbmV4cG9ydCBkZWZhdWx0IEdyYXBoeUFQSVNlcnZpY2VcbiJdLCJuYW1lcyI6WyJHUkFQSFlfQ09ORklHIiwiYmFzZVVybCIsIm1pZCIsInByb2Nlc3MiLCJlbnYiLCJHUkFQSFlfTUlEIiwiYXBpS2V5IiwiR1JBUEhZX0FQSV9LRVkiLCJHcmFwaHlBUElTZXJ2aWNlIiwiZ2V0TGVhcm5lciIsImxlYXJuZXJJZCIsImluY2x1ZGVDb3Vyc2VJbmZvIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwiZXJyb3IiLCJjb25zb2xlIiwibWVzc2FnZSIsImdldExlYXJuZXJVc2FnZSIsInByb2R1Y3RJZCIsImRhdGUiLCJkYXRlUGFyYW0iLCJnZXRMZWFybmVyRGlzY3Vzc2lvbnMiLCJzdGFydERhdGUiLCJlbmREYXRlIiwic3RhcnRQYXJhbSIsImVuZFBhcmFtIiwiZ2V0TGl2ZUNsYXNzQXR0ZW5kZWVzIiwibGl2ZUNsYXNzSWQiLCJza2lwIiwibGltaXQiLCJyZXNldExlYXJuZXJEZXZpY2UiLCJlbWFpbCIsImNyZWF0ZU9yVXBkYXRlTGVhcm5lciIsImxlYXJuZXJEYXRhIiwiZm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJuYW1lIiwicGFzc3dvcmQiLCJtb2JpbGUiLCJzZW5kRW1haWwiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsImN1c3RvbUZpZWxkcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJib2R5IiwicmVzZXRJT1NTY3JlZW5zaG90UmVzdHJpY3Rpb24iLCJmb3JtYXREYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsInJlcGxhY2UiLCJpc1ZhbGlkRW1haWwiLCJlbWFpbFJlZ2V4IiwidGVzdCIsImdyYXBoeUFQSSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///56\n"));

/***/ }),

/***/ 415:
/*!****************************************************!*\
  !*** ./lib/services/graphy-package-integration.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PACKAGE_TO_GRAPHY_MAPPING: () => (/* binding */ PACKAGE_TO_GRAPHY_MAPPING),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   graphyPackageIntegration: () => (/* binding */ graphyPackageIntegration)\n/* harmony export */ });\n/* harmony import */ var _graphy_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graphy-api */ 56);\n\n// Mapping of Shikshanam packages to Graphy products\nconst PACKAGE_TO_GRAPHY_MAPPING = {\n    'sanskrit-foundations': {\n        sku: 'sanskrit-foundations',\n        graphyProductId: 'sanskrit_foundations_001',\n        graphyCourseIds: [\n            'sanskrit_alphabet_001',\n            'sanskrit_grammar_001',\n            'sanskrit_vocab_001'\n        ],\n        liveClassIds: [\n            'sanskrit_live_001'\n        ]\n    },\n    'vedic-philosophy-complete': {\n        sku: 'vedic-philosophy-complete',\n        graphyProductId: 'vedic_philosophy_001',\n        graphyCourseIds: [\n            'upanishads_001',\n            'vedanta_001',\n            'mimamsa_001'\n        ],\n        liveClassIds: [\n            'vedic_live_001'\n        ]\n    },\n    'yoga-darshan-advanced': {\n        sku: 'yoga-darshan-advanced',\n        graphyProductId: 'yoga_darshan_001',\n        graphyCourseIds: [\n            'yoga_sutras_001',\n            'yoga_philosophy_001'\n        ],\n        liveClassIds: [\n            'yoga_live_001'\n        ]\n    },\n    'emotional-intelligence-with-samkhya': {\n        sku: 'emotional-intelligence-with-samkhya',\n        graphyProductId: 'emotional_intelligence_001',\n        graphyCourseIds: [\n            'samkhya_001',\n            'emotional_intelligence_001'\n        ],\n        liveClassIds: [\n            'ei_live_001'\n        ]\n    },\n    'isha-upanishad': {\n        sku: 'isha-upanishad',\n        graphyProductId: 'isha_upanishad_001',\n        graphyCourseIds: [\n            'isha_upanishad_001'\n        ],\n        liveClassIds: [\n            'isha_live_001'\n        ]\n    },\n    'kashmir-shaivism': {\n        sku: 'kashmir-shaivism',\n        graphyProductId: 'kashmir_shaivism_001',\n        graphyCourseIds: [\n            'kashmir_shaivism_001'\n        ],\n        liveClassIds: [\n            'kashmir_live_001'\n        ]\n    },\n    'nyaya-darshan': {\n        sku: 'nyaya-darshan',\n        graphyProductId: 'nyaya_darshan_001',\n        graphyCourseIds: [\n            'nyaya_001'\n        ],\n        liveClassIds: [\n            'nyaya_live_001'\n        ]\n    },\n    'prashna-upanishad': {\n        sku: 'prashna-upanishad',\n        graphyProductId: 'prashna_upanishad_001',\n        graphyCourseIds: [\n            'prashna_upanishad_001'\n        ],\n        liveClassIds: [\n            'prashna_live_001'\n        ]\n    },\n    'samkhya-darshan': {\n        sku: 'samkhya-darshan',\n        graphyProductId: 'samkhya_darshan_001',\n        graphyCourseIds: [\n            'samkhya_001'\n        ],\n        liveClassIds: [\n            'samkhya_live_001'\n        ]\n    },\n    'tantra-darshan': {\n        sku: 'tantra-darshan',\n        graphyProductId: 'tantra_darshan_001',\n        graphyCourseIds: [\n            'tantra_001'\n        ],\n        liveClassIds: [\n            'tantra_live_001'\n        ]\n    },\n    'vaisheshik-darshan': {\n        sku: 'vaisheshik-darshan',\n        graphyProductId: 'vaisheshik_darshan_001',\n        graphyCourseIds: [\n            'vaisheshik_001'\n        ],\n        liveClassIds: [\n            'vaisheshik_live_001'\n        ]\n    },\n    'vedanta-essentials': {\n        sku: 'vedanta-essentials',\n        graphyProductId: 'vedanta_essentials_001',\n        graphyCourseIds: [\n            'vedanta_001'\n        ],\n        liveClassIds: [\n            'vedanta_live_001'\n        ]\n    },\n    'yoga-darshan': {\n        sku: 'yoga-darshan',\n        graphyProductId: 'yoga_darshan_basic_001',\n        graphyCourseIds: [\n            'yoga_basics_001'\n        ],\n        liveClassIds: [\n            'yoga_basic_live_001'\n        ]\n    }\n};\nclass GraphyPackageIntegrationService {\n    /**\n   * Create a learner in Graphy when user authenticates\n   */ async createLearnerFromAuth(userData) {\n        try {\n            const result = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.createOrUpdateLearner({\n                email: userData.email,\n                name: userData.name,\n                mobile: userData.mobile,\n                sendEmail: true,\n                customFields: {\n                    source: 'shikshanam',\n                    registrationDate: new Date().toISOString(),\n                    platform: 'web'\n                }\n            });\n            return result;\n        } catch (error) {\n            console.error('Error creating learner from auth:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to create learner'\n            };\n        }\n    }\n    /**\n   * Get learner progress for a specific package\n   */ async getLearnerProgress(learnerId, packageSku) {\n        try {\n            const mapping = PACKAGE_TO_GRAPHY_MAPPING[packageSku];\n            if (!mapping) {\n                return {\n                    success: false,\n                    error: \"Package mapping not found for SKU: \".concat(packageSku)\n                };\n            }\n            // Get learner with course info\n            const learnerResult = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.getLearner(learnerId, true);\n            if (!learnerResult.success) {\n                return learnerResult;\n            }\n            // Get usage data for the product\n            const usageResult = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.getLearnerUsage(learnerId, mapping.graphyProductId);\n            if (!usageResult.success) {\n                return usageResult;\n            }\n            return {\n                success: true,\n                data: {\n                    learner: learnerResult.data,\n                    usage: usageResult.data,\n                    packageSku,\n                    graphyProductId: mapping.graphyProductId\n                }\n            };\n        } catch (error) {\n            console.error('Error getting learner progress:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get learner progress'\n            };\n        }\n    }\n    /**\n   * Enroll learner in a package (simulate enrollment in Graphy)\n   */ async enrollLearnerInPackage(learnerId, packageSku) {\n        try {\n            const mapping = PACKAGE_TO_GRAPHY_MAPPING[packageSku];\n            if (!mapping) {\n                return {\n                    success: false,\n                    error: \"Package mapping not found for SKU: \".concat(packageSku)\n                };\n            }\n            // In a real implementation, this would call Graphy's enrollment API\n            // For now, we'll simulate successful enrollment\n            const enrollmentData = {\n                learnerId,\n                packageSku,\n                graphyProductId: mapping.graphyProductId,\n                enrolledAt: new Date().toISOString(),\n                status: 'active',\n                courses: mapping.graphyCourseIds,\n                liveClasses: mapping.liveClassIds || []\n            };\n            return {\n                success: true,\n                data: enrollmentData,\n                message: 'Successfully enrolled in package'\n            };\n        } catch (error) {\n            console.error('Error enrolling learner in package:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to enroll in package'\n            };\n        }\n    }\n    /**\n   * Get learner's enrolled packages\n   */ async getLearnerPackages(learnerId) {\n        try {\n            var _learnerResult_data_courseInfo, _learnerResult_data;\n            // Get learner with course info\n            const learnerResult = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.getLearner(learnerId, true);\n            if (!learnerResult.success) {\n                return {\n                    success: false,\n                    error: learnerResult.error || 'Failed to fetch learner data'\n                };\n            }\n            // Map Graphy course data to Shikshanam UserPackage format\n            const userPackages = [];\n            // This would typically come from Graphy's enrollment data\n            // For now, we'll simulate based on the learner's course info\n            if ((_learnerResult_data = learnerResult.data) === null || _learnerResult_data === void 0 ? void 0 : (_learnerResult_data_courseInfo = _learnerResult_data.courseInfo) === null || _learnerResult_data_courseInfo === void 0 ? void 0 : _learnerResult_data_courseInfo.enrolledCourses) {\n                const enrolledCourses = learnerResult.data.courseInfo.enrolledCourses;\n                // Group courses by package\n                const packageGroups = {};\n                enrolledCourses.forEach((course)=>{\n                    // Find which package this course belongs to\n                    for (const [sku, mapping] of Object.entries(PACKAGE_TO_GRAPHY_MAPPING)){\n                        if (mapping.graphyCourseIds.includes(course.id)) {\n                            if (!packageGroups[sku]) {\n                                packageGroups[sku] = [];\n                            }\n                            packageGroups[sku].push(course);\n                        }\n                    }\n                });\n                // Convert to UserPackage format\n                for (const [sku, courses] of Object.entries(packageGroups)){\n                    const mapping = PACKAGE_TO_GRAPHY_MAPPING[sku];\n                    if (mapping) {\n                        userPackages.push({\n                            sku,\n                            name: this.getPackageName(sku),\n                            accessExpiresAt: undefined,\n                            status: 'active',\n                            progress: this.calculateProgress(courses),\n                            nextLiveSession: undefined,\n                            availableMentorHours: 0,\n                            certificateStatus: this.getCertificateStatus(courses),\n                            includedCourses: courses.map((course)=>({\n                                    id: course.id,\n                                    title: course.title,\n                                    duration: course.duration || '4 weeks',\n                                    link: \"/courses/\".concat(course.id)\n                                }))\n                        });\n                    }\n                }\n            }\n            return {\n                success: true,\n                data: userPackages\n            };\n        } catch (error) {\n            console.error('Error getting learner packages:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get learner packages'\n            };\n        }\n    }\n    /**\n   * Get live class attendees for a package\n   */ async getLiveClassAttendees(packageSku, liveClassId) {\n        try {\n            const result = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.getLiveClassAttendees(liveClassId, 0, 100);\n            return result;\n        } catch (error) {\n            console.error('Error getting live class attendees:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get live class attendees'\n            };\n        }\n    }\n    /**\n   * Get upcoming live sessions for a package\n   */ async getUpcomingLiveSessions(packageSku) {\n        try {\n            const mapping = PACKAGE_TO_GRAPHY_MAPPING[packageSku];\n            if (!mapping || !mapping.liveClassIds) {\n                return {\n                    success: true,\n                    data: []\n                };\n            }\n            // In a real implementation, this would fetch from Graphy's live class API\n            // For now, we'll return mock data\n            const sessions = mapping.liveClassIds.map((liveClassId, index)=>({\n                    id: liveClassId,\n                    date: new Date(Date.now() + (index + 1) * 7 * 24 * 60 * 60 * 1000).toISOString(),\n                    seatRemaining: Math.floor(Math.random() * 50) + 10,\n                    maxSeats: 100,\n                    title: \"Live Session \".concat(index + 1, \" - \").concat(this.getPackageName(packageSku))\n                }));\n            return {\n                success: true,\n                data: sessions\n            };\n        } catch (error) {\n            console.error('Error getting upcoming live sessions:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get live sessions'\n            };\n        }\n    }\n    /**\n   * Get learner usage for a specific package\n   */ async getLearnerUsage(learnerId, packageSku) {\n        try {\n            const mapping = PACKAGE_TO_GRAPHY_MAPPING[packageSku];\n            if (!mapping) {\n                return {\n                    success: false,\n                    error: \"Package mapping not found for SKU: \".concat(packageSku)\n                };\n            }\n            const result = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.getLearnerUsage(learnerId, mapping.graphyProductId);\n            return result;\n        } catch (error) {\n            console.error('Error getting learner usage:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get learner usage'\n            };\n        }\n    }\n    /**\n   * Get learner discussions\n   */ async getLearnerDiscussions(learnerId, packageSku) {\n        try {\n            const result = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.getLearnerDiscussions(learnerId);\n            return result;\n        } catch (error) {\n            console.error('Error getting learner discussions:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to get learner discussions'\n            };\n        }\n    }\n    /**\n   * Reset learner device\n   */ async resetLearnerDevice(email) {\n        try {\n            const result = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.resetLearnerDevice(email);\n            return result;\n        } catch (error) {\n            console.error('Error resetting learner device:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to reset learner device'\n            };\n        }\n    }\n    /**\n   * Reset iOS screenshot restriction\n   */ async resetIOSScreenshotRestriction(email) {\n        try {\n            const result = await _graphy_api__WEBPACK_IMPORTED_MODULE_0__.graphyAPI.resetIOSScreenshotRestriction(email);\n            return result;\n        } catch (error) {\n            console.error('Error resetting iOS screenshot restriction:', error);\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Failed to reset iOS screenshot restriction'\n            };\n        }\n    }\n    // Helper methods\n    getPackageName(sku) {\n        const packageNames = {\n            'sanskrit-foundations': 'Sanskrit Foundations',\n            'vedic-philosophy-complete': 'Vedic Philosophy Complete',\n            'yoga-darshan-advanced': 'Yoga Darshan Advanced',\n            'emotional-intelligence-with-samkhya': 'Emotional Intelligence with Samkhya',\n            'isha-upanishad': 'Isha Upanishad',\n            'kashmir-shaivism': 'Kashmir Shaivism',\n            'nyaya-darshan': 'Nyaya Darshan',\n            'prashna-upanishad': 'Prashna Upanishad',\n            'samkhya-darshan': 'Samkhya Darshan',\n            'tantra-darshan': 'Tantra Darshan',\n            'vaisheshik-darshan': 'Vaisheshik Darshan',\n            'vedanta-essentials': 'Vedanta Essentials',\n            'yoga-darshan': 'Yoga Darshan'\n        };\n        return packageNames[sku] || sku;\n    }\n    calculateProgress(courses) {\n        if (!courses || courses.length === 0) return 0;\n        const totalProgress = courses.reduce((sum, course)=>sum + (course.progress || 0), 0);\n        return Math.round(totalProgress / courses.length);\n    }\n    getCertificateStatus(courses) {\n        if (!courses || courses.length === 0) return 'not_available';\n        const allCompleted = courses.every((course)=>course.progress === 100);\n        if (allCompleted) {\n            return 'issued';\n        }\n        const someCompleted = courses.some((course)=>course.progress === 100);\n        return someCompleted ? 'pending' : 'not_available';\n    }\n}\n// Export singleton instance\nconst graphyPackageIntegration = new GraphyPackageIntegrationService();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GraphyPackageIntegrationService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0EsV0FBV0EsUUFBUTRDLE1BQU0sS0FBSyxHQUFHLE9BQU87UUFFN0MsTUFBTUssZUFBZWpELFFBQVFrRCxLQUFLLENBQUMxQyxDQUFBQSxTQUFVQSxPQUFPUyxRQUFRLEtBQUs7UUFDakUsSUFBSWdDLGNBQWM7WUFDaEIsT0FBTztRQUNUO1FBRUEsTUFBTUUsZ0JBQWdCbkQsUUFBUW9ELElBQUksQ0FBQzVDLENBQUFBLFNBQVVBLE9BQU9TLFFBQVEsS0FBSztRQUNqRSxPQUFPa0MsZ0JBQWdCLFlBQVk7SUFDckM7QUFDRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNRSwyQkFBMkIsSUFBSXhGLGtDQUFpQztBQUM3RSxpRUFBZUEsK0JBQStCQSxFQUFBIiwic291cmNlcyI6WyIvVXNlcnMvYW1hbmJob2dhbC9EZXNrdG9wL3NoaWtzaGEvc2hpa3NoYW5hbV9uZXcvbGliL3NlcnZpY2VzL2dyYXBoeS1wYWNrYWdlLWludGVncmF0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdyYXBoeUFQSSwgR3JhcGh5TGVhcm5lciwgR3JhcGh5QVBJUmVzcG9uc2UgfSBmcm9tICcuL2dyYXBoeS1hcGknXG5pbXBvcnQgeyBQYWNrYWdlLCBVc2VyUGFja2FnZSwgU2Vzc2lvbiB9IGZyb20gJ0AvbGliL3R5cGVzL3BhY2thZ2VzJ1xuXG4vLyBHcmFwaHkgUHJvZHVjdCBtYXBwaW5nIGZvciBTaGlrc2hhbmFtIHBhY2thZ2VzXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoeVByb2R1Y3RNYXBwaW5nIHtcbiAgc2t1OiBzdHJpbmdcbiAgZ3JhcGh5UHJvZHVjdElkOiBzdHJpbmdcbiAgZ3JhcGh5Q291cnNlSWRzOiBzdHJpbmdbXVxuICBsaXZlQ2xhc3NJZHM/OiBzdHJpbmdbXVxufVxuXG4vLyBNYXBwaW5nIG9mIFNoaWtzaGFuYW0gcGFja2FnZXMgdG8gR3JhcGh5IHByb2R1Y3RzXG5leHBvcnQgY29uc3QgUEFDS0FHRV9UT19HUkFQSFlfTUFQUElORzogUmVjb3JkPHN0cmluZywgR3JhcGh5UHJvZHVjdE1hcHBpbmc+ID0ge1xuICAnc2Fuc2tyaXQtZm91bmRhdGlvbnMnOiB7XG4gICAgc2t1OiAnc2Fuc2tyaXQtZm91bmRhdGlvbnMnLFxuICAgIGdyYXBoeVByb2R1Y3RJZDogJ3NhbnNrcml0X2ZvdW5kYXRpb25zXzAwMScsXG4gICAgZ3JhcGh5Q291cnNlSWRzOiBbJ3NhbnNrcml0X2FscGhhYmV0XzAwMScsICdzYW5za3JpdF9ncmFtbWFyXzAwMScsICdzYW5za3JpdF92b2NhYl8wMDEnXSxcbiAgICBsaXZlQ2xhc3NJZHM6IFsnc2Fuc2tyaXRfbGl2ZV8wMDEnXVxuICB9LFxuICAndmVkaWMtcGhpbG9zb3BoeS1jb21wbGV0ZSc6IHtcbiAgICBza3U6ICd2ZWRpYy1waGlsb3NvcGh5LWNvbXBsZXRlJyxcbiAgICBncmFwaHlQcm9kdWN0SWQ6ICd2ZWRpY19waGlsb3NvcGh5XzAwMScsXG4gICAgZ3JhcGh5Q291cnNlSWRzOiBbJ3VwYW5pc2hhZHNfMDAxJywgJ3ZlZGFudGFfMDAxJywgJ21pbWFtc2FfMDAxJ10sXG4gICAgbGl2ZUNsYXNzSWRzOiBbJ3ZlZGljX2xpdmVfMDAxJ11cbiAgfSxcbiAgJ3lvZ2EtZGFyc2hhbi1hZHZhbmNlZCc6IHtcbiAgICBza3U6ICd5b2dhLWRhcnNoYW4tYWR2YW5jZWQnLFxuICAgIGdyYXBoeVByb2R1Y3RJZDogJ3lvZ2FfZGFyc2hhbl8wMDEnLFxuICAgIGdyYXBoeUNvdXJzZUlkczogWyd5b2dhX3N1dHJhc18wMDEnLCAneW9nYV9waGlsb3NvcGh5XzAwMSddLFxuICAgIGxpdmVDbGFzc0lkczogWyd5b2dhX2xpdmVfMDAxJ11cbiAgfSxcbiAgJ2Vtb3Rpb25hbC1pbnRlbGxpZ2VuY2Utd2l0aC1zYW1raHlhJzoge1xuICAgIHNrdTogJ2Vtb3Rpb25hbC1pbnRlbGxpZ2VuY2Utd2l0aC1zYW1raHlhJyxcbiAgICBncmFwaHlQcm9kdWN0SWQ6ICdlbW90aW9uYWxfaW50ZWxsaWdlbmNlXzAwMScsXG4gICAgZ3JhcGh5Q291cnNlSWRzOiBbJ3NhbWtoeWFfMDAxJywgJ2Vtb3Rpb25hbF9pbnRlbGxpZ2VuY2VfMDAxJ10sXG4gICAgbGl2ZUNsYXNzSWRzOiBbJ2VpX2xpdmVfMDAxJ11cbiAgfSxcbiAgJ2lzaGEtdXBhbmlzaGFkJzoge1xuICAgIHNrdTogJ2lzaGEtdXBhbmlzaGFkJyxcbiAgICBncmFwaHlQcm9kdWN0SWQ6ICdpc2hhX3VwYW5pc2hhZF8wMDEnLFxuICAgIGdyYXBoeUNvdXJzZUlkczogWydpc2hhX3VwYW5pc2hhZF8wMDEnXSxcbiAgICBsaXZlQ2xhc3NJZHM6IFsnaXNoYV9saXZlXzAwMSddXG4gIH0sXG4gICdrYXNobWlyLXNoYWl2aXNtJzoge1xuICAgIHNrdTogJ2thc2htaXItc2hhaXZpc20nLFxuICAgIGdyYXBoeVByb2R1Y3RJZDogJ2thc2htaXJfc2hhaXZpc21fMDAxJyxcbiAgICBncmFwaHlDb3Vyc2VJZHM6IFsna2FzaG1pcl9zaGFpdmlzbV8wMDEnXSxcbiAgICBsaXZlQ2xhc3NJZHM6IFsna2FzaG1pcl9saXZlXzAwMSddXG4gIH0sXG4gICdueWF5YS1kYXJzaGFuJzoge1xuICAgIHNrdTogJ255YXlhLWRhcnNoYW4nLFxuICAgIGdyYXBoeVByb2R1Y3RJZDogJ255YXlhX2RhcnNoYW5fMDAxJyxcbiAgICBncmFwaHlDb3Vyc2VJZHM6IFsnbnlheWFfMDAxJ10sXG4gICAgbGl2ZUNsYXNzSWRzOiBbJ255YXlhX2xpdmVfMDAxJ11cbiAgfSxcbiAgJ3ByYXNobmEtdXBhbmlzaGFkJzoge1xuICAgIHNrdTogJ3ByYXNobmEtdXBhbmlzaGFkJyxcbiAgICBncmFwaHlQcm9kdWN0SWQ6ICdwcmFzaG5hX3VwYW5pc2hhZF8wMDEnLFxuICAgIGdyYXBoeUNvdXJzZUlkczogWydwcmFzaG5hX3VwYW5pc2hhZF8wMDEnXSxcbiAgICBsaXZlQ2xhc3NJZHM6IFsncHJhc2huYV9saXZlXzAwMSddXG4gIH0sXG4gICdzYW1raHlhLWRhcnNoYW4nOiB7XG4gICAgc2t1OiAnc2Fta2h5YS1kYXJzaGFuJyxcbiAgICBncmFwaHlQcm9kdWN0SWQ6ICdzYW1raHlhX2RhcnNoYW5fMDAxJyxcbiAgICBncmFwaHlDb3Vyc2VJZHM6IFsnc2Fta2h5YV8wMDEnXSxcbiAgICBsaXZlQ2xhc3NJZHM6IFsnc2Fta2h5YV9saXZlXzAwMSddXG4gIH0sXG4gICd0YW50cmEtZGFyc2hhbic6IHtcbiAgICBza3U6ICd0YW50cmEtZGFyc2hhbicsXG4gICAgZ3JhcGh5UHJvZHVjdElkOiAndGFudHJhX2RhcnNoYW5fMDAxJyxcbiAgICBncmFwaHlDb3Vyc2VJZHM6IFsndGFudHJhXzAwMSddLFxuICAgIGxpdmVDbGFzc0lkczogWyd0YW50cmFfbGl2ZV8wMDEnXVxuICB9LFxuICAndmFpc2hlc2hpay1kYXJzaGFuJzoge1xuICAgIHNrdTogJ3ZhaXNoZXNoaWstZGFyc2hhbicsXG4gICAgZ3JhcGh5UHJvZHVjdElkOiAndmFpc2hlc2hpa19kYXJzaGFuXzAwMScsXG4gICAgZ3JhcGh5Q291cnNlSWRzOiBbJ3ZhaXNoZXNoaWtfMDAxJ10sXG4gICAgbGl2ZUNsYXNzSWRzOiBbJ3ZhaXNoZXNoaWtfbGl2ZV8wMDEnXVxuICB9LFxuICAndmVkYW50YS1lc3NlbnRpYWxzJzoge1xuICAgIHNrdTogJ3ZlZGFudGEtZXNzZW50aWFscycsXG4gICAgZ3JhcGh5UHJvZHVjdElkOiAndmVkYW50YV9lc3NlbnRpYWxzXzAwMScsXG4gICAgZ3JhcGh5Q291cnNlSWRzOiBbJ3ZlZGFudGFfMDAxJ10sXG4gICAgbGl2ZUNsYXNzSWRzOiBbJ3ZlZGFudGFfbGl2ZV8wMDEnXVxuICB9LFxuICAneW9nYS1kYXJzaGFuJzoge1xuICAgIHNrdTogJ3lvZ2EtZGFyc2hhbicsXG4gICAgZ3JhcGh5UHJvZHVjdElkOiAneW9nYV9kYXJzaGFuX2Jhc2ljXzAwMScsXG4gICAgZ3JhcGh5Q291cnNlSWRzOiBbJ3lvZ2FfYmFzaWNzXzAwMSddLFxuICAgIGxpdmVDbGFzc0lkczogWyd5b2dhX2Jhc2ljX2xpdmVfMDAxJ11cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyYXBoeVBhY2thZ2VJbnRlZ3JhdGlvbiB7XG4gIC8vIExlYXJuZXIgbWFuYWdlbWVudFxuICBjcmVhdGVMZWFybmVyRnJvbUF1dGg6ICh1c2VyRGF0YTogeyBuYW1lOiBzdHJpbmc7IGVtYWlsOiBzdHJpbmc7IG1vYmlsZT86IHN0cmluZyB9KSA9PiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPEdyYXBoeUxlYXJuZXI+PlxuICBnZXRMZWFybmVyUHJvZ3Jlc3M6IChsZWFybmVySWQ6IHN0cmluZywgcGFja2FnZVNrdTogc3RyaW5nKSA9PiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPGFueT4+XG4gIFxuICAvLyBQYWNrYWdlIGVucm9sbG1lbnRcbiAgZW5yb2xsTGVhcm5lckluUGFja2FnZTogKGxlYXJuZXJJZDogc3RyaW5nLCBwYWNrYWdlU2t1OiBzdHJpbmcpID0+IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8YW55Pj5cbiAgZ2V0TGVhcm5lclBhY2thZ2VzOiAobGVhcm5lcklkOiBzdHJpbmcpID0+IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8VXNlclBhY2thZ2VbXT4+XG4gIFxuICAvLyBMaXZlIHNlc3Npb25zXG4gIGdldExpdmVDbGFzc0F0dGVuZGVlczogKHBhY2thZ2VTa3U6IHN0cmluZywgbGl2ZUNsYXNzSWQ6IHN0cmluZykgPT4gUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxhbnlbXT4+XG4gIGdldFVwY29taW5nTGl2ZVNlc3Npb25zOiAocGFja2FnZVNrdTogc3RyaW5nKSA9PiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPFNlc3Npb25bXT4+XG4gIFxuICAvLyBVc2FnZSBhbmFseXRpY3NcbiAgZ2V0TGVhcm5lclVzYWdlOiAobGVhcm5lcklkOiBzdHJpbmcsIHBhY2thZ2VTa3U6IHN0cmluZykgPT4gUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxhbnk+PlxuICBnZXRMZWFybmVyRGlzY3Vzc2lvbnM6IChsZWFybmVySWQ6IHN0cmluZywgcGFja2FnZVNrdT86IHN0cmluZykgPT4gUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxhbnlbXT4+XG4gIFxuICAvLyBEZXZpY2UgbWFuYWdlbWVudFxuICByZXNldExlYXJuZXJEZXZpY2U6IChlbWFpbDogc3RyaW5nKSA9PiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPGFueT4+XG4gIHJlc2V0SU9TU2NyZWVuc2hvdFJlc3RyaWN0aW9uOiAoZW1haWw6IHN0cmluZykgPT4gUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxhbnk+PlxufVxuXG5jbGFzcyBHcmFwaHlQYWNrYWdlSW50ZWdyYXRpb25TZXJ2aWNlIGltcGxlbWVudHMgR3JhcGh5UGFja2FnZUludGVncmF0aW9uIHtcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsZWFybmVyIGluIEdyYXBoeSB3aGVuIHVzZXIgYXV0aGVudGljYXRlc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlTGVhcm5lckZyb21BdXRoKHVzZXJEYXRhOiB7IG5hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZzsgbW9iaWxlPzogc3RyaW5nIH0pOiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPEdyYXBoeUxlYXJuZXI+PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdyYXBoeUFQSS5jcmVhdGVPclVwZGF0ZUxlYXJuZXIoe1xuICAgICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICAgIG5hbWU6IHVzZXJEYXRhLm5hbWUsXG4gICAgICAgIG1vYmlsZTogdXNlckRhdGEubW9iaWxlLFxuICAgICAgICBzZW5kRW1haWw6IHRydWUsXG4gICAgICAgIGN1c3RvbUZpZWxkczoge1xuICAgICAgICAgIHNvdXJjZTogJ3NoaWtzaGFuYW0nLFxuICAgICAgICAgIHJlZ2lzdHJhdGlvbkRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBwbGF0Zm9ybTogJ3dlYidcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBsZWFybmVyIGZyb20gYXV0aDonLCBlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGNyZWF0ZSBsZWFybmVyJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbGVhcm5lciBwcm9ncmVzcyBmb3IgYSBzcGVjaWZpYyBwYWNrYWdlXG4gICAqL1xuICBhc3luYyBnZXRMZWFybmVyUHJvZ3Jlc3MobGVhcm5lcklkOiBzdHJpbmcsIHBhY2thZ2VTa3U6IHN0cmluZyk6IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8YW55Pj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gUEFDS0FHRV9UT19HUkFQSFlfTUFQUElOR1twYWNrYWdlU2t1XVxuICAgICAgaWYgKCFtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGBQYWNrYWdlIG1hcHBpbmcgbm90IGZvdW5kIGZvciBTS1U6ICR7cGFja2FnZVNrdX1gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGxlYXJuZXIgd2l0aCBjb3Vyc2UgaW5mb1xuICAgICAgY29uc3QgbGVhcm5lclJlc3VsdCA9IGF3YWl0IGdyYXBoeUFQSS5nZXRMZWFybmVyKGxlYXJuZXJJZCwgdHJ1ZSlcbiAgICAgIGlmICghbGVhcm5lclJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiBsZWFybmVyUmVzdWx0XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB1c2FnZSBkYXRhIGZvciB0aGUgcHJvZHVjdFxuICAgICAgY29uc3QgdXNhZ2VSZXN1bHQgPSBhd2FpdCBncmFwaHlBUEkuZ2V0TGVhcm5lclVzYWdlKGxlYXJuZXJJZCwgbWFwcGluZy5ncmFwaHlQcm9kdWN0SWQpXG4gICAgICBpZiAoIXVzYWdlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgcmV0dXJuIHVzYWdlUmVzdWx0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBsZWFybmVyOiBsZWFybmVyUmVzdWx0LmRhdGEsXG4gICAgICAgICAgdXNhZ2U6IHVzYWdlUmVzdWx0LmRhdGEsXG4gICAgICAgICAgcGFja2FnZVNrdSxcbiAgICAgICAgICBncmFwaHlQcm9kdWN0SWQ6IG1hcHBpbmcuZ3JhcGh5UHJvZHVjdElkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBsZWFybmVyIHByb2dyZXNzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gZ2V0IGxlYXJuZXIgcHJvZ3Jlc3MnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucm9sbCBsZWFybmVyIGluIGEgcGFja2FnZSAoc2ltdWxhdGUgZW5yb2xsbWVudCBpbiBHcmFwaHkpXG4gICAqL1xuICBhc3luYyBlbnJvbGxMZWFybmVySW5QYWNrYWdlKGxlYXJuZXJJZDogc3RyaW5nLCBwYWNrYWdlU2t1OiBzdHJpbmcpOiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPGFueT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWFwcGluZyA9IFBBQ0tBR0VfVE9fR1JBUEhZX01BUFBJTkdbcGFja2FnZVNrdV1cbiAgICAgIGlmICghbWFwcGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgUGFja2FnZSBtYXBwaW5nIG5vdCBmb3VuZCBmb3IgU0tVOiAke3BhY2thZ2VTa3V9YFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBjYWxsIEdyYXBoeSdzIGVucm9sbG1lbnQgQVBJXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCBzaW11bGF0ZSBzdWNjZXNzZnVsIGVucm9sbG1lbnRcbiAgICAgIGNvbnN0IGVucm9sbG1lbnREYXRhID0ge1xuICAgICAgICBsZWFybmVySWQsXG4gICAgICAgIHBhY2thZ2VTa3UsXG4gICAgICAgIGdyYXBoeVByb2R1Y3RJZDogbWFwcGluZy5ncmFwaHlQcm9kdWN0SWQsXG4gICAgICAgIGVucm9sbGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgY291cnNlczogbWFwcGluZy5ncmFwaHlDb3Vyc2VJZHMsXG4gICAgICAgIGxpdmVDbGFzc2VzOiBtYXBwaW5nLmxpdmVDbGFzc0lkcyB8fCBbXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiBlbnJvbGxtZW50RGF0YSxcbiAgICAgICAgbWVzc2FnZTogJ1N1Y2Nlc3NmdWxseSBlbnJvbGxlZCBpbiBwYWNrYWdlJ1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJvbGxpbmcgbGVhcm5lciBpbiBwYWNrYWdlOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gZW5yb2xsIGluIHBhY2thZ2UnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsZWFybmVyJ3MgZW5yb2xsZWQgcGFja2FnZXNcbiAgICovXG4gIGFzeW5jIGdldExlYXJuZXJQYWNrYWdlcyhsZWFybmVySWQ6IHN0cmluZyk6IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8VXNlclBhY2thZ2VbXT4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGxlYXJuZXIgd2l0aCBjb3Vyc2UgaW5mb1xuICAgICAgY29uc3QgbGVhcm5lclJlc3VsdCA9IGF3YWl0IGdyYXBoeUFQSS5nZXRMZWFybmVyKGxlYXJuZXJJZCwgdHJ1ZSlcbiAgICAgIGlmICghbGVhcm5lclJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGxlYXJuZXJSZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBsZWFybmVyIGRhdGEnXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWFwIEdyYXBoeSBjb3Vyc2UgZGF0YSB0byBTaGlrc2hhbmFtIFVzZXJQYWNrYWdlIGZvcm1hdFxuICAgICAgY29uc3QgdXNlclBhY2thZ2VzOiBVc2VyUGFja2FnZVtdID0gW11cbiAgICAgIFxuICAgICAgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgY29tZSBmcm9tIEdyYXBoeSdzIGVucm9sbG1lbnQgZGF0YVxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgc2ltdWxhdGUgYmFzZWQgb24gdGhlIGxlYXJuZXIncyBjb3Vyc2UgaW5mb1xuICAgICAgaWYgKGxlYXJuZXJSZXN1bHQuZGF0YT8uY291cnNlSW5mbz8uZW5yb2xsZWRDb3Vyc2VzKSB7XG4gICAgICAgIGNvbnN0IGVucm9sbGVkQ291cnNlcyA9IGxlYXJuZXJSZXN1bHQuZGF0YS5jb3Vyc2VJbmZvLmVucm9sbGVkQ291cnNlc1xuICAgICAgICBcbiAgICAgICAgLy8gR3JvdXAgY291cnNlcyBieSBwYWNrYWdlXG4gICAgICAgIGNvbnN0IHBhY2thZ2VHcm91cHM6IFJlY29yZDxzdHJpbmcsIGFueVtdPiA9IHt9XG4gICAgICAgIGVucm9sbGVkQ291cnNlcy5mb3JFYWNoKChjb3Vyc2U6IGFueSkgPT4ge1xuICAgICAgICAgIC8vIEZpbmQgd2hpY2ggcGFja2FnZSB0aGlzIGNvdXJzZSBiZWxvbmdzIHRvXG4gICAgICAgICAgZm9yIChjb25zdCBbc2t1LCBtYXBwaW5nXSBvZiBPYmplY3QuZW50cmllcyhQQUNLQUdFX1RPX0dSQVBIWV9NQVBQSU5HKSkge1xuICAgICAgICAgICAgaWYgKG1hcHBpbmcuZ3JhcGh5Q291cnNlSWRzLmluY2x1ZGVzKGNvdXJzZS5pZCkpIHtcbiAgICAgICAgICAgICAgaWYgKCFwYWNrYWdlR3JvdXBzW3NrdV0pIHtcbiAgICAgICAgICAgICAgICBwYWNrYWdlR3JvdXBzW3NrdV0gPSBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhY2thZ2VHcm91cHNbc2t1XS5wdXNoKGNvdXJzZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gQ29udmVydCB0byBVc2VyUGFja2FnZSBmb3JtYXRcbiAgICAgICAgZm9yIChjb25zdCBbc2t1LCBjb3Vyc2VzXSBvZiBPYmplY3QuZW50cmllcyhwYWNrYWdlR3JvdXBzKSkge1xuICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBQQUNLQUdFX1RPX0dSQVBIWV9NQVBQSU5HW3NrdV1cbiAgICAgICAgICBpZiAobWFwcGluZykge1xuICAgICAgICAgICAgdXNlclBhY2thZ2VzLnB1c2goe1xuICAgICAgICAgICAgICBza3UsXG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMuZ2V0UGFja2FnZU5hbWUoc2t1KSxcbiAgICAgICAgICAgICAgYWNjZXNzRXhwaXJlc0F0OiB1bmRlZmluZWQsIC8vIExpZmV0aW1lIGFjY2Vzc1xuICAgICAgICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICAgICAgICBwcm9ncmVzczogdGhpcy5jYWxjdWxhdGVQcm9ncmVzcyhjb3Vyc2VzKSxcbiAgICAgICAgICAgICAgbmV4dExpdmVTZXNzaW9uOiB1bmRlZmluZWQsIC8vIFdvdWxkIGJlIHBvcHVsYXRlZCBmcm9tIGxpdmUgY2xhc3MgZGF0YVxuICAgICAgICAgICAgICBhdmFpbGFibGVNZW50b3JIb3VyczogMCwgLy8gV291bGQgY29tZSBmcm9tIHBhY2thZ2UgY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZVN0YXR1czogdGhpcy5nZXRDZXJ0aWZpY2F0ZVN0YXR1cyhjb3Vyc2VzKSxcbiAgICAgICAgICAgICAgaW5jbHVkZWRDb3Vyc2VzOiBjb3Vyc2VzLm1hcChjb3Vyc2UgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogY291cnNlLmlkLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjb3Vyc2UudGl0bGUsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGNvdXJzZS5kdXJhdGlvbiB8fCAnNCB3ZWVrcycsXG4gICAgICAgICAgICAgICAgbGluazogYC9jb3Vyc2VzLyR7Y291cnNlLmlkfWBcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB1c2VyUGFja2FnZXNcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBsZWFybmVyIHBhY2thZ2VzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gZ2V0IGxlYXJuZXIgcGFja2FnZXMnXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsaXZlIGNsYXNzIGF0dGVuZGVlcyBmb3IgYSBwYWNrYWdlXG4gICAqL1xuICBhc3luYyBnZXRMaXZlQ2xhc3NBdHRlbmRlZXMocGFja2FnZVNrdTogc3RyaW5nLCBsaXZlQ2xhc3NJZDogc3RyaW5nKTogUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxhbnlbXT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3JhcGh5QVBJLmdldExpdmVDbGFzc0F0dGVuZGVlcyhsaXZlQ2xhc3NJZCwgMCwgMTAwKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGxpdmUgY2xhc3MgYXR0ZW5kZWVzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gZ2V0IGxpdmUgY2xhc3MgYXR0ZW5kZWVzJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXBjb21pbmcgbGl2ZSBzZXNzaW9ucyBmb3IgYSBwYWNrYWdlXG4gICAqL1xuICBhc3luYyBnZXRVcGNvbWluZ0xpdmVTZXNzaW9ucyhwYWNrYWdlU2t1OiBzdHJpbmcpOiBQcm9taXNlPEdyYXBoeUFQSVJlc3BvbnNlPFNlc3Npb25bXT4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWFwcGluZyA9IFBBQ0tBR0VfVE9fR1JBUEhZX01BUFBJTkdbcGFja2FnZVNrdV1cbiAgICAgIGlmICghbWFwcGluZyB8fCAhbWFwcGluZy5saXZlQ2xhc3NJZHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGZldGNoIGZyb20gR3JhcGh5J3MgbGl2ZSBjbGFzcyBBUElcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHJldHVybiBtb2NrIGRhdGFcbiAgICAgIGNvbnN0IHNlc3Npb25zOiBTZXNzaW9uW10gPSBtYXBwaW5nLmxpdmVDbGFzc0lkcy5tYXAoKGxpdmVDbGFzc0lkLCBpbmRleCkgPT4gKHtcbiAgICAgICAgaWQ6IGxpdmVDbGFzc0lkLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgKGluZGV4ICsgMSkgKiA3ICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSwgLy8gTmV4dCB3ZWVrXG4gICAgICAgIHNlYXRSZW1haW5pbmc6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSArIDEwLFxuICAgICAgICBtYXhTZWF0czogMTAwLFxuICAgICAgICB0aXRsZTogYExpdmUgU2Vzc2lvbiAke2luZGV4ICsgMX0gLSAke3RoaXMuZ2V0UGFja2FnZU5hbWUocGFja2FnZVNrdSl9YFxuICAgICAgfSkpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHNlc3Npb25zXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXBjb21pbmcgbGl2ZSBzZXNzaW9uczonLCBlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGdldCBsaXZlIHNlc3Npb25zJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbGVhcm5lciB1c2FnZSBmb3IgYSBzcGVjaWZpYyBwYWNrYWdlXG4gICAqL1xuICBhc3luYyBnZXRMZWFybmVyVXNhZ2UobGVhcm5lcklkOiBzdHJpbmcsIHBhY2thZ2VTa3U6IHN0cmluZyk6IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8YW55Pj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gUEFDS0FHRV9UT19HUkFQSFlfTUFQUElOR1twYWNrYWdlU2t1XVxuICAgICAgaWYgKCFtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGBQYWNrYWdlIG1hcHBpbmcgbm90IGZvdW5kIGZvciBTS1U6ICR7cGFja2FnZVNrdX1gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3JhcGh5QVBJLmdldExlYXJuZXJVc2FnZShsZWFybmVySWQsIG1hcHBpbmcuZ3JhcGh5UHJvZHVjdElkKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGxlYXJuZXIgdXNhZ2U6JywgZXJyb3IpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBnZXQgbGVhcm5lciB1c2FnZSdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGxlYXJuZXIgZGlzY3Vzc2lvbnNcbiAgICovXG4gIGFzeW5jIGdldExlYXJuZXJEaXNjdXNzaW9ucyhsZWFybmVySWQ6IHN0cmluZywgcGFja2FnZVNrdT86IHN0cmluZyk6IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8YW55W10+PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdyYXBoeUFQSS5nZXRMZWFybmVyRGlzY3Vzc2lvbnMobGVhcm5lcklkKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGxlYXJuZXIgZGlzY3Vzc2lvbnM6JywgZXJyb3IpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBnZXQgbGVhcm5lciBkaXNjdXNzaW9ucydcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgbGVhcm5lciBkZXZpY2VcbiAgICovXG4gIGFzeW5jIHJlc2V0TGVhcm5lckRldmljZShlbWFpbDogc3RyaW5nKTogUHJvbWlzZTxHcmFwaHlBUElSZXNwb25zZTxhbnk+PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdyYXBoeUFQSS5yZXNldExlYXJuZXJEZXZpY2UoZW1haWwpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc2V0dGluZyBsZWFybmVyIGRldmljZTonLCBlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHJlc2V0IGxlYXJuZXIgZGV2aWNlJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBpT1Mgc2NyZWVuc2hvdCByZXN0cmljdGlvblxuICAgKi9cbiAgYXN5bmMgcmVzZXRJT1NTY3JlZW5zaG90UmVzdHJpY3Rpb24oZW1haWw6IHN0cmluZyk6IFByb21pc2U8R3JhcGh5QVBJUmVzcG9uc2U8YW55Pj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBncmFwaHlBUEkucmVzZXRJT1NTY3JlZW5zaG90UmVzdHJpY3Rpb24oZW1haWwpXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlc2V0dGluZyBpT1Mgc2NyZWVuc2hvdCByZXN0cmljdGlvbjonLCBlcnJvcilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHJlc2V0IGlPUyBzY3JlZW5zaG90IHJlc3RyaWN0aW9uJ1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2RzXG4gIHByaXZhdGUgZ2V0UGFja2FnZU5hbWUoc2t1OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdzYW5za3JpdC1mb3VuZGF0aW9ucyc6ICdTYW5za3JpdCBGb3VuZGF0aW9ucycsXG4gICAgICAndmVkaWMtcGhpbG9zb3BoeS1jb21wbGV0ZSc6ICdWZWRpYyBQaGlsb3NvcGh5IENvbXBsZXRlJyxcbiAgICAgICd5b2dhLWRhcnNoYW4tYWR2YW5jZWQnOiAnWW9nYSBEYXJzaGFuIEFkdmFuY2VkJyxcbiAgICAgICdlbW90aW9uYWwtaW50ZWxsaWdlbmNlLXdpdGgtc2Fta2h5YSc6ICdFbW90aW9uYWwgSW50ZWxsaWdlbmNlIHdpdGggU2Fta2h5YScsXG4gICAgICAnaXNoYS11cGFuaXNoYWQnOiAnSXNoYSBVcGFuaXNoYWQnLFxuICAgICAgJ2thc2htaXItc2hhaXZpc20nOiAnS2FzaG1pciBTaGFpdmlzbScsXG4gICAgICAnbnlheWEtZGFyc2hhbic6ICdOeWF5YSBEYXJzaGFuJyxcbiAgICAgICdwcmFzaG5hLXVwYW5pc2hhZCc6ICdQcmFzaG5hIFVwYW5pc2hhZCcsXG4gICAgICAnc2Fta2h5YS1kYXJzaGFuJzogJ1NhbWtoeWEgRGFyc2hhbicsXG4gICAgICAndGFudHJhLWRhcnNoYW4nOiAnVGFudHJhIERhcnNoYW4nLFxuICAgICAgJ3ZhaXNoZXNoaWstZGFyc2hhbic6ICdWYWlzaGVzaGlrIERhcnNoYW4nLFxuICAgICAgJ3ZlZGFudGEtZXNzZW50aWFscyc6ICdWZWRhbnRhIEVzc2VudGlhbHMnLFxuICAgICAgJ3lvZ2EtZGFyc2hhbic6ICdZb2dhIERhcnNoYW4nXG4gICAgfVxuICAgIHJldHVybiBwYWNrYWdlTmFtZXNbc2t1XSB8fCBza3VcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUHJvZ3Jlc3MoY291cnNlczogYW55W10pOiBudW1iZXIge1xuICAgIGlmICghY291cnNlcyB8fCBjb3Vyc2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcbiAgICBcbiAgICBjb25zdCB0b3RhbFByb2dyZXNzID0gY291cnNlcy5yZWR1Y2UoKHN1bSwgY291cnNlKSA9PiBzdW0gKyAoY291cnNlLnByb2dyZXNzIHx8IDApLCAwKVxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRvdGFsUHJvZ3Jlc3MgLyBjb3Vyc2VzLmxlbmd0aClcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2VydGlmaWNhdGVTdGF0dXMoY291cnNlczogYW55W10pOiAnbm90X2F2YWlsYWJsZScgfCAncGVuZGluZycgfCAnaXNzdWVkJyB7XG4gICAgaWYgKCFjb3Vyc2VzIHx8IGNvdXJzZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ25vdF9hdmFpbGFibGUnXG4gICAgXG4gICAgY29uc3QgYWxsQ29tcGxldGVkID0gY291cnNlcy5ldmVyeShjb3Vyc2UgPT4gY291cnNlLnByb2dyZXNzID09PSAxMDApXG4gICAgaWYgKGFsbENvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuICdpc3N1ZWQnXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNvbWVDb21wbGV0ZWQgPSBjb3Vyc2VzLnNvbWUoY291cnNlID0+IGNvdXJzZS5wcm9ncmVzcyA9PT0gMTAwKVxuICAgIHJldHVybiBzb21lQ29tcGxldGVkID8gJ3BlbmRpbmcnIDogJ25vdF9hdmFpbGFibGUnXG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGdyYXBoeVBhY2thZ2VJbnRlZ3JhdGlvbiA9IG5ldyBHcmFwaHlQYWNrYWdlSW50ZWdyYXRpb25TZXJ2aWNlKClcbmV4cG9ydCBkZWZhdWx0IEdyYXBoeVBhY2thZ2VJbnRlZ3JhdGlvblNlcnZpY2VcbiJdLCJuYW1lcyI6WyJncmFwaHlBUEkiLCJQQUNLQUdFX1RPX0dSQVBIWV9NQVBQSU5HIiwic2t1IiwiZ3JhcGh5UHJvZHVjdElkIiwiZ3JhcGh5Q291cnNlSWRzIiwibGl2ZUNsYXNzSWRzIiwiR3JhcGh5UGFja2FnZUludGVncmF0aW9uU2VydmljZSIsImNyZWF0ZUxlYXJuZXJGcm9tQXV0aCIsInVzZXJEYXRhIiwicmVzdWx0IiwiY3JlYXRlT3JVcGRhdGVMZWFybmVyIiwiZW1haWwiLCJuYW1lIiwibW9iaWxlIiwic2VuZEVtYWlsIiwiY3VzdG9tRmllbGRzIiwic291cmNlIiwicmVnaXN0cmF0aW9uRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInBsYXRmb3JtIiwiZXJyb3IiLCJjb25zb2xlIiwic3VjY2VzcyIsIkVycm9yIiwibWVzc2FnZSIsImdldExlYXJuZXJQcm9ncmVzcyIsImxlYXJuZXJJZCIsInBhY2thZ2VTa3UiLCJtYXBwaW5nIiwibGVhcm5lclJlc3VsdCIsImdldExlYXJuZXIiLCJ1c2FnZVJlc3VsdCIsImdldExlYXJuZXJVc2FnZSIsImRhdGEiLCJsZWFybmVyIiwidXNhZ2UiLCJlbnJvbGxMZWFybmVySW5QYWNrYWdlIiwiZW5yb2xsbWVudERhdGEiLCJlbnJvbGxlZEF0Iiwic3RhdHVzIiwiY291cnNlcyIsImxpdmVDbGFzc2VzIiwiZ2V0TGVhcm5lclBhY2thZ2VzIiwidXNlclBhY2thZ2VzIiwiY291cnNlSW5mbyIsImVucm9sbGVkQ291cnNlcyIsInBhY2thZ2VHcm91cHMiLCJmb3JFYWNoIiwiY291cnNlIiwiT2JqZWN0IiwiZW50cmllcyIsImluY2x1ZGVzIiwiaWQiLCJwdXNoIiwiZ2V0UGFja2FnZU5hbWUiLCJhY2Nlc3NFeHBpcmVzQXQiLCJ1bmRlZmluZWQiLCJwcm9ncmVzcyIsImNhbGN1bGF0ZVByb2dyZXNzIiwibmV4dExpdmVTZXNzaW9uIiwiYXZhaWxhYmxlTWVudG9ySG91cnMiLCJjZXJ0aWZpY2F0ZVN0YXR1cyIsImdldENlcnRpZmljYXRlU3RhdHVzIiwiaW5jbHVkZWRDb3Vyc2VzIiwibWFwIiwidGl0bGUiLCJkdXJhdGlvbiIsImxpbmsiLCJnZXRMaXZlQ2xhc3NBdHRlbmRlZXMiLCJsaXZlQ2xhc3NJZCIsImdldFVwY29taW5nTGl2ZVNlc3Npb25zIiwic2Vzc2lvbnMiLCJpbmRleCIsImRhdGUiLCJub3ciLCJzZWF0UmVtYWluaW5nIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibWF4U2VhdHMiLCJnZXRMZWFybmVyRGlzY3Vzc2lvbnMiLCJyZXNldExlYXJuZXJEZXZpY2UiLCJyZXNldElPU1NjcmVlbnNob3RSZXN0cmljdGlvbiIsInBhY2thZ2VOYW1lcyIsImxlbmd0aCIsInRvdGFsUHJvZ3Jlc3MiLCJyZWR1Y2UiLCJzdW0iLCJyb3VuZCIsImFsbENvbXBsZXRlZCIsImV2ZXJ5Iiwic29tZUNvbXBsZXRlZCIsInNvbWUiLCJncmFwaHlQYWNrYWdlSW50ZWdyYXRpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///415\n"));

/***/ }),

/***/ 98497:
/*!******************************!*\
  !*** ./lib/auth-context.tsx ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ 35733);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ 12115);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _cookies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cookies */ 2444);\n/* harmony import */ var _services_graphy_package_integration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services/graphy-package-integration */ 415);\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [isLoggedIn, setIsLoggedIn] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCreatingLearner, setIsCreatingLearner] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [learnerCreationError, setLearnerCreationError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Define login function first to avoid initialization error\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[login]\": (userData)=>{\n            setIsLoggedIn(true);\n            setUser(userData);\n            (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.setAuthCookie)(userData);\n        }\n    }[\"AuthProvider.useCallback[login]\"], []);\n    const logout = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[logout]\": ()=>{\n            setIsLoggedIn(false);\n            setUser(null);\n            (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.deleteAuthCookie)();\n        }\n    }[\"AuthProvider.useCallback[logout]\"], []);\n    // Create Graphy learner when user logs in\n    const createGraphyLearner = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"AuthProvider.useCallback[createGraphyLearner]\": async ()=>{\n            if (!user || isCreatingLearner) return;\n            setIsCreatingLearner(true);\n            setLearnerCreationError(null);\n            try {\n                const result = await _services_graphy_package_integration__WEBPACK_IMPORTED_MODULE_3__.graphyPackageIntegration.createLearnerFromAuth({\n                    name: user.name,\n                    email: user.email,\n                    mobile: undefined\n                });\n                if (result.success && result.data) {\n                    // Update user with Graphy learner ID\n                    const updatedUser = {\n                        ...user,\n                        graphyLearnerId: result.data.id\n                    };\n                    setUser(updatedUser);\n                    (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.setAuthCookie)(updatedUser);\n                } else {\n                    setLearnerCreationError(result.error || 'Failed to create Graphy learner');\n                }\n            } catch (error) {\n                const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n                setLearnerCreationError(errorMessage);\n            } finally{\n                setIsCreatingLearner(false);\n            }\n        }\n    }[\"AuthProvider.useCallback[createGraphyLearner]\"], [\n        user,\n        isCreatingLearner\n    ]);\n    // Check for existing auth state on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            try {\n                // Check for saved auth state in cookies\n                const authData = (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.getAuthCookie)();\n                if (authData && authData.isLoggedIn && authData.user) {\n                    setIsLoggedIn(true);\n                    setUser(authData.user);\n                }\n            } catch (error) {\n                console.warn('Failed to load auth state from cookies:', error);\n                // Clear potentially corrupted auth data\n                (0,_cookies__WEBPACK_IMPORTED_MODULE_2__.deleteAuthCookie)();\n            }\n            setIsInitialized(true);\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            isLoggedIn,\n            user,\n            isInitialized,\n            login,\n            logout\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/amanbhogal/Desktop/shiksha/shikshanam_new/lib/auth-context.tsx\",\n        lineNumber: 96,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"2J2iX+XJGcryr00oCkp/T5iY+EQ=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error('useAuth must be used within an AuthProvider');\n    }\n    return context;\n}\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aGEvc2hpa3NoYW5hbV9uZXcvbGliL2F1dGgtY29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHNldEF1dGhDb29raWUsIGdldEF1dGhDb29raWUsIGRlbGV0ZUF1dGhDb29raWUgfSBmcm9tICcuL2Nvb2tpZXMnXG5pbXBvcnQgeyBncmFwaHlQYWNrYWdlSW50ZWdyYXRpb24gfSBmcm9tICcuL3NlcnZpY2VzL2dyYXBoeS1wYWNrYWdlLWludGVncmF0aW9uJ1xuXG5pbnRlcmZhY2UgVXNlciB7XG4gIG5hbWU6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIGF2YXRhcj86IHN0cmluZ1xuICBncmFwaHlMZWFybmVySWQ/OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIEF1dGhDb250ZXh0VHlwZSB7XG4gIGlzTG9nZ2VkSW46IGJvb2xlYW5cbiAgdXNlcjogVXNlciB8IG51bGxcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhblxuICBpc0NyZWF0aW5nTGVhcm5lcjogYm9vbGVhblxuICBsZWFybmVyQ3JlYXRpb25FcnJvcjogc3RyaW5nIHwgbnVsbFxuICBsb2dpbjogKHVzZXJEYXRhOiBVc2VyKSA9PiB2b2lkXG4gIGxvZ291dDogKCkgPT4gdm9pZFxuICBjcmVhdGVHcmFwaHlMZWFybmVyOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuZXhwb3J0IGZ1bmN0aW9uIEF1dGhQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFtpc0xvZ2dlZEluLCBzZXRJc0xvZ2dlZEluXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2lzSW5pdGlhbGl6ZWQsIHNldElzSW5pdGlhbGl6ZWRdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtpc0NyZWF0aW5nTGVhcm5lciwgc2V0SXNDcmVhdGluZ0xlYXJuZXJdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtsZWFybmVyQ3JlYXRpb25FcnJvciwgc2V0TGVhcm5lckNyZWF0aW9uRXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcblxuICAvLyBEZWZpbmUgbG9naW4gZnVuY3Rpb24gZmlyc3QgdG8gYXZvaWQgaW5pdGlhbGl6YXRpb24gZXJyb3JcbiAgY29uc3QgbG9naW4gPSB1c2VDYWxsYmFjaygodXNlckRhdGE6IFVzZXIpID0+IHtcbiAgICBzZXRJc0xvZ2dlZEluKHRydWUpXG4gICAgc2V0VXNlcih1c2VyRGF0YSlcbiAgICBzZXRBdXRoQ29va2llKHVzZXJEYXRhKVxuICB9LCBbXSlcblxuICBjb25zdCBsb2dvdXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0SXNMb2dnZWRJbihmYWxzZSlcbiAgICBzZXRVc2VyKG51bGwpXG4gICAgZGVsZXRlQXV0aENvb2tpZSgpXG4gIH0sIFtdKVxuXG4gIC8vIENyZWF0ZSBHcmFwaHkgbGVhcm5lciB3aGVuIHVzZXIgbG9ncyBpblxuICBjb25zdCBjcmVhdGVHcmFwaHlMZWFybmVyID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlciB8fCBpc0NyZWF0aW5nTGVhcm5lcikgcmV0dXJuXG5cbiAgICBzZXRJc0NyZWF0aW5nTGVhcm5lcih0cnVlKVxuICAgIHNldExlYXJuZXJDcmVhdGlvbkVycm9yKG51bGwpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3JhcGh5UGFja2FnZUludGVncmF0aW9uLmNyZWF0ZUxlYXJuZXJGcm9tQXV0aCh7XG4gICAgICAgIG5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIG1vYmlsZTogdW5kZWZpbmVkXG4gICAgICB9KVxuXG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgLy8gVXBkYXRlIHVzZXIgd2l0aCBHcmFwaHkgbGVhcm5lciBJRFxuICAgICAgICBjb25zdCB1cGRhdGVkVXNlciA9IHsgLi4udXNlciwgZ3JhcGh5TGVhcm5lcklkOiByZXN1bHQuZGF0YS5pZCB9XG4gICAgICAgIHNldFVzZXIodXBkYXRlZFVzZXIpXG4gICAgICAgIHNldEF1dGhDb29raWUodXBkYXRlZFVzZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRMZWFybmVyQ3JlYXRpb25FcnJvcihyZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgR3JhcGh5IGxlYXJuZXInKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ1xuICAgICAgc2V0TGVhcm5lckNyZWF0aW9uRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0NyZWF0aW5nTGVhcm5lcihmYWxzZSlcbiAgICB9XG4gIH0sIFt1c2VyLCBpc0NyZWF0aW5nTGVhcm5lcl0pXG5cbiAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGF1dGggc3RhdGUgb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgZm9yIHNhdmVkIGF1dGggc3RhdGUgaW4gY29va2llc1xuICAgICAgY29uc3QgYXV0aERhdGEgPSBnZXRBdXRoQ29va2llKClcbiAgICAgIGlmIChhdXRoRGF0YSAmJiBhdXRoRGF0YS5pc0xvZ2dlZEluICYmIGF1dGhEYXRhLnVzZXIpIHtcbiAgICAgICAgc2V0SXNMb2dnZWRJbih0cnVlKVxuICAgICAgICBzZXRVc2VyKGF1dGhEYXRhLnVzZXIpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgYXV0aCBzdGF0ZSBmcm9tIGNvb2tpZXM6JywgZXJyb3IpXG4gICAgICAvLyBDbGVhciBwb3RlbnRpYWxseSBjb3JydXB0ZWQgYXV0aCBkYXRhXG4gICAgICBkZWxldGVBdXRoQ29va2llKClcbiAgICB9XG4gICAgXG4gICAgc2V0SXNJbml0aWFsaXplZCh0cnVlKVxuICB9LCBbXSlcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBpc0xvZ2dlZEluLCB1c2VyLCBpc0luaXRpYWxpemVkLCBsb2dpbiwgbG9nb3V0IH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUF1dGgoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KVxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJylcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInNldEF1dGhDb29raWUiLCJnZXRBdXRoQ29va2llIiwiZGVsZXRlQXV0aENvb2tpZSIsImdyYXBoeVBhY2thZ2VJbnRlZ3JhdGlvbiIsIkF1dGhDb250ZXh0IiwidW5kZWZpbmVkIiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJpc0xvZ2dlZEluIiwic2V0SXNMb2dnZWRJbiIsInVzZXIiLCJzZXRVc2VyIiwiaXNJbml0aWFsaXplZCIsInNldElzSW5pdGlhbGl6ZWQiLCJpc0NyZWF0aW5nTGVhcm5lciIsInNldElzQ3JlYXRpbmdMZWFybmVyIiwibGVhcm5lckNyZWF0aW9uRXJyb3IiLCJzZXRMZWFybmVyQ3JlYXRpb25FcnJvciIsImxvZ2luIiwidXNlckRhdGEiLCJsb2dvdXQiLCJjcmVhdGVHcmFwaHlMZWFybmVyIiwicmVzdWx0IiwiY3JlYXRlTGVhcm5lckZyb21BdXRoIiwibmFtZSIsImVtYWlsIiwibW9iaWxlIiwic3VjY2VzcyIsImRhdGEiLCJ1cGRhdGVkVXNlciIsImdyYXBoeUxlYXJuZXJJZCIsImlkIiwiZXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsIm1lc3NhZ2UiLCJhdXRoRGF0YSIsImNvbnNvbGUiLCJ3YXJuIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUF1dGgiLCJjb250ZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98497\n"));

/***/ })

});